

===== FILE: src/App_Final.jsx =====

import React from 'react';
import ForumPage from './pages/ForumPage';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { LanguageProvider } from './contexts/LanguageContext';
import PrivateRoute from './components/PrivateRoute';
import Header from './components/Header';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage_Fixed';
import TopicSelectionPage from './pages/TopicSelectionPage_Updated';
import PracticeModeSelection from './pages/PracticeModeSelection';
import QuizPage from './pages/QuizPage';
import ResultsPage from './pages/ResultsPage_Updated_Fixed';
import MillionaireQuiz from './pages/MillionaireQuiz';
import LeaderboardPage from './pages/LeaderboardPage';
import ProfilePage from './pages/ProfilePage';
import HistoryPage from './pages/HistoryPage_Fixed';
import MistakeNotebookPage from './pages/MistakeNotebookPage';
import FirebaseTestPage from './pages/FirebaseTestPage';
import DebugDashboard from './pages/DebugDashboard';
import SRSReviewPage from './pages/SRSReviewPage';
import { useQuizData } from './hooks/useQuizData';
import ChemistryLoading from './components/ChemistryLoading';
import ChemStore from './components/ChemStore';
import TokenLog from './components/TokenLog';
import { ChemCityRoot } from './components/chemcity/ChemCityRoot';
import LandingPage from './pages/LandingPage';
import VisionPage from './pages/VisionPage';

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTK36yaUN-NMCkQNT-DAHgc6FMZPjUc0Yv3nYEK4TA9W2qE9V1TqVD10Tq98-wXQoAvKOZlwGWRSDkU/pub?gid=1182550140&single=true&output=csv';

function AppContent() {
  const location = useLocation();
  const { questions, loading, error } = useQuizData(SHEET_URL);
  const isNotebookRoute = location.pathname === '/notebook';
  const isChemCityRoute = location.pathname === '/chemcity';
  const noShellRoutes = new Set(['/', '/vision', '/dashboard', '/login', '/register', '/millionaire']);
  const useNoShell = noShellRoutes.has(location.pathname);
  const hideHeaderRoutes = new Set(['/', '/vision', '/login', '/register', '/millionaire']);
  const showHeader = !hideHeaderRoutes.has(location.pathname);

  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <ChemistryLoading persistKey="startup" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <div className="text-center bg-white p-8 rounded-2xl shadow-xl border-2 border-red-200">
          <p className="text-red-500 font-bold mb-2">Error loading questions</p>
          <p className="text-academic-slate">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <>
      {showHeader && <Header />}
      <div
        className={`${showHeader && !isChemCityRoute ? 'pt-[76px]' : ''} ${isChemCityRoute ? 'bg-slate-950' : ''} ${(useNoShell || isNotebookRoute || isChemCityRoute) ? '' : 'container mx-auto px-4 py-6'}`.trim()}
      >
        <Routes>
          {/* Public Routes */}
          <Route path="/" element={<LandingPage />} />
          <Route path="/vision" element={<VisionPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />

          {/* Protected Routes */}
          {/* ✅ FIXED: Now passes questions prop to DashboardPage */}
          <Route
            path="/dashboard"
            element={
              <PrivateRoute>
                <DashboardPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/home"
            element={
              <PrivateRoute>
                <Navigate to="/dashboard" replace />
              </PrivateRoute>
            }
          />

          {/* Practice Mode Selection */}
          <Route
            path="/practice"
            element={
              <PrivateRoute>
                <PracticeModeSelection questions={questions} />
              </PrivateRoute>
            }
          />

          <Route
            path="/srs-review"
            element={
              <PrivateRoute>
                <SRSReviewPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          {/* Legacy Topic Selection */}
          <Route
            path="/topics"
            element={
              <PrivateRoute>
                <TopicSelectionPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/quiz"
            element={
              <PrivateRoute>
                <QuizPage />
              </PrivateRoute>
            }
          />

          <Route
            path="/millionaire"
            element={
              <PrivateRoute>
                <MillionaireQuiz questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/results"
            element={
              <PrivateRoute>
                <ResultsPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/leaderboard"
            element={
              <PrivateRoute>
                <LeaderboardPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/profile"
            element={
              <PrivateRoute>
                <ProfilePage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/history"
            element={
              <PrivateRoute>
                <HistoryPage />
              </PrivateRoute>
            }
          />
          
          {/* Mistake Notebook - NEW */}
          <Route
            path="/notebook"
            element={
              <PrivateRoute>
                <MistakeNotebookPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/forum"
            element={
              <PrivateRoute>
                <ForumPage />
              </PrivateRoute>
            }
          />

          {/* ChemStore - FIXED: Now inside Routes */}
          <Route
            path="/store"
            element={
              <PrivateRoute>
                <ChemStore />
              </PrivateRoute>
            }
          />

          <Route
            path="/chemcity"
            element={
              <PrivateRoute>
                <ChemCityRoot />
              </PrivateRoute>
            }
          />

          {/* Token Log - FIXED: Now inside Routes */}
          <Route
            path="/token-log"
            element={
              <PrivateRoute>
                <TokenLog />
              </PrivateRoute>
            }
          />

          {/* Firebase Test Page - for debugging */}
          <Route
            path="/test-firebase"
            element={
              <PrivateRoute>
                <FirebaseTestPage />
              </PrivateRoute>
            }
          />
          
          {/* Debug Dashboard - comprehensive diagnostics */}
          <Route
            path="/debug"
            element={
              <PrivateRoute>
                <DebugDashboard />
              </PrivateRoute>
            }
          />

          {/* Catch all - redirect to dashboard */}
          <Route path="*" element={<Navigate to="/dashboard" replace />} />
        </Routes>
      </div>
    </>
  );
}

function AppShell() {
  const location = useLocation();
  const noShellRoutes = new Set(['/', '/dashboard', '/login', '/register', '/millionaire']);
  const useNoShell = noShellRoutes.has(location.pathname);

  return (
    <div className={useNoShell ? 'min-h-screen' : 'min-h-screen bg-gray-50'}>
      <AppContent />
    </div>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AuthProvider>
        <Router>
          <AppShell />
        </Router>
      </AuthProvider>
    </LanguageProvider>
  );
}

===== FILE: src/components/Header.jsx =====

import React, { useEffect, useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { Home, Trophy, User, LogOut, History, ChevronDown, Menu, X, Languages, BookOpen, MessageSquare, Gem, ShoppingBag, Clock, AlertTriangle, Pencil, Bell, BellDot, Trash2, AlertCircle, Building2 } from 'lucide-react';
import { quizStorage } from '../utils/quizStorage';
import { forumService } from '../services/forumService';

import ChemCityUserProfileIcon from './ChemCityUserProfileIcon';

export default function Header() {
    const { currentUser, logout, userProfile, profileError } = useAuth();
    const { language, toggleLanguage, isEnglish, t, tf } = useLanguage();
    const navigate = useNavigate();
    const location = useLocation();
    const [showUserMenu, setShowUserMenu] = useState(false);
    const [showMobileNav, setShowMobileNav] = useState(false);
    const [showLogoutModal, setShowLogoutModal] = useState(false);
    const [showNotifPanel, setShowNotifPanel] = useState(false);
    const [unreadCount, setUnreadCount] = useState(0);
    const [notifs, setNotifs] = useState([]);
    const [notifLimit, setNotifLimit] = useState(10);
    const [showDeleteAllNotifsConfirm, setShowDeleteAllNotifsConfirm] = useState(false);

    useEffect(() => {
        if (!currentUser || !showNotifPanel) return;
        const unsub = forumService.subscribeToNotifications(currentUser.uid, (data) => {
            setNotifs(data);
            setUnreadCount(data.filter(n => !n.read).length);
        }, notifLimit);
        return () => unsub && unsub();
    }, [currentUser, showNotifPanel, notifLimit]);

    useEffect(() => {
        if (!showNotifPanel) {
            setNotifLimit(10);
        }
    }, [showNotifPanel]);

    const handleMarkNotifRead = async (id) => {
        try {
            await forumService.markNotificationRead(id);
        } catch { /* ignore */ }
    };

    const handleMarkAllNotifsRead = async () => {
        if (!currentUser) return;
        try {
            await forumService.markAllNotificationsRead(currentUser.uid);
        } catch { /* ignore */ }
    };

    const handleDeleteNotif = async (id) => {
        try {
            await forumService.deleteNotification(id);
        } catch { /* ignore */ }
    };

    const handleDeleteAllNotifs = async () => {
        if (!currentUser) return;
        setShowDeleteAllNotifsConfirm(true);
    };

    const confirmDeleteAllNotifs = async () => {
        if (!currentUser) return;
        try {
            await forumService.deleteAllNotifications(currentUser.uid, 200);
            setShowDeleteAllNotifsConfirm(false);
        } catch { /* ignore */ }
    };

    const formatAgo = (iso) => {
        const diffMs = Date.now() - new Date(iso).getTime();
        const mins = Math.floor(diffMs / 60000);
        if (mins < 1) return t('forum.justNow');
        if (mins < 60) return tf('forum.timeAgoMinutesShort', { count: mins });
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return tf('forum.timeAgoHoursShort', { count: hrs });
        return tf('forum.timeAgoDaysShort', { count: Math.floor(hrs / 24) });
    };

    const typeLabel = (n) => {
        switch (n.type) {
            case 'like': return t('forum.likedYourComment');
            case 'reply': return t('forum.repliedToPost');
            case 'post_like': return t('forum.likedYourPost');
            case 'reply_like': return t('forum.likedYourReply');
            case 'comment_reply': return t('forum.repliedToComment');
            case 'comment_reply_like': return t('forum.likedYourReply');
            default: return t('forum.interactedWithContent');
        }
    };

    // Get tokens from userProfile with real-time sync
    const tokens = userProfile?.tokens;
    const tokensDisplay =
        profileError && (tokens === undefined || tokens === null)
            ? '—'
            : (tokens ?? 0);

    if (location.pathname === '/login' || location.pathname === '/register') {
        return null;
    }

    const isInQuiz = location.pathname === '/quiz';

    async function handleLogoutConfirm() {
        try {
            await logout();
            navigate('/');
        } catch (error) {
            console.error('Failed to log out:', error);
        }
    }

    const handleLogoutClick = () => {
        if (isInQuiz) {
            const confirmed = window.confirm(
                t('header.confirmLogoutInQuiz')
            );
            if (!confirmed) return;
            quizStorage.clearQuizData();
            handleLogoutConfirm();
        } else {
            setShowLogoutModal(true);
        }
    };

    const handleNavigation = (path, options = {}) => {
        if (isInQuiz && path !== '/quiz') {
            const confirmed = window.confirm(
                t('header.confirmLeaveQuiz')
            );
            if (!confirmed) {
                return;
            }
            quizStorage.clearQuizData();
        }

        navigate(path, options);
        setShowUserMenu(false);
        setShowMobileNav(false);
    };

    const handleNotebookHome = () => {
        // Force Mistake Notebook to reset to the 3-button home screen even if we're already on /notebook.
        // We do this by pushing a unique navigation state nonce that MistakeNotebookPage listens for.
        handleNavigation('/notebook', { state: { forceNotebookHome: Date.now() } });
    };

    const isActive = (path) => location.pathname === path;

    return (
        <>
            <header className="fixed top-0 left-0 right-0 z-50 py-1">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                    <div className="floating-island island-amber w-full md:mx-auto px-3 sm:px-3 py-0.5">
                        <div className="floating-island-content flex justify-between items-center h-14 gap-4 min-w-0">
                        {/* Logo and Brand */}
                        <div className="flex-shrink min-w-0">
                            <div className="flex items-center gap-2 cursor-pointer" onClick={() => handleNavigation('/dashboard')}>
                                <div className="transition-transform active:scale-95">
                                    <img
                                        src="/ChemistreeIcon_square.png"
                                        alt="Chemistree"
                                        className="w-10 h-10"
                                        draggable="false"
                                    />
                                </div>
                                <div className="min-w-0 flex-1">
                                    <h1 className="text-xl font-black leading-tight whitespace-nowrap chem-sans" style={{ color: '#76A8A5' }}>
                                        Chemistree
                                    </h1>
                                    <p className="text-[10px] text-slate-500 font-bold -mt-1 hidden sm:block whitespace-nowrap overflow-hidden text-ellipsis chem-sans">
                                        by ChemLeung
                                    </p>
                                </div>
                            </div>
                        </div>

                        {/* Desktop Navigation Links */}
                        {currentUser && (
                            <div className="hidden md:flex flex-1 justify-center">
                                <nav className="flex items-center gap-4">
                                <button
                                    onClick={() => handleNavigation('/dashboard')}
                                    className={`nav-orb ${isActive('/dashboard') ? 'bg-lab-blue text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('nav.dashboard')}
                                    title={t('nav.dashboard')}
                                >
                                    <Home size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('nav.dashboard')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/practice')}
                                    className={`nav-orb ${isActive('/practice') || isActive('/quiz') ? 'bg-chemistry-green text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('nav.practice')}
                                    title={t('nav.practice')}
                                >
                                    <Pencil size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('nav.practice')}</span>
                                </button>

                                <button
                                    onClick={handleNotebookHome}
                                    className={`nav-orb ${isActive('/notebook') ? 'bg-orange-600 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('dashboard.mistakeNotebook')}
                                    title={t('dashboard.mistakeNotebook')}
                                >
                                    <BookOpen size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('dashboard.mistakeNotebook')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/forum')}
                                    className={`nav-orb ${isActive('/forum') ? 'bg-purple-600 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('forum.title')}
                                    title={t('forum.title')}
                                >
                                    <MessageSquare size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('forum.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/leaderboard')}
                                    className={`nav-orb ${isActive('/leaderboard') ? 'bg-amber-500 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('leaderboard.title')}
                                    title={t('leaderboard.title')}
                                >
                                    <Trophy size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('leaderboard.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/chemcity')}
                                    className={`nav-orb ${isActive('/chemcity') ? 'bg-sky-600 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label="ChemCity"
                                    title="ChemCity"
                                >
                                    <Building2 size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">ChemCity</span>
                                </button>

                                {/* TOKENS */}
                                <button
                                    onClick={() => handleNavigation('/store')}
                                    className={`nav-orb ${isActive('/store') ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white' : 'bg-gradient-to-r from-amber-400 to-orange-500 text-white'}`}
                                    aria-label={t('store.title')}
                                    title={t('store.title')}
                                >
                                    <Gem size={20} fill="currentColor" />
                                    <span className="nav-orb-badge bg-slate-900/90">{tokensDisplay}</span>
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('store.title')}</span>
                                </button>

                                <button
                                    onClick={toggleLanguage}
                                    className="nav-orb bg-gradient-to-r from-slate-600 to-slate-700 text-white"
                                    aria-label={isEnglish ? t('auth.switchToChinese') : t('auth.switchToEnglish')}
                                    title={isEnglish ? t('auth.switchToChinese') : t('auth.switchToEnglish')}
                                >
                                    <Languages size={20} strokeWidth={3} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{isEnglish ? t('auth.languageNameChinese') : t('auth.languageNameEnglish')}</span>
                                </button>
                                </nav>
                            </div>
                        )}

                        {/* Mobile + Desktop User Menu */}
                        {currentUser && (
                            <div className="flex items-center gap-2 flex-shrink min-w-0 justify-end">
                                <button
                                    onClick={() => setShowMobileNav(!showMobileNav)}
                                    className="md:hidden p-2 rounded-lg hover:bg-slate-100 transition-all active:scale-95"
                                >
                                    {showMobileNav ? <X size={24} /> : <Menu size={24} />}
                                </button>

                                {/* Notifications (right side) */}
                                <div className="relative">
                                    <button
                                        onClick={() => setShowNotifPanel(v => !v)}
                                        className="relative p-2 rounded-lg hover:bg-white/60 transition-all active:scale-[0.99]"
                                        aria-label={t('forum.notifications')}
                                        title={t('forum.notifications')}
                                    >
                                        {unreadCount > 0 ? <BellDot size={22} className="text-purple-700" /> : <Bell size={22} className="text-slate-700" />}
                                        {unreadCount > 0 && (
                                            <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] rounded-full w-5 h-5 flex items-center justify-center font-black">
                                                {unreadCount > 9 ? t('common.ninePlus') : unreadCount}
                                            </span>
                                        )}
                                    </button>

                                    {showNotifPanel && (
                                        <>
                                            <div className="fixed inset-0 z-40" onClick={() => setShowNotifPanel(false)} />
                                            <div className="absolute right-0 mt-2 w-80 bg-white rounded-2xl shadow-2xl border-2 border-slate-200 z-50 overflow-hidden max-h-[480px] flex flex-col">
                                                <div className="p-4 border-b flex items-center justify-between bg-slate-50">
                                                    <h3 className="font-bold text-slate-800 flex items-center gap-2">
                                                        <Bell size={18} />
                                                        {t('forum.notifications')}
                                                        {unreadCount > 0 && <span className="bg-red-500 text-white text-xs rounded-full px-2 py-0.5">{unreadCount}</span>}
                                                    </h3>
                                                    <div className="flex items-center gap-2">
                                                        {unreadCount > 0 && (
                                                            <button onClick={handleMarkAllNotifsRead} className="text-xs text-lab-blue hover:underline font-semibold">
                                                                {t('forum.markAllRead')}
                                                            </button>
                                                        )}
                                                        {notifs.length > 0 && (
                                                            <button
                                                                type="button"
                                                                onClick={handleDeleteAllNotifs}
                                                                className="p-1 hover:bg-rose-50 rounded text-rose-600"
                                                                aria-label={t('forum.deleteAll')}
                                                                title={t('forum.deleteAll')}
                                                            >
                                                                <Trash2 size={16} />
                                                            </button>
                                                        )}
                                                        <button onClick={() => setShowNotifPanel(false)} className="p-1 hover:bg-slate-200 rounded"><X size={16} /></button>
                                                    </div>
                                                </div>

                                                <div className="overflow-y-auto flex-1">
                                                    {notifs.length === 0 ? (
                                                        <div className="text-center py-10 text-slate-400 text-sm">{t('forum.noNotificationsYet')}</div>
                                                    ) : (
                                                        <>
                                                            {notifs.map(n => (
                                                                <div
                                                                    key={n.id}
                                                                    onClick={() => handleMarkNotifRead(n.id)}
                                                                    className={`p-4 border-b cursor-pointer hover:bg-slate-50 transition-all ${!n.read ? 'bg-blue-50' : ''}`}
                                                                >
                                                                    <div className="flex items-start gap-3">
                                                                        <div className={`w-2 h-2 rounded-full mt-2 flex-shrink-0 ${!n.read ? 'bg-lab-blue' : 'bg-transparent'}`} />
                                                                        <ChemCityUserProfileIcon userId={n.senderId} displayName={n.senderDisplayName || t('common.someone')} size={28} />
                                                                        <div className="flex-1 min-w-0">
                                                                            <p className="text-sm text-slate-800 font-medium leading-snug">
                                                                                <span className="font-bold">{n.senderDisplayName || t('common.someone')}</span> {typeLabel(n)}
                                                                            </p>
                                                                            {n.previewText && (
                                                                                <p className="text-xs text-slate-500 mt-1 truncate">"{n.previewText}"</p>
                                                                            )}
                                                                            {n.postTitle && (
                                                                                <p className="text-xs text-lab-blue mt-0.5 truncate">→ {n.postTitle}</p>
                                                                            )}
                                                                            <p className="text-xs text-slate-400 mt-1">{formatAgo(n.createdAt)}</p>
                                                                        </div>
                                                                        <button
                                                                            onClick={(e) => { e.stopPropagation(); handleDeleteNotif(n.id); }}
                                                                            className="p-1 hover:bg-slate-200 rounded text-slate-500 hover:text-rose-600"
                                                                            title={t('forum.delete') || 'Delete'}
                                                                        >
                                                                            <X size={16} />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                            {notifs.length >= notifLimit && (
                                                                <div className="p-3 flex justify-center">
                                                                    <button
                                                                        onClick={() => setNotifLimit((n) => n + 10)}
                                                                        className="px-4 py-2 rounded-lg font-bold bg-slate-100 text-slate-700 hover:bg-slate-200 transition-all"
                                                                    >
                                                                        {t('forum.viewMore')}
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                        </>
                                    )}
                                </div>

                                <div className="relative">
                                    <button
                                        onClick={() => setShowUserMenu(!showUserMenu)}
                                        className="flex items-center gap-3 px-3 py-1.5 rounded-xl hover:bg-white/60 transition-all active:scale-[0.99] border-2 border-transparent hover:border-white/60 max-w-[240px] sm:max-w-[280px]"
                                        title={currentUser.displayName || currentUser.email || t('common.anonymous')}
                                    >
                                        <ChemCityUserProfileIcon
                                            userId={currentUser?.uid}
                                            displayName={currentUser?.displayName || currentUser?.email || t('common.anonymous')}
                                            size={32}
                                            className="shadow-md flex-shrink-0"
                                        />
                                        <div className="hidden sm:block text-left min-w-0">
                                            <p
                                                className="text-sm font-bold text-slate-900 truncate max-w-[140px] lg:max-w-[180px]"
                                                title={currentUser.displayName || t('common.anonymous')}
                                            >
                                                {currentUser.displayName || t('common.anonymous')}
                                            </p>
                                            <p
                                                className="text-xs text-slate-700 truncate max-w-[140px] lg:max-w-[180px]"
                                                title={currentUser.email || ''}
                                            >
                                                {currentUser.email}
                                            </p>
                                        </div>
                                        <ChevronDown size={16} className="text-slate-600 hidden sm:block flex-shrink-0" />
                                    </button>

                                    {showUserMenu && (
                                        <>
                                            <div
                                                className="fixed inset-0 z-40"
                                                onClick={() => setShowUserMenu(false)}
                                            />
                                            <div className="absolute right-0 mt-2 w-56 bg-white rounded-xl shadow-xl border-2 border-slate-200 z-50 overflow-hidden">
                                                <button
                                                    onClick={() => handleNavigation('/profile')}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-slate-50 transition-all text-left active:scale-[0.99]"
                                                >
                                                    <User size={18} className="text-slate-700" />
                                                    <span className="font-bold text-slate-900">
                                                        {t('profile.profileSettings')}
                                                    </span>
                                                </button>
                                                <button
                                                    onClick={() => handleNavigation('/history')}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-slate-50 transition-all text-left border-t border-slate-100 active:scale-[0.99]"
                                                >
                                                    <History size={18} className="text-slate-700" />
                                                    <span className="font-bold text-slate-900">
                                                        {t('header.myHistory')}
                                                    </span>
                                                </button>
                                                <button
                                                    onClick={() => handleNavigation('/token-log')}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-slate-50 transition-all text-left border-t border-slate-100 active:scale-[0.99]"
                                                >
                                                    <Clock size={18} className="text-amber-500" />
                                                    <span className="font-bold text-slate-900">
                                                        {t('header.tokenHistory')}
                                                    </span>
                                                </button>
                                                <button
                                                    onClick={handleLogoutClick}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-red-50 transition-all text-left border-t border-slate-100 active:scale-[0.99]"
                                                >
                                                    <LogOut size={18} className="text-red-600" />
                                                    <span className="font-bold text-red-600">
                                                        {t('nav.logout')}
                                                    </span>
                                                </button>
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
                </div>

                {/* Mobile Navigation Menu */}
                {showMobileNav && currentUser && (
                    <>
                        <div
                            className="fixed inset-0 bg-black bg-opacity-25 z-30"
                            onClick={() => setShowMobileNav(false)}
                        />
                        <div className="md:hidden fixed top-[64px] left-0 right-0 bg-white border-b-2 border-slate-200 shadow-xl z-40 animate-in slide-in-from-top duration-200">
                            <nav className="flex flex-col p-2">
                                {/* Token Display - Mobile */}
                                <div className="mb-2 p-3 bg-gradient-to-r from-amber-400 to-orange-500 rounded-lg">
                                    <div className="flex items-center justify-between text-white">
                                        <div className="flex items-center gap-2">
                                        <Gem size={20} fill="currentColor" />
                                        <span className="font-black text-lg">{tokensDisplay}</span>
                                        <span className="text-sm opacity-90">{t('header.tokens')}</span>
                                    </div>
                                    <button
                                        onClick={() => handleNavigation('/store')}
                                        className="px-3 py-1 bg-white/20 rounded-lg font-bold text-sm hover:bg-white/30 transition-all active:scale-[0.98]"
                                    >
                                        <ShoppingBag size={16} className="inline mr-1" />
                                        {t('store.title')}
                                    </button>
                                </div>
                            </div>

                                <button
                                    onClick={() => handleNavigation('/dashboard')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/dashboard')
                                            ? 'bg-lab-blue text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <Home size={20} />
                                    <span>{t('nav.dashboard')}</span>
                                </button>
                                <button
                                    onClick={() => handleNavigation('/practice')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/practice') || isActive('/quiz')
                                            ? 'bg-chemistry-green text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <img
                                        src="/ChemistreeIcon_square.png"
                                        alt="Chemistree"
                                        className="w-8 h-8"
                                        draggable="false"
                                    />
                                    <span>{t('nav.practice')}</span>
                                </button>
                                
                                <button
                                    onClick={handleNotebookHome}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/notebook')
                                            ? 'bg-orange-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <BookOpen size={20} />
                                    <span>{t('dashboard.mistakeNotebook')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/forum')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/forum')
                                            ? 'bg-purple-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <MessageSquare size={20} />
                                    <span>{t('forum.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/leaderboard')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/leaderboard')
                                            ? 'bg-amber-500 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <Trophy size={20} />
                                    <span>{t('leaderboard.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/chemcity')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/chemcity')
                                            ? 'bg-sky-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <Building2 size={20} />
                                    <span>ChemCity</span>
                                </button>
                                <button
                                    onClick={() => handleNavigation('/history')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/history')
                                            ? 'bg-purple-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <History size={20} />
                                    <span>{t('history.title')}</span>
                                </button>

                                <button
                                    onClick={() => {
                                        toggleLanguage();
                                        setShowMobileNav(false);
                                    }}
                                    className="flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] bg-gradient-to-r from-amber-400 to-orange-500 text-white hover:from-amber-500 hover:to-orange-600 mt-2 shadow-md"
                                >
                                    <Languages size={20} strokeWidth={3} />
                                    <span>{isEnglish ? t('auth.languageNameChinese') : t('auth.languageNameEnglish')}</span>
                                </button>
                            </nav>
                        </div>
                    </>
                )}
            </header>

            {/* Logout Confirmation Modal */}
            {showLogoutModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-in zoom-in duration-200">
                        <div className="p-6">
                            <div className="flex items-center gap-3 mb-4">
                                <div className="w-12 h-12 rounded-full bg-red-100 flex items-center justify-center">
                                    <AlertTriangle className="text-red-600" size={24} />
                                </div>
                                <div>
                                    <h3 className="text-xl font-black text-slate-800">
                                        {t('dashboard.confirmLogout')}
                                    </h3>
                                    <p className="text-sm text-slate-500">
                                        {t('dashboard.areYouSureLogout')}
                                    </p>
                                </div>
                            </div>
                            <p className="text-slate-600 mb-6">
                                {t('header.logoutWarning')}
                            </p>
                            <div className="flex gap-3">
                                <button
                                    onClick={() => setShowLogoutModal(false)}
                                    className="flex-1 px-6 py-3 bg-slate-100 text-slate-700 rounded-xl font-bold hover:bg-slate-200 transition-all"
                                >
                                    {t('common.cancel')}
                                </button>
                                <button
                                    onClick={() => {
                                        setShowLogoutModal(false);
                                        handleLogoutConfirm();
                                    }}
                                    className="flex-1 px-6 py-3 bg-red-600 text-white rounded-xl font-bold hover:bg-red-700 transition-all flex items-center justify-center gap-2"
                                >
                                    <LogOut size={18} />
                                    {t('nav.logout')}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {showDeleteAllNotifsConfirm && (
                <div className="fixed inset-0 z-[70] flex items-center justify-center p-4" onClick={() => setShowDeleteAllNotifsConfirm(false)}>
                    <div className="absolute inset-0 bg-black/40" />
                    <div
                        className="relative w-full max-w-sm bg-white rounded-2xl shadow-2xl border-2 border-slate-200 overflow-hidden"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <div className="p-4 border-b bg-slate-50 flex items-center gap-3">
                            <AlertCircle className="text-rose-600" size={18} />
                            <h4 className="font-black text-slate-800">{t('forum.deleteAllNotificationsTitle')}</h4>
                        </div>
                        <div className="p-4 text-sm text-slate-700">
                            {t('forum.deleteAllNotificationsBody')}
                        </div>
                        <div className="p-4 border-t bg-white flex justify-end gap-2">
                            <button
                                type="button"
                                onClick={() => setShowDeleteAllNotifsConfirm(false)}
                                className="px-4 py-2 rounded-lg font-bold bg-slate-200 text-slate-700 hover:bg-slate-300 transition-all"
                            >
                                {t('common.cancel')}
                            </button>
                            <button
                                type="button"
                                onClick={confirmDeleteAllNotifs}
                                className="px-4 py-2 rounded-lg font-bold bg-rose-600 text-white hover:bg-rose-700 transition-all"
                            >
                                {t('common.delete')}
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </>
    );
}

===== FILE: src/components/ChemStore.jsx =====

// ============================================================================
// CHEMSTORE - Token Economy Shop
// ============================================================================

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { ArrowLeft, ShoppingBag } from 'lucide-react';
import { getCosmeticsMap } from '../lib/chemcity/gachaStaticCache';
import { callChemCityBuyTickets, callChemCityPurchaseCosmetic } from '../lib/chemcity/cloudFunctions';

export default function ChemStore() {
  const navigate = useNavigate();
  const { currentUser, userProfile } = useAuth();
  const { t } = useLanguage();
  const [selectedCategory, setSelectedCategory] = useState('tickets');
  const [purchasing, setPurchasing] = useState(null);
  const [notification, setNotification] = useState(null);

  const [cosmeticsMap, setCosmeticsMap] = useState(null);

  const chemcity = userProfile?.chemcity || {};
  const currencies = chemcity?.currencies || {};
  const coins = Number(currencies.coins || 0);
  const tickets = Number(currencies.tickets || 0);
  const ownedCosmetics = Array.isArray(chemcity?.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
  const ownedCosmeticsSet = new Set(ownedCosmetics);

  const gender = userProfile?.gender || 'boy';

  // Show notification
  const showNotification = (message, type = 'success') => {
    setNotification({ message, type });
    setTimeout(() => setNotification(null), 3000);
  };

  useEffect(() => {
    let mounted = true;
    getCosmeticsMap()
      .then((m) => {
        if (!mounted) return;
        setCosmeticsMap(m);
      })
      .catch(() => {
        if (!mounted) return;
        setCosmeticsMap(new Map());
      });
    return () => {
      mounted = false;
    };
  }, []);

  const categories = [
    { key: 'tickets', label: 'Tickets', icon: '🎟️' },
    { key: 'avatars', label: 'Avatars', icon: '🧑' },
    { key: 'backgrounds', label: 'Backgrounds', icon: '🖼️' },
  ];

  const allCosmetics = cosmeticsMap ? Array.from(cosmeticsMap.values()) : [];
  const shopCosmetics = allCosmetics.filter((c) => c?.availability?.channels?.shop === true && c?.deprecated !== true);
  const currentCosmetics =
    selectedCategory === 'avatars'
      ? shopCosmetics.filter((c) => c.type === 'avatar')
      : selectedCategory === 'backgrounds'
        ? shopCosmetics.filter((c) => c.type === 'background')
        : [];

  const handleBuyTickets = async (count) => {
    if (purchasing) return;
    setPurchasing(`tickets_${count}`);
    try {
      await callChemCityBuyTickets({ count });
      showNotification(`Bought ${count} tickets`, 'success');
    } catch (e) {
      showNotification(e?.message || 'Failed to buy tickets', 'error');
    }
    setPurchasing(null);
  };

  const handleBuyCosmetic = async (cosmetic, currency) => {
    if (purchasing) return;
    setPurchasing(cosmetic.id);
    try {
      await callChemCityPurchaseCosmetic({ cosmeticId: cosmetic.id, currency });
      showNotification(`Purchased ${cosmetic.name}`, 'success');
    } catch (e) {
      showNotification(e?.message || 'Purchase failed', 'error');
    }
    setPurchasing(null);
  };

  return (
    <div className="max-w-7xl mx-auto space-y-6">
      {/* Notification */}
      {notification && (
        <div className={`fixed top-20 right-4 z-50 px-6 py-3 rounded-lg shadow-2xl animate-in slide-in-from-top-2 ${
          notification.type === 'success' 
            ? 'bg-gradient-to-r from-green-500 to-emerald-600 text-white' 
            : 'bg-gradient-to-r from-red-500 to-rose-600 text-white'
        }`}>
          <p className="font-bold">{notification.message}</p>
        </div>
      )}

      {/* Header */}
      <div className="flex items-center gap-4">
        <button
          onClick={() => navigate('/dashboard')}
          className="p-3 bg-white rounded-lg border-2 border-slate-200 hover:border-lab-blue transition-all"
        >
          <ArrowLeft size={20} />
        </button>
        
        <div className="flex-1 receipt-widget">
          <div className="receipt-perforation" />
          <div className="receipt-widget-content p-6">
            <h1 className="text-3xl font-black flex items-center gap-3 text-slate-900 bellmt-title ink-amber">
              <ShoppingBag size={32} className="text-amber-700" />
              {t('store.title')}
            </h1>
            <p className="text-slate-700 mt-1 font-semibold">
              {t('store.subtitle')}
            </p>
            <div className="flex items-start justify-between gap-6">
              <div className="min-w-0">
                <div className="mt-3 receipt-rule" />
                <p className="mt-3 text-sm text-slate-700 font-medium">
                  {t('store.subtitle')}
                </p>
              </div>

              <div className="flex-shrink-0 text-right">
                <div className="text-xs font-bold tracking-widest text-slate-500 uppercase">
                  {t('store.yourBalance')}
                </div>
                <div className="mt-2 flex items-center justify-end gap-2">
                  <span className="px-3 py-1 rounded-full bg-slate-100 border border-slate-200 text-slate-800 font-black tabular-nums">
                    {coins} coins
                  </span>
                  <span className="px-3 py-1 rounded-full bg-slate-100 border border-slate-200 text-slate-800 font-black tabular-nums">
                    {tickets} tickets
                  </span>
                </div>
                <div className="mt-3 receipt-rule" />
                <div className="mt-2 font-mono text-[11px] text-slate-500">
                  #{String(currentUser?.uid || '').slice(0, 6).toUpperCase()} · {new Date().toLocaleDateString('en-GB')}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Category Tabs */}
      <div className="bg-white rounded-2xl shadow-xl border-2 border-slate-200 overflow-hidden">
        <div className="flex border-b-2 border-slate-200">
          {categories.map(cat => (
            <button
              key={cat.key}
              onClick={() => setSelectedCategory(cat.key)}
              className={`flex-1 px-6 py-4 font-bold text-base transition-all flex items-center justify-center gap-2 ${
                selectedCategory === cat.key
                  ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white'
                  : 'text-slate-600 hover:bg-slate-50'
              }`}
            >
              <span className="text-2xl">{cat.icon}</span>
              {cat.label}
            </button>
          ))}
        </div>

        {/* Items Grid */}
        <div className="p-6">
          {selectedCategory === 'tickets' ? (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {[1, 10, 50].map((count) => {
                const cost = 250 * count;
                const canAfford = coins >= cost;
                return (
                  <div
                    key={count}
                    className="bg-white rounded-2xl border-2 border-slate-200 p-6 shadow-sm"
                  >
                    <div className="text-2xl font-black text-slate-900">{count} Tickets</div>
                    <div className="mt-1 text-slate-600 font-semibold">Cost: {cost} coins</div>
                    <button
                      onClick={() => handleBuyTickets(count)}
                      disabled={!canAfford || purchasing === `tickets_${count}`}
                      className={`mt-4 w-full px-4 py-3 rounded-xl font-black transition-all ${
                        canAfford
                          ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:opacity-90'
                          : 'bg-slate-200 text-slate-400 cursor-not-allowed'
                      }`}
                    >
                      {purchasing === `tickets_${count}` ? 'Buying...' : canAfford ? 'Buy' : 'Not enough coins'}
                    </button>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {currentCosmetics.map((cosmetic) => {
                const owned = ownedCosmeticsSet.has(cosmetic.id);
                const coinCost = Number(cosmetic?.shopData?.coinCost || 0);
                const canBuyWithCoins = Number.isFinite(coinCost) && coinCost > 0;
                const canAfford = canBuyWithCoins ? coins >= coinCost : false;

                return (
                  <div
                    key={cosmetic.id}
                    className="relative bg-white rounded-2xl border-2 border-slate-200 overflow-hidden transition-all hover:shadow-lg"
                  >
                    <div className="p-4 bg-slate-50 flex items-center justify-center">
                      {cosmetic.type === 'background' ? (
                        <img
                          src={cosmetic.imageUrl}
                          alt=""
                          className="w-full h-40 object-cover rounded-xl"
                          draggable={false}
                        />
                      ) : (
                        <div className="relative w-full h-40 rounded-xl overflow-hidden bg-gradient-to-b from-indigo-900 to-gray-900">
                          <img
                            src={cosmetic.imageUrl}
                            alt=""
                            draggable={false}
                            className="absolute bottom-0 left-0 h-full w-[200%] object-contain"
                            style={{ transform: gender === 'girl' ? 'translateX(-50%)' : 'translateX(0%)' }}
                          />
                        </div>
                      )}
                    </div>

                    <div className="p-5">
                      <div className="text-lg font-black text-slate-900 truncate">{cosmetic.name}</div>

                      <div className="mt-3 flex items-center justify-between">
                        <div className="text-slate-700 font-black tabular-nums">
                          {canBuyWithCoins ? `${coinCost} coins` : 'Not for sale'}
                        </div>

                        {owned ? (
                          <div className="px-3 py-1 rounded-full bg-green-100 text-green-700 font-black text-sm">
                            Owned
                          </div>
                        ) : (
                          <button
                            onClick={() => handleBuyCosmetic(cosmetic, 'coins')}
                            disabled={!canBuyWithCoins || !canAfford || purchasing === cosmetic.id}
                            className={`px-4 py-2 rounded-xl font-black transition-all ${
                              canBuyWithCoins && canAfford
                                ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:opacity-90'
                                : 'bg-slate-200 text-slate-400 cursor-not-allowed'
                            }`}
                          >
                            {purchasing === cosmetic.id ? 'Buying...' : canBuyWithCoins ? 'Buy' : 'Locked'}
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                );
              })}

              {currentCosmetics.length === 0 && (
                <div className="text-center py-12 col-span-full">
                  <p className="text-slate-400 text-lg">No items for sale yet.</p>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

    </div>
  );
}

===== FILE: src/components/chemcity/ChemStore.tsx =====

import React, { useEffect, useState } from 'react';
import { X, ShoppingBag, Clock, Lock, Plus, Coins, Gem, Tag, RefreshCw } from 'lucide-react';
import { useChemCityStore } from '../../store/chemcityStore';
import { getEffectiveCoinPrice } from '../../lib/chemcity/shop';
import { countdownToMidnight, STORE_SLOT_UNLOCK_COSTS, STORE_MAX_SLOTS } from '../../lib/chemcity/dailyStore';
import type { SlimItemDocument } from '../../lib/chemcity/types';

function needsAnonymousCrossOrigin(url?: string | null): boolean {
  if (!url) return false;
  const u = url.toLowerCase();
  return u.includes('drive.google.com') || u.includes('googleusercontent.com');
}

// Preload card images in the background
function preloadCardImages(items: SlimItemDocument[]) {
  items.forEach(item => {
    if (item.imageUrl) {
      const img = new Image();
      if (needsAnonymousCrossOrigin(item.imageUrl)) {
        img.crossOrigin = 'anonymous';
        img.referrerPolicy = 'no-referrer';
      }
      img.src = item.imageUrl;
    }
  });
}

const RARITY_CONFIG: Record<string, {
  borderColor: string; glowColor: string; bgGradient: string; artBg: string;
  badgeColor: string; badgeText: string; labelBg: string;
}> = {
  common:    { borderColor: '#94a3b8', glowColor: 'rgba(148,163,184,0.2)', bgGradient: 'linear-gradient(165deg,#1e293b,#0f172a)', artBg: 'rgba(255,255,255,0.04)', badgeColor: 'rgba(148,163,184,0.2)', badgeText: '#94a3b8', labelBg: 'rgba(148,163,184,0.15)' },
  uncommon:  { borderColor: '#34d399', glowColor: 'rgba(52,211,153,0.28)',  bgGradient: 'linear-gradient(165deg,#0f3d33,#071a16)', artBg: 'rgba(52,211,153,0.06)',  badgeColor: 'rgba(52,211,153,0.18)', badgeText: '#34d399', labelBg: 'rgba(52,211,153,0.14)' },
  rare:      { borderColor: '#60a5fa', glowColor: 'rgba(96,165,250,0.35)',  bgGradient: 'linear-gradient(165deg,#1e3a5f,#0f172a)', artBg: 'rgba(96,165,250,0.07)',  badgeColor: 'rgba(96,165,250,0.2)',  badgeText: '#60a5fa', labelBg: 'rgba(96,165,250,0.15)'  },
  epic:      { borderColor: '#a855f7', glowColor: 'rgba(168,85,247,0.35)',  bgGradient: 'linear-gradient(165deg,#2d1b4e,#0f0a1e)', artBg: 'rgba(168,85,247,0.07)',  badgeColor: 'rgba(168,85,247,0.2)',  badgeText: '#a855f7', labelBg: 'rgba(168,85,247,0.15)' },
  legendary: { borderColor: '#fbbf24', glowColor: 'rgba(251,191,36,0.45)',  bgGradient: 'linear-gradient(165deg,#3d2800,#1a0f00)', artBg: 'rgba(251,191,36,0.09)',  badgeColor: 'rgba(251,191,36,0.2)',  badgeText: '#fbbf24', labelBg: 'rgba(251,191,36,0.15)' },
};

export const ChemStore: React.FC = () => {
  const user             = useChemCityStore(s => s.user);
  const dailyStoreItems  = useChemCityStore(s => s.dailyStoreItems);
  const storeSlotCount   = useChemCityStore(s => s.storeSlotCount);
  const openPurchaseConfirm = useChemCityStore(s => s.openPurchaseConfirm);
  const unlockStoreSlot  = useChemCityStore(s => s.unlockStoreSlot);
  const devRefreshStaticData = useChemCityStore(s => s.devRefreshStaticData);
  const devGrantCoins = useChemCityStore(s => s.devGrantCoins);
  const devRerollStore = useChemCityStore(s => s.devRerollStore);

  const [countdown, setCountdown]   = useState(() => countdownToMidnight());
  const [unlockingSlot, setUnlockingSlot] = useState(false);
  const [unlockError, setUnlockError] = useState<string | null>(null);

  useEffect(() => {
    const id = setInterval(() => setCountdown(countdownToMidnight()), 1000);
    return () => clearInterval(id);
  }, []);

  // Preload store item images when they change
  useEffect(() => {
    preloadCardImages(dailyStoreItems);
  }, [dailyStoreItems]);

  const discount  = user?.activeBonuses.shopDiscountPercent ?? 0;
  const coins     = user?.currencies.coins ?? 0;
  const ownedSet  = new Set(user?.ownedItems ?? []);

  const isDevBuild = !!(import.meta as any)?.env?.DEV;
  const isDevToggle = (() => {
    try {
      const qs = new URLSearchParams(window.location.search);
      if (qs.get('cc_dev') === '1') return true;
      return localStorage.getItem('cc_dev') === '1';
    } catch {
      return false;
    }
  })();
  const isLocalhost = (() => {
    try {
      return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    } catch {
      return false;
    }
  })();
  const showDevControls = isDevBuild || isDevToggle || isLocalhost;

  const nextSlotNum  = storeSlotCount + 1;
  const nextSlotCost = STORE_SLOT_UNLOCK_COSTS[nextSlotNum] ?? null;
  const canUnlockMore = storeSlotCount < STORE_MAX_SLOTS;
  const canAffordNext = nextSlotCost != null && coins >= nextSlotCost;

  const handleUnlockSlot = async () => {
    if (unlockingSlot || !canUnlockMore || !canAffordNext) return;
    setUnlockingSlot(true);
    setUnlockError(null);
    try { await unlockStoreSlot(); }
    catch (err: any) { setUnlockError(err?.message ?? 'Failed to unlock slot.'); }
    finally { setUnlockingSlot(false); }
  };

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@500;600;700;800&display=swap');
        @keyframes shimmerSlide { 0%,100%{transform:translateX(-200%)} 50%{transform:translateX(200%)} }
        @keyframes legendGlow { 0%,100%{box-shadow:0 0 20px rgba(251,191,36,0.4),0 4px 12px rgba(0,0,0,0.5)} 50%{box-shadow:0 0 36px rgba(251,191,36,0.7),0 4px 16px rgba(0,0,0,0.6)} }
        .store-card:hover { transform:translateY(-4px) !important; }
        .store-card { transition:transform 0.2s ease, box-shadow 0.2s ease !important; }
        .owned-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.5); border-radius:inherit; display:flex; align-items:center; justify-content:center; }
        .slot-bar-segment { height:4px; border-radius:2px; flex:1; transition:background 0.4s ease; }
      `}</style>

      <div style={{ display: 'flex', flexDirection: 'column', flex: 1, paddingTop: 132, fontFamily: "'Quicksand',sans-serif", minHeight: 0 }}>

        {/* ── Store Header ── */}
        <div style={{
          padding: '16px 20px 14px',
          borderBottom: '1px solid rgba(197,215,181,0.1)',
          background: 'linear-gradient(135deg, rgba(118,168,165,0.1) 0%, transparent 80%)',
          flexShrink: 0,
        }}>
          <div style={{ display: 'flex', alignItems: 'flex-start', justifyContent: 'space-between', marginBottom: 10, gap: 12 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
              <div style={{
                background: 'linear-gradient(135deg,rgba(118,168,165,0.3),rgba(118,168,165,0.1))',
                border: '1.5px solid rgba(118,168,165,0.5)',
                borderRadius: 12, width: 46, height: 46,
                display: 'flex', alignItems: 'center', justifyContent: 'center',
              }}>
                <ShoppingBag size={22} color="#76A8A5" />
              </div>
              <div>
                <div style={{ color: '#fff', fontWeight: 800, fontSize: 18 }}>ChemStore</div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, color: 'rgba(197,215,181,0.5)', fontSize: 12, fontWeight: 600 }}>
                  <Clock size={11} />
                  <span>Resets in {countdown}</span>
                </div>
              </div>
            </div>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end', gap: 10, flexWrap: 'wrap', rowGap: 8, maxWidth: 520 }}>
              {showDevControls && (
                <>
                  <button
                    type="button"
                    onClick={() => devRefreshStaticData()}
                    style={{
                      display: 'flex', alignItems: 'center', gap: 6,
                      background: 'rgba(255,255,255,0.06)',
                      border: '1px solid rgba(255,255,255,0.12)',
                      borderRadius: 12,
                      padding: '6px 10px',
                      cursor: 'pointer',
                      color: 'rgba(255,255,255,0.55)',
                      fontWeight: 800,
                      fontSize: 11,
                      fontFamily: "'Quicksand',sans-serif",
                    }}
                    title="DEV: refresh ChemCity static data"
                  >
                    <RefreshCw size={14} />
                    Refresh
                  </button>

                  <button
                    type="button"
                    onClick={() => devRerollStore()}
                    style={{
                      display: 'flex', alignItems: 'center', gap: 6,
                      background: 'rgba(118,168,165,0.14)',
                      border: '1px solid rgba(118,168,165,0.28)',
                      borderRadius: 12,
                      padding: '6px 10px',
                      cursor: 'pointer',
                      color: 'rgba(197,215,181,0.9)',
                      fontWeight: 900,
                      fontSize: 11,
                      fontFamily: "'Quicksand',sans-serif",
                    }}
                    title="DEV: reroll store items"
                  >
                    Reroll
                  </button>

                  <button
                    type="button"
                    onClick={() => devGrantCoins(1000)}
                    style={{
                      display: 'flex', alignItems: 'center', gap: 6,
                      background: 'rgba(251,191,36,0.12)',
                      border: '1px solid rgba(251,191,36,0.25)',
                      borderRadius: 12,
                      padding: '6px 10px',
                      cursor: 'pointer',
                      color: 'rgba(251,191,36,0.9)',
                      fontWeight: 900,
                      fontSize: 11,
                      fontFamily: "'Quicksand',sans-serif",
                    }}
                    title="DEV: +1000 coins"
                  >
                    +1000
                  </button>
                </>
              )}

              {discount > 0 && (
                <div style={{
                  display: 'flex', alignItems: 'center', gap: 5,
                  background: 'rgba(52,211,153,0.15)', border: '1.5px solid rgba(52,211,153,0.4)',
                  borderRadius: 20, padding: '5px 12px',
                }}>
                  <Tag size={13} color="#34d399" />
                  <span style={{ color: '#34d399', fontWeight: 800, fontSize: 13 }}>{discount}% OFF</span>
                </div>
              )}
            </div>
          </div>

          {/* Slot progress bar */}
          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <div style={{ display: 'flex', gap: 3, flex: 1 }}>
              {Array.from({ length: STORE_MAX_SLOTS }, (_, i) => (
                <div key={i} className="slot-bar-segment" style={{
                  background: i < storeSlotCount ? 'rgba(118,168,165,0.8)' : 'rgba(255,255,255,0.08)',
                }} />
              ))}
            </div>
            <span style={{ color: 'rgba(255,255,255,0.4)', fontSize: 11, fontWeight: 700, flexShrink: 0 }}>
              {storeSlotCount}/{STORE_MAX_SLOTS} slots
            </span>
          </div>
        </div>

        {/* ── Card Display ── */}
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {dailyStoreItems.length === 0 ? (
            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: 200, gap: 12 }}>
              <ShoppingBag size={40} color="rgba(255,255,255,0.1)" style={{ animation: 'legendGlow 2s infinite' }} />
              <p style={{ color: 'rgba(255,255,255,0.3)', fontSize: 14, fontWeight: 600, margin: 0 }}>Loading store…</p>
            </div>
          ) : (
            <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
              {/* ── Card Row ── */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${Math.min(dailyStoreItems.length, 3)}, 1fr)`,
                gap: 12,
                justifyItems: 'center',
              }}>
                {dailyStoreItems.map((item, idx) => {
                  const isOwned = ownedSet.has(item.id);
                  const cfg = RARITY_CONFIG[item.rarity] ?? RARITY_CONFIG.common;
                  const rawCoin = item.shopData?.coinCost;
                  const rawDiamond = item.shopData?.diamondCost;
                  const effCoin = rawCoin != null ? getEffectiveCoinPrice(rawCoin, user?.activeBonuses ?? null) : null;
                  const coinSaved = rawCoin != null && effCoin != null ? rawCoin - effCoin : 0;

                  return (
                    <div key={item.id} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 8, width: '100%', maxWidth: 160 }}>
                      {/* Vertical RPG card */}
                      <button
                        onClick={() => openPurchaseConfirm(item.id)}
                        className="store-card"
                        style={{
                          position: 'relative',
                          width: '100%', maxWidth: 150, height: 210,
                          borderRadius: 14,
                          border: `2px solid ${cfg.borderColor}`,
                          background: cfg.bgGradient,
                          boxShadow: item.rarity === 'legendary'
                            ? `0 0 28px ${cfg.glowColor}, 0 6px 20px rgba(0,0,0,0.6)`
                            : `0 0 14px ${cfg.glowColor}, 0 4px 12px rgba(0,0,0,0.5)`,
                          cursor: 'pointer', overflow: 'hidden', padding: 0,
                          animation: item.rarity === 'legendary' ? 'legendGlow 2.5s ease-in-out infinite' : 'none',
                        }}
                      >
                        {/* Shimmer for legendary */}
                        {item.rarity === 'legendary' && (
                          <div style={{
                            position: 'absolute', inset: 0, zIndex: 1, pointerEvents: 'none',
                            background: 'linear-gradient(105deg,transparent 30%,rgba(255,215,0,0.12) 50%,transparent 70%)',
                            animation: 'shimmerSlide 3s ease-in-out infinite',
                          }} />
                        )}

                        {/* Slot # badge */}
                        <div style={{
                          position: 'absolute', top: 6, left: 8, zIndex: 3,
                          color: 'rgba(255,255,255,0.3)', fontSize: 9, fontWeight: 700,
                          fontFamily: "'Quicksand',sans-serif",
                        }}>#{idx + 1}</div>

                        {/* Stars */}
                        <div style={{
                          position: 'absolute', top: 5, right: 7, zIndex: 3,
                          color: cfg.badgeText, fontSize: 8, letterSpacing: 1,
                        }}>{'✦'.repeat({ common:1, uncommon:2, rare:2, epic:3, legendary:4 }[item.rarity] ?? 1)}</div>

                        {/* Art */}
                        <div style={{
                          height: 130, margin: '14px 10px 6px',
                          background: cfg.artBg,
                          border: `1px solid ${cfg.borderColor}`,
                          borderRadius: 8,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          overflow: 'hidden',
                          position: 'relative',
                          zIndex: 2,
                        }}>
                          {item.imageUrl ? (
                            <img
                              src={item.imageUrl}
                              alt={item.name}
                              style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                              {...(needsAnonymousCrossOrigin(item.imageUrl)
                                ? { crossOrigin: 'anonymous' as const, referrerPolicy: 'no-referrer' as const }
                                : {})}
                              loading="lazy"
                              onError={e => { (e.target as HTMLImageElement).style.display='none'; }}
                            />
                          ) : (
                            <span style={{ fontSize: 48 }}>{item.emoji}</span>
                          )}
                        </div>

                        {/* Name */}
                        <div style={{ padding: '0 10px 4px', textAlign: 'center', position: 'relative', zIndex: 2 }}>
                          <div style={{ color: '#f1f5f9', fontSize: 11, fontWeight: 800, fontFamily: "'Quicksand',sans-serif", lineHeight: 1.25, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{item.name}</div>
                          <div style={{ color: 'rgba(255,255,255,0.4)', fontSize: 9, fontFamily: 'monospace', marginTop: 1 }}>{item.chemicalFormula}</div>
                        </div>

                        {/* Rarity footer */}
                        <div style={{
                          position: 'absolute', bottom: 8, left: 10, right: 10,
                          background: cfg.badgeColor, borderRadius: 4, padding: '2px 0',
                          textAlign: 'center', fontSize: 8, fontWeight: 800,
                          color: cfg.badgeText, fontFamily: "'Quicksand',sans-serif",
                          textTransform: 'uppercase', letterSpacing: '0.06em', zIndex: 2,
                        }}>{item.rarity}</div>

                        {/* Owned overlay */}
                        {isOwned && (
                          <div className="owned-overlay" style={{ zIndex: 4, borderRadius: 12 }}>
                            <div style={{
                              background: 'rgba(52,211,153,0.9)', borderRadius: 8,
                              padding: '6px 14px', fontWeight: 800, fontSize: 12,
                              color: '#052e16', fontFamily: "'Quicksand',sans-serif",
                            }}>✓ Owned</div>
                          </div>
                        )}
                      </button>

                      {/* Price below card */}
                      <div style={{ textAlign: 'center', width: '100%' }}>
                        {effCoin != null && (
                          <div>
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4 }}>
                              <Coins size={12} color="#fbbf24" />
                              <span style={{ color: '#fbbf24', fontWeight: 800, fontSize: 13, fontFamily: "'Quicksand',sans-serif" }}>
                                {effCoin.toLocaleString()}
                              </span>
                            </div>
                            {coinSaved > 0 && (
                              <div style={{ color: 'rgba(255,255,255,0.3)', fontSize: 10, textDecoration: 'line-through', fontFamily: "'Quicksand',sans-serif" }}>
                                {rawCoin!.toLocaleString()}
                              </div>
                            )}
                          </div>
                        )}
                        {item.shopData?.diamondCost != null && (
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4 }}>
                            <Gem size={11} color="#67e8f9" />
                            <span style={{ color: '#67e8f9', fontWeight: 800, fontSize: 13, fontFamily: "'Quicksand',sans-serif" }}>
                              {item.shopData.diamondCost.toLocaleString()}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>

              {/* ── Unlock More Slots ── */}
              {canUnlockMore && (
                <div style={{ marginTop: 8 }}>
                  <p style={{ color: 'rgba(255,255,255,0.3)', fontSize: 11, fontWeight: 600, textAlign: 'center', marginBottom: 10 }}>
                    Unlock more slots to see more cards daily
                  </p>
                  <button
                    onClick={handleUnlockSlot}
                    disabled={!canAffordNext || unlockingSlot}
                    style={{
                      width: '100%', padding: '14px',
                      borderRadius: 14, border: '2px dashed',
                      borderColor: canAffordNext && !unlockingSlot ? 'rgba(118,168,165,0.5)' : 'rgba(255,255,255,0.1)',
                      background: canAffordNext && !unlockingSlot ? 'rgba(118,168,165,0.08)' : 'rgba(255,255,255,0.02)',
                      cursor: canAffordNext && !unlockingSlot ? 'pointer' : 'not-allowed',
                      display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 10,
                      transition: 'all 0.2s',
                    }}
                  >
                    <div style={{
                      width: 32, height: 32,
                      background: canAffordNext ? 'rgba(118,168,165,0.2)' : 'rgba(255,255,255,0.05)',
                      borderRadius: 8, display: 'flex', alignItems: 'center', justifyContent: 'center',
                    }}>
                      {unlockingSlot ? (
                        <div style={{ width:14, height:14, border:'2px solid rgba(255,255,255,0.2)', borderTopColor:'#76A8A5', borderRadius:'50%', animation:'spin 0.8s linear infinite' }} />
                      ) : (
                        <Lock size={14} color={canAffordNext ? '#76A8A5' : '#64748b'} />
                      )}
                    </div>
                    <div style={{ textAlign: 'left' }}>
                      <div style={{ color: canAffordNext ? '#fff' : '#64748b', fontWeight: 800, fontSize: 13, fontFamily: "'Quicksand',sans-serif" }}>
                        Unlock Slot #{nextSlotNum}
                      </div>
                      {nextSlotCost != null && (
                        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                          <Coins size={11} color={canAffordNext ? '#fbbf24' : '#64748b'} />
                          <span style={{ color: canAffordNext ? '#fbbf24' : '#64748b', fontSize: 12, fontWeight: 800, fontFamily: "'Quicksand',sans-serif" }}>
                            {nextSlotCost.toLocaleString()}
                          </span>
                          {!canAffordNext && (
                            <span style={{ color: '#64748b', fontSize: 10, fontFamily: "'Quicksand',sans-serif" }}>
                              (need {(nextSlotCost - coins).toLocaleString()} more)
                            </span>
                          )}
                        </div>
                      )}
                    </div>
                    <Plus size={16} color={canAffordNext ? '#76A8A5' : '#64748b'} style={{ marginLeft: 'auto' }} />
                  </button>
                  {unlockError && <p style={{ color: '#f87171', fontSize: 11, textAlign: 'center', marginTop: 6, fontFamily: "'Quicksand',sans-serif" }}>{unlockError}</p>}
                </div>
              )}

              {storeSlotCount === STORE_MAX_SLOTS && (
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6, padding: '12px 0' }}>
                  <div style={{ height: 1, flex: 1, background: 'rgba(255,255,255,0.06)' }} />
                  <span style={{ color: 'rgba(255,255,255,0.2)', fontSize: 11, fontWeight: 700, fontFamily: "'Quicksand',sans-serif" }}>All slots unlocked</span>
                  <div style={{ height: 1, flex: 1, background: 'rgba(255,255,255,0.06)' }} />
                </div>
              )}
            </div>
          )}
        </div>
      </div>
      <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>
    </>
  );
};

===== FILE: src/components/chemcity/PurchaseConfirmModal.tsx =====

import React, { useEffect, useState } from 'react';
import { X, Coins, Gem, CheckCircle, FlaskConical, Star, BookOpen, Zap } from 'lucide-react';
import { useChemCityStore } from '../../store/chemcityStore';
import { getEffectiveCoinPrice } from '../../lib/chemcity/shop';

function needsAnonymousCrossOrigin(url?: string | null): boolean {
  if (!url) return false;
  const u = url.toLowerCase();
  return u.includes('drive.google.com') || u.includes('googleusercontent.com');
}

const RARITY_CONFIG: Record<string, {
  borderColor: string; glowColor: string; bgGradient: string; artBg: string;
  badgeColor: string; badgeText: string;
}> = {
  common:    { borderColor: '#94a3b8', glowColor: 'rgba(148,163,184,0.3)', bgGradient: 'linear-gradient(165deg,#1e293b,#0f172a)', artBg: 'rgba(255,255,255,0.04)', badgeColor: 'rgba(148,163,184,0.2)', badgeText: '#94a3b8' },
  uncommon:  { borderColor: '#34d399', glowColor: 'rgba(52,211,153,0.35)',  bgGradient: 'linear-gradient(165deg,#0f3d33,#071a16)', artBg: 'rgba(52,211,153,0.06)',  badgeColor: 'rgba(52,211,153,0.18)', badgeText: '#34d399' },
  rare:      { borderColor: '#60a5fa', glowColor: 'rgba(96,165,250,0.4)',  bgGradient: 'linear-gradient(165deg,#1e3a5f,#0f172a)', artBg: 'rgba(96,165,250,0.07)',  badgeColor: 'rgba(96,165,250,0.2)',  badgeText: '#60a5fa' },
  epic:      { borderColor: '#a855f7', glowColor: 'rgba(168,85,247,0.4)',  bgGradient: 'linear-gradient(165deg,#2d1b4e,#0f0a1e)', artBg: 'rgba(168,85,247,0.07)',  badgeColor: 'rgba(168,85,247,0.2)',  badgeText: '#a855f7' },
  legendary: { borderColor: '#fbbf24', glowColor: 'rgba(251,191,36,0.5)',  bgGradient: 'linear-gradient(165deg,#3d2800,#1a0f00)', artBg: 'rgba(251,191,36,0.09)',  badgeColor: 'rgba(251,191,36,0.2)',  badgeText: '#fbbf24' },
};

type PurchaseCurrency = 'coins' | 'diamonds';

export const PurchaseConfirmModal: React.FC = () => {
  const user                  = useChemCityStore(s => s.user);
  const slimItems             = useChemCityStore(s => s.slimItems);
  const storePurchaseItemId   = useChemCityStore(s => s.storePurchaseItemId);
  const storePurchaseData     = useChemCityStore(s => s.storePurchaseData);
  const storePurchaseLoading  = useChemCityStore(s => s.storePurchaseLoading);
  const closePurchaseConfirm  = useChemCityStore(s => s.closePurchaseConfirm);
  const purchaseCard          = useChemCityStore(s => s.purchaseCard);

  const [purchasing, setPurchasing]         = useState(false);
  const [purchaseCurrency, setPurchaseCurrency] = useState<PurchaseCurrency>('coins');
  const [purchaseError, setPurchaseError]   = useState<string | null>(null);
  const [purchaseSuccess, setPurchaseSuccess] = useState(false);

  const isOpen = !!storePurchaseItemId;
  const slim   = slimItems.find(i => i.id === storePurchaseItemId);
  const full   = storePurchaseData;

  const isOwned  = !!user?.ownedItems?.includes(storePurchaseItemId ?? '');
  const rarity   = slim?.rarity ?? 'common';
  const cfg      = RARITY_CONFIG[rarity] ?? RARITY_CONFIG.common;
  const rarityStars = { common:1, uncommon:2, rare:2, epic:3, legendary:4 }[rarity] ?? 1;
  const discount = user?.activeBonuses.shopDiscountPercent ?? 0;
  const rawCoin  = slim?.shopData?.coinCost;
  const rawDiamond = slim?.shopData?.diamondCost;
  const effCoin  = rawCoin != null ? getEffectiveCoinPrice(rawCoin, user?.activeBonuses ?? null) : null;
  const coins    = user?.currencies.coins ?? 0;
  const diamonds = user?.currencies.diamonds ?? 0;
  const canAffordCoins    = effCoin != null && coins >= effCoin;
  const canAffordDiamonds = rawDiamond != null && diamonds >= rawDiamond;

  useEffect(() => {
    if (isOpen) {
      setPurchaseError(null);
      setPurchaseSuccess(false);
      setPurchasing(false);
      if (rawCoin != null) setPurchaseCurrency('coins');
      else if (rawDiamond != null) setPurchaseCurrency('diamonds');
    }
  }, [isOpen, storePurchaseItemId, rawCoin, rawDiamond]);

  if (!isOpen || !slim) return null;

  const handlePurchase = async () => {
    if (purchasing || isOwned) return;
    const canAfford = purchaseCurrency === 'coins' ? canAffordCoins : canAffordDiamonds;
    if (!canAfford) return;
    setPurchasing(true);
    setPurchaseError(null);
    try {
      await purchaseCard(slim.id, purchaseCurrency);
      setPurchaseSuccess(true);
      setTimeout(() => closePurchaseConfirm(), 1800);
    } catch (err: any) {
      setPurchaseError(err?.message ?? 'Purchase failed. Please try again.');
    } finally {
      setPurchasing(false);
    }
  };

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@500;600;700;800&display=swap');
        @keyframes purchaseIn { from{opacity:0;transform:scale(0.9) translateY(20px)} to{opacity:1;transform:scale(1) translateY(0)} }
        @keyframes shimmerSlide { 0%,100%{transform:translateX(-200%)} 50%{transform:translateX(200%)} }
        @keyframes legendGlow { 0%,100%{box-shadow:0 0 24px rgba(251,191,36,0.4)} 50%{box-shadow:0 0 44px rgba(251,191,36,0.7)} }
        @keyframes successPop { 0%{transform:scale(0.7);opacity:0} 60%{transform:scale(1.12)} 100%{transform:scale(1);opacity:1} }
        .purchase-panel { animation: purchaseIn 0.3s cubic-bezier(0.34,1.56,0.64,1) forwards; }
        .curr-tab { font-family:'Quicksand',sans-serif; font-weight:800; font-size:12px; padding:8px 16px; border-radius:10px; border:1.5px solid; cursor:pointer; transition:all 0.2s; display:flex; align-items:center; gap:6px; }
      `}</style>

      {/* Backdrop */}
      <div onClick={closePurchaseConfirm} style={{
        position: 'fixed', inset: 0, zIndex: 80,
        background: 'rgba(4,10,9,0.9)',
        backdropFilter: 'blur(14px)', WebkitBackdropFilter: 'blur(14px)',
        display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 16,
      }}>
        <div className="purchase-panel" onClick={e => e.stopPropagation()} style={{
          width: 'min(620px, 94vw)', maxHeight: '90vh',
          background: 'rgba(8,20,19,0.97)',
          backdropFilter: 'blur(24px)', WebkitBackdropFilter: 'blur(24px)',
          border: '1.5px solid rgba(197,215,181,0.18)',
          borderRadius: 24,
          boxShadow: '0 40px 100px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.05)',
          overflow: 'hidden', display: 'flex', flexDirection: 'column',
          fontFamily: "'Quicksand',sans-serif",
        }}>
          {/* Close */}
          <button onClick={closePurchaseConfirm} style={{
            position: 'absolute', top: 14, right: 14, zIndex: 10,
            background: 'rgba(255,255,255,0.08)', border: '1px solid rgba(255,255,255,0.12)',
            borderRadius: 8, width: 30, height: 30, cursor: 'pointer',
            display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#94a3b8',
          }}><X size={14} /></button>

          <div style={{ display: 'flex', gap: 0, flex: 1, minHeight: 0, overflow: 'hidden' }}>
            {/* ── Left: Vertical RPG Card ── */}
            <div style={{
              width: 200, flexShrink: 0, padding: '24px 0 24px 24px',
              display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 12,
            }}>
              {/* Card */}
              <div style={{
                width: 155, height: 220, borderRadius: 16,
                border: `2.5px solid ${cfg.borderColor}`,
                background: cfg.bgGradient,
                boxShadow: rarity === 'legendary'
                  ? `0 0 40px ${cfg.glowColor}, 0 8px 24px rgba(0,0,0,0.7)`
                  : `0 0 20px ${cfg.glowColor}, 0 6px 16px rgba(0,0,0,0.6)`,
                overflow: 'hidden', position: 'relative', flexShrink: 0,
                animation: rarity === 'legendary' ? 'legendGlow 2.5s ease-in-out infinite' : 'none',
              }}>
                {rarity === 'legendary' && (
                  <div style={{
                    position: 'absolute', inset: 0, zIndex: 1, pointerEvents: 'none',
                    background: 'linear-gradient(105deg,transparent 30%,rgba(255,215,0,0.13) 50%,transparent 70%)',
                    animation: 'shimmerSlide 3s ease-in-out infinite',
                  }} />
                )}
                {/* Stars */}
                <div style={{ position:'absolute', top:6, right:8, zIndex:3, color:cfg.badgeText, fontSize:10, letterSpacing:1 }}>
                  {'✦'.repeat(rarityStars)}
                </div>
                {/* Art */}
                <div style={{
                  height: 140, margin: '14px 10px 6px',
                  background: cfg.artBg, border: `1px solid ${cfg.borderColor}`,
                  borderRadius: 10, display: 'flex', alignItems: 'center', justifyContent: 'center',
                  overflow: 'hidden', position: 'relative', zIndex: 2,
                }}>
                  {(full?.imageUrl || slim.imageUrl) ? (
                    <img
                      src={full?.imageUrl || slim.imageUrl}
                      alt={slim.name}
                      style={{ width:'100%', height:'100%', objectFit:'cover' }}
                      {...(needsAnonymousCrossOrigin(full?.imageUrl || slim.imageUrl)
                        ? { crossOrigin: 'anonymous' as const, referrerPolicy: 'no-referrer' as const }
                        : {})}
                      onError={e => { (e.target as HTMLImageElement).style.display='none'; }}
                    />
                  ) : (
                    <span style={{ fontSize: 52 }}>{slim.emoji}</span>
                  )}
                </div>
                {/* Name / formula */}
                <div style={{ padding:'0 10px 4px', textAlign:'center', position:'relative', zIndex:2 }}>
                  <div style={{ color:'#f1f5f9', fontSize:11, fontWeight:800, overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap' }}>
                    {full?.displayName || slim.name}
                  </div>
                  <div style={{ color:'rgba(255,255,255,0.4)', fontSize:9, fontFamily:'monospace', marginTop:1 }}>
                    {slim.chemicalFormula}
                  </div>
                </div>
                {/* Rarity footer */}
                <div style={{
                  position:'absolute', bottom:8, left:10, right:10,
                  background:cfg.badgeColor, borderRadius:4, padding:'2px 0',
                  textAlign:'center', fontSize:8, fontWeight:800, color:cfg.badgeText,
                  textTransform:'uppercase', letterSpacing:'0.06em', zIndex:2,
                }}>{rarity}</div>

                {/* Owned stamp */}
                {isOwned && (
                  <div style={{
                    position:'absolute', inset:0, background:'rgba(0,0,0,0.55)', zIndex:4, borderRadius:14,
                    display:'flex', alignItems:'center', justifyContent:'center',
                  }}>
                    <div style={{ background:'rgba(74,222,128,0.9)', borderRadius:8, padding:'6px 14px', fontWeight:800, fontSize:12, color:'#052e16' }}>✓ Owned</div>
                  </div>
                )}
              </div>

              {/* Skill contribution */}
              {slim.skillContribution > 0 && (
                <div style={{
                  display:'flex', alignItems:'center', gap:6,
                  background:'rgba(118,168,165,0.12)', border:'1px solid rgba(118,168,165,0.3)',
                  borderRadius:8, padding:'6px 12px',
                }}>
                  <Zap size={12} color="#76A8A5" />
                  <span style={{ color:'rgba(197,215,181,0.8)', fontSize:11, fontWeight:700 }}>+{slim.skillContribution} Power</span>
                </div>
              )}
            </div>

            {/* ── Right: Info + Purchase ── */}
            <div style={{ flex:1, display:'flex', flexDirection:'column', minWidth:0, overflow:'hidden' }}>
              {/* Scrollable info */}
              <div style={{ flex:1, overflowY:'auto', padding:'24px 24px 12px' }}>
                <div style={{ color:'#fff', fontWeight:800, fontSize:17, marginBottom:4 }}>
                  {full?.displayName || slim.name}
                </div>
                <div style={{ color:'rgba(255,255,255,0.35)', fontFamily:'monospace', fontSize:12, marginBottom:12 }}>
                  {slim.chemicalFormula}
                </div>

                {storePurchaseLoading && (
                  <div style={{ display:'flex', flexDirection:'column', gap:8 }}>
                    {[1,2,3].map(i => <div key={i} style={{ height:14, background:'rgba(255,255,255,0.06)', borderRadius:6, animation:'pulse 1.5s infinite' }} />)}
                    <style>{`@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}`}</style>
                  </div>
                )}

                {full?.description && (
                  <p style={{ color:'rgba(255,255,255,0.6)', fontSize:12, lineHeight:1.7, margin:'0 0 12px', fontFamily:"'Quicksand',sans-serif" }}>
                    {full.description}
                  </p>
                )}

                {full?.educational?.funFact && (
                  <div style={{ background:'rgba(96,165,250,0.07)', border:'1px solid rgba(96,165,250,0.2)', borderRadius:10, padding:'10px 12px', marginBottom:10 }}>
                    <div style={{ display:'flex', alignItems:'center', gap:6, marginBottom:5 }}>
                      <FlaskConical size={11} color="#60a5fa" />
                      <span style={{ color:'#60a5fa', fontSize:10, fontWeight:800, textTransform:'uppercase', letterSpacing:'0.07em' }}>Fun Fact</span>
                    </div>
                    <p style={{ color:'rgba(255,255,255,0.65)', fontSize:11, lineHeight:1.6, margin:0 }}>{full.educational.funFact}</p>
                  </div>
                )}

                {full?.educational?.everydayUses && full.educational.everydayUses.length > 0 && (
                  <div style={{ marginBottom:10 }}>
                    <div style={{ display:'flex', alignItems:'center', gap:6, marginBottom:6 }}>
                      <Star size={10} color="#c5d7b5" />
                      <span style={{ color:'rgba(197,215,181,0.7)', fontSize:10, fontWeight:800, textTransform:'uppercase', letterSpacing:'0.07em' }}>Uses</span>
                    </div>
                    <div style={{ display:'flex', flexWrap:'wrap', gap:4 }}>
                      {full.educational.everydayUses.slice(0,5).map(use => (
                        <span key={use} style={{ background:'rgba(255,255,255,0.06)', border:'1px solid rgba(255,255,255,0.1)', borderRadius:6, padding:'3px 8px', fontSize:10, color:'rgba(255,255,255,0.6)', fontFamily:"'Quicksand',sans-serif", fontWeight:600 }}>{use}</span>
                      ))}
                    </div>
                  </div>
                )}

                {full?.topicConnections && full.topicConnections.length > 0 && (
                  <div>
                    <div style={{ display:'flex', alignItems:'center', gap:6, marginBottom:6 }}>
                      <BookOpen size={10} color="#86efac" />
                      <span style={{ color:'rgba(134,239,172,0.7)', fontSize:10, fontWeight:800, textTransform:'uppercase', letterSpacing:'0.07em' }}>DSE Topics</span>
                    </div>
                    <div style={{ display:'flex', flexWrap:'wrap', gap:4 }}>
                      {full.topicConnections.map(tid => (
                        <span key={tid} style={{ background:'rgba(134,239,172,0.08)', border:'1px solid rgba(134,239,172,0.25)', borderRadius:6, padding:'3px 8px', fontSize:10, color:'#86efac', fontFamily:"'Quicksand',sans-serif", fontWeight:600 }}>{tid}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>

              {/* ── Purchase Footer ── */}
              <div style={{ borderTop:'1px solid rgba(255,255,255,0.08)', padding:'14px 24px 20px', background:'rgba(0,0,0,0.2)', flexShrink:0 }}>
                {purchaseSuccess ? (
                  <div style={{ display:'flex', flexDirection:'column', alignItems:'center', gap:8, padding:'10px 0', animation:'successPop 0.4s ease forwards' }}>
                    <CheckCircle size={32} color="#4ade80" />
                    <span style={{ color:'#4ade80', fontWeight:800, fontSize:14 }}>Added to your collection!</span>
                  </div>
                ) : isOwned ? (
                  <div style={{ display:'flex', alignItems:'center', justifyContent:'center', gap:8, padding:'12px', background:'rgba(255,255,255,0.04)', border:'1px solid rgba(255,255,255,0.08)', borderRadius:12 }}>
                    <CheckCircle size={16} color="rgba(255,255,255,0.3)" />
                    <span style={{ color:'rgba(255,255,255,0.35)', fontWeight:700, fontSize:13 }}>Already in your collection</span>
                  </div>
                ) : (
                  <>
                    {/* Currency toggle */}
                    {effCoin != null && rawDiamond != null && (
                      <div style={{ display:'flex', gap:8, marginBottom:12 }}>
                        <button className="curr-tab" onClick={() => setPurchaseCurrency('coins')} style={{
                          flex:1, background: purchaseCurrency==='coins' ? 'rgba(251,191,36,0.15)' : 'rgba(255,255,255,0.05)',
                          borderColor: purchaseCurrency==='coins' ? 'rgba(251,191,36,0.5)' : 'rgba(255,255,255,0.1)',
                          color: purchaseCurrency==='coins' ? '#fbbf24' : 'rgba(255,255,255,0.4)',
                          justifyContent:'center',
                        }}>
                          <Coins size={14} /> Coins
                        </button>
                        <button className="curr-tab" onClick={() => setPurchaseCurrency('diamonds')} style={{
                          flex:1, background: purchaseCurrency==='diamonds' ? 'rgba(103,232,249,0.12)' : 'rgba(255,255,255,0.05)',
                          borderColor: purchaseCurrency==='diamonds' ? 'rgba(103,232,249,0.5)' : 'rgba(255,255,255,0.1)',
                          color: purchaseCurrency==='diamonds' ? '#67e8f9' : 'rgba(255,255,255,0.4)',
                          justifyContent:'center',
                        }}>
                          <Gem size={13} /> Diamonds
                        </button>
                      </div>
                    )}

                    {/* Price + balance */}
                    <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', marginBottom:10, padding:'10px 12px', background:'rgba(255,255,255,0.03)', borderRadius:10 }}>
                      <div>
                        {purchaseCurrency === 'coins' && effCoin != null && (
                          <div style={{ display:'flex', alignItems:'center', gap:8 }}>
                            <div style={{ display:'flex', alignItems:'center', gap:5 }}>
                              <Coins size={15} color="#fbbf24" />
                              <span style={{ color:'#fbbf24', fontWeight:800, fontSize:16 }}>{effCoin.toLocaleString()}</span>
                            </div>
                            {rawCoin != null && rawCoin !== effCoin && (
                              <span style={{ color:'rgba(255,255,255,0.25)', fontSize:12, textDecoration:'line-through' }}>{rawCoin.toLocaleString()}</span>
                            )}
                            {discount > 0 && (
                              <span style={{ background:'rgba(52,211,153,0.2)', border:'1px solid rgba(52,211,153,0.4)', borderRadius:20, padding:'1px 7px', fontSize:10, color:'#34d399', fontWeight:800 }}>{discount}% OFF</span>
                            )}
                          </div>
                        )}
                        {purchaseCurrency === 'diamonds' && rawDiamond != null && (
                          <div style={{ display:'flex', alignItems:'center', gap:5 }}>
                            <Gem size={14} color="#67e8f9" />
                            <span style={{ color:'#67e8f9', fontWeight:800, fontSize:16 }}>{rawDiamond.toLocaleString()}</span>
                          </div>
                        )}
                      </div>
                      <span style={{ color:'rgba(255,255,255,0.3)', fontSize:11, fontWeight:600 }}>
                        You have: {purchaseCurrency === 'coins' ? `${coins.toLocaleString()} 🪙` : `${diamonds.toLocaleString()} 💎`}
                      </span>
                    </div>

                    {purchaseError && <p style={{ color:'#f87171', fontSize:11, textAlign:'center', marginBottom:8 }}>{purchaseError}</p>}

                    {/* Shortfall notice */}
                    {purchaseCurrency === 'coins' && effCoin != null && !canAffordCoins && (
                      <p style={{ color:'rgba(251,191,36,0.7)', fontSize:11, textAlign:'center', marginBottom:8 }}>
                        Need {(effCoin - coins).toLocaleString()} more coins
                      </p>
                    )}
                    {purchaseCurrency === 'diamonds' && rawDiamond != null && !canAffordDiamonds && (
                      <p style={{ color:'rgba(103,232,249,0.7)', fontSize:11, textAlign:'center', marginBottom:8 }}>
                        Need {(rawDiamond - diamonds).toLocaleString()} more diamonds
                      </p>
                    )}

                    <button onClick={handlePurchase} disabled={
                      purchasing ||
                      (purchaseCurrency==='coins' && (!canAffordCoins || effCoin==null)) ||
                      (purchaseCurrency==='diamonds' && (!canAffordDiamonds || rawDiamond==null))
                    } style={{
                      width:'100%', padding:'13px',
                      borderRadius:12, border:'none',
                      background: purchasing ? 'rgba(255,255,255,0.08)'
                        : purchaseCurrency==='coins' && canAffordCoins ? 'linear-gradient(135deg, #b45309, #92400e)'
                        : purchaseCurrency==='diamonds' && canAffordDiamonds ? 'linear-gradient(135deg, #0e7490, #164e63)'
                        : 'rgba(255,255,255,0.06)',
                      color: (purchaseCurrency==='coins' && canAffordCoins) || (purchaseCurrency==='diamonds' && canAffordDiamonds) ? '#fff' : 'rgba(255,255,255,0.3)',
                      fontWeight:800, fontSize:14, cursor: purchasing ? 'not-allowed' : 'pointer',
                      fontFamily:"'Quicksand',sans-serif",
                      boxShadow: (purchaseCurrency==='coins' && canAffordCoins) ? '0 4px 20px rgba(180,83,9,0.4)' : 'none',
                      transition:'all 0.2s',
                      display:'flex', alignItems:'center', justifyContent:'center', gap:8,
                    }}>
                      {purchasing ? (
                        <div style={{ width:16, height:16, border:'2px solid rgba(255,255,255,0.2)', borderTopColor:'#fff', borderRadius:'50%', animation:'spin 0.8s linear infinite' }} />
                      ) : purchaseCurrency==='coins' && effCoin != null ? (
                        <><Coins size={16} />Buy for {effCoin.toLocaleString()} coins</>
                      ) : rawDiamond != null ? (
                        <><Gem size={15} />Buy for {rawDiamond.toLocaleString()} diamonds</>
                      ) : 'Not for sale'}
                    </button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
      <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>
    </>
  );
};

===== FILE: src/components/chemcity/CurrencyBar.tsx =====

import React, { useMemo, useState } from 'react';
import { Coins, Gem, ChevronLeft, Sparkles, BookOpen, ShoppingBag, Archive, Fuel, X, Zap, Ticket } from 'lucide-react';
import { useChemCityStore } from '../../store/chemcityStore';

export const CurrencyBar: React.FC = () => {
  const user               = useChemCityStore(s => s.user);
  const places             = useChemCityStore(s => s.places);
  const view               = useChemCityStore(s => s.view);
  const selectedPlaceId    = useChemCityStore(s => s.selectedPlaceId);
  const navigateToMap      = useChemCityStore(s => s.navigateToMap);
  const navigateToInventory = useChemCityStore(s => s.navigateToInventory);
  const navigateToStore    = useChemCityStore(s => s.navigateToStore);
  const navigateToCollections = useChemCityStore(s => s.navigateToCollections);
  const navigateToGasStationDistributor = useChemCityStore(s => s.navigateToGasStationDistributor);
  const navigateToGacha    = useChemCityStore(s => (s as any).navigateToGacha);
  const navigateToCosmetics = useChemCityStore(s => (s as any).navigateToCosmetics);

  const [skillsOpen, setSkillsOpen] = useState(false);

  const coins    = user?.currencies.coins ?? 0;
  const diamonds = user?.currencies.diamonds ?? 0;
  const tickets  = (user?.currencies as any)?.tickets ?? 0;

  const showGasDistributorButton = view === 'place' && selectedPlaceId === 'gas_station' && (user?.extraSlotsBudget ?? 0) > 0;

  const skillSummaryByPlaceId = useMemo(() => {
    const b = user?.activeBonuses;
    if (!b) return {} as Record<string, string>;
    return {
      garden:             `${b.passiveBaseCoinsPerHour.toLocaleString()} coins/hr`,
      lab:                `${b.passiveMultiplier.toFixed(1)}× multiplier`,
      kitchen:            `+${b.quizFlatDiamondBonus} diamond bonus`,
      school:             `${b.quizDiamondMultiplier.toFixed(1)}× quiz diamonds`,
      beach:              `${b.quizDoubleChancePercent}% double chance`,
      toilet:             `${b.dailyLoginDiamonds} daily diamonds`,
      gas_station:        `${b.extraSlotsTotal} bonus slots`,
      lifestyle_boutique: `${b.shopDiscountPercent}% store discount`,
    };
  }, [user?.activeBonuses]);

  const NavBtn: React.FC<{
    onClick: () => void; active: boolean; label: string; children: React.ReactNode; accent?: boolean;
  }> = ({ onClick, active, label, children, accent }) => (
    <button onClick={onClick} title={label} aria-label={label} style={{
      width: 36, height: 36, borderRadius: 10,
      border: `1.5px solid ${active ? 'rgba(118,168,165,0.6)' : accent ? 'rgba(251,191,36,0.4)' : 'rgba(255,255,255,0.12)'}`,
      background: active
        ? 'rgba(118,168,165,0.25)'
        : accent ? 'rgba(251,191,36,0.12)' : 'rgba(8,20,19,0.9)',
      backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
      color: active ? '#C5D7B5' : accent ? '#fbbf24' : '#94a3b8',
      cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center',
      transition: 'all 0.2s ease',
      boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
    }}>
      {children}
    </button>
  );

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@500;600;700;800&display=swap');
        .skills-row:hover { background: rgba(255,255,255,0.06) !important; }
      `}</style>

      <div style={{
        position: 'fixed', top: 84, left: 12, right: 12, zIndex: 50,
        display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8,
        pointerEvents: 'none',
        fontFamily: "'Quicksand',sans-serif",
      }}>
        {/* Left: Back button */}
        <div style={{ pointerEvents: 'auto' }}>
          {view !== 'map' && (
            <button onClick={navigateToMap} title="Back to map" aria-label="Back to map" style={{
              width: 36, height: 36, borderRadius: 10,
              border: '1.5px solid rgba(255,255,255,0.12)',
              background: 'rgba(8,20,19,0.9)',
              backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
              color: '#94a3b8', cursor: 'pointer',
              display: 'flex', alignItems: 'center', justifyContent: 'center',
              boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
              transition: 'all 0.2s',
            }}>
              <ChevronLeft size={18} />
            </button>
          )}
        </div>

        {/* Right: Currency pills + nav buttons */}
        <div style={{ display: 'flex', alignItems: 'center', gap: 7, pointerEvents: 'auto' }}>
          {/* Coins pill */}
          <div style={{
            display: 'flex', alignItems: 'center', gap: 6,
            background: 'rgba(8,20,19,0.9)',
            border: '1.5px solid rgba(251,191,36,0.25)',
            backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
            borderRadius: 20, padding: '5px 10px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
          }}>
            <Coins size={13} color="#fbbf24" />
            <span style={{ color: '#fff', fontSize: 13, fontWeight: 800, fontVariantNumeric: 'tabular-nums' }}>
              {coins.toLocaleString()}
            </span>
          </div>

          {/* Diamonds pill */}
          <div style={{
            display: 'flex', alignItems: 'center', gap: 6,
            background: 'rgba(8,20,19,0.9)',
            border: '1.5px solid rgba(103,232,249,0.25)',
            backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
            borderRadius: 20, padding: '5px 10px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
          }}>
            <Gem size={12} color="#67e8f9" />
            <span style={{ color: '#fff', fontSize: 13, fontWeight: 800, fontVariantNumeric: 'tabular-nums' }}>
              {diamonds.toLocaleString()}
            </span>
          </div>

          {/* Tickets pill */}
          <div style={{
            display: 'flex', alignItems: 'center', gap: 6,
            background: 'rgba(8,20,19,0.9)',
            border: '1.5px solid rgba(167,139,250,0.25)',
            backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
            borderRadius: 20, padding: '5px 10px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
          }}>
            <Ticket size={12} color="#a78bfa" />
            <span style={{ color: '#fff', fontSize: 13, fontWeight: 800, fontVariantNumeric: 'tabular-nums' }}>
              {Number(tickets || 0).toLocaleString()}
            </span>
          </div>

          <NavBtn onClick={() => setSkillsOpen(true)} active={false} label="Skill Boosts">
            <Sparkles size={15} />
          </NavBtn>
          <NavBtn onClick={navigateToCollections} active={view === 'collections'} label="Collections Album">
            <BookOpen size={15} />
          </NavBtn>
          <NavBtn onClick={navigateToStore} active={view === 'store'} label="ChemStore">
            <ShoppingBag size={15} />
          </NavBtn>
          <NavBtn onClick={() => navigateToGacha?.()} active={view === 'gacha'} label="Gacha Machine" accent>
            <Ticket size={15} />
          </NavBtn>
          <NavBtn onClick={() => navigateToCosmetics?.()} active={view === 'cosmetics'} label="Cosmetics" accent>
            <Sparkles size={15} />
          </NavBtn>
          <NavBtn onClick={navigateToInventory} active={view === 'inventory'} label="Card Inventory">
            <Archive size={15} />
          </NavBtn>
          {showGasDistributorButton && (
            <NavBtn onClick={navigateToGasStationDistributor} active={false} label="Distribute Bonus Slots" accent>
              <Fuel size={15} />
            </NavBtn>
          )}
        </div>
      </div>

      {/* ── Skills Modal ── */}
      {skillsOpen && (
        <div
          onClick={() => setSkillsOpen(false)}
          style={{
            position: 'fixed', inset: 0, zIndex: 60,
            background: 'rgba(4,10,9,0.88)',
            backdropFilter: 'blur(14px)', WebkitBackdropFilter: 'blur(14px)',
            display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 16,
          }}
        >
          <div onClick={e => e.stopPropagation()} style={{
            width: 'min(420px, 94vw)',
            background: 'rgba(8,20,19,0.97)',
            border: '1.5px solid rgba(197,215,181,0.18)',
            borderRadius: 20,
            boxShadow: '0 32px 80px rgba(0,0,0,0.7)',
            overflow: 'hidden',
            fontFamily: "'Quicksand',sans-serif",
          }}>
            {/* Header */}
            <div style={{
              padding: '16px 18px', borderBottom: '1px solid rgba(197,215,181,0.1)',
              display: 'flex', alignItems: 'center', justifyContent: 'space-between',
              background: 'linear-gradient(135deg, rgba(118,168,165,0.12) 0%, transparent)',
            }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                <div style={{ background:'rgba(118,168,165,0.2)', border:'1.5px solid rgba(118,168,165,0.4)', borderRadius:10, width:36, height:36, display:'flex', alignItems:'center', justifyContent:'center' }}>
                  <Sparkles size={16} color="#76A8A5" />
                </div>
                <div>
                  <div style={{ color: '#fff', fontWeight: 800, fontSize: 15 }}>Skill Boosts</div>
                  <div style={{ color: 'rgba(197,215,181,0.5)', fontSize: 11, fontWeight: 600 }}>Active card bonuses</div>
                </div>
              </div>
              <button onClick={() => setSkillsOpen(false)} style={{
                background: 'rgba(255,255,255,0.07)', border: '1.5px solid rgba(255,255,255,0.12)',
                borderRadius: 8, width: 30, height: 30, cursor: 'pointer',
                display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#94a3b8',
              }}><X size={14} /></button>
            </div>

            {/* Skills list */}
            <div style={{ padding: '12px', display: 'flex', flexDirection: 'column', gap: 6, maxHeight: '65vh', overflowY: 'auto' }}>
              {places.map(p => (
                <div key={p.id} className="skills-row" style={{
                  display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 12,
                  background: 'rgba(255,255,255,0.03)', border: '1px solid rgba(255,255,255,0.07)',
                  borderRadius: 12, padding: '10px 14px',
                  transition: 'background 0.2s',
                }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 10, minWidth: 0 }}>
                    <div style={{ fontSize: 20, flexShrink: 0 }}>{p.emoji}</div>
                    <div style={{ minWidth: 0 }}>
                      <div style={{ color: '#fff', fontWeight: 800, fontSize: 12 }}>{p.displayName}</div>
                      <div style={{ color: 'rgba(197,215,181,0.4)', fontSize: 10, fontWeight: 600, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {p.skill.description}
                      </div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 5, flexShrink: 0 }}>
                    <Zap size={10} color="#76A8A5" />
                    <span style={{ color: '#76A8A5', fontWeight: 800, fontSize: 12 }}>
                      {skillSummaryByPlaceId[p.id] ?? '—'}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </>
  );
};

===== FILE: src/components/chemcity/ChemCityRoot.tsx =====

import React, { useEffect } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useChemCityStore } from '../../store/chemcityStore';
import { CurrencyBar } from './CurrencyBar';
import { ChemCityMap } from './ChemCityMap';
import { PlaceView } from './PlaceView';
import { CardInventory } from './CardInventory';
import { CardPicker } from './CardPicker';
import { CardDetail } from './CardDetail';
import { DailyLoginModal } from './DailyLoginModal';
import { QuizRewardModal } from './QuizRewardModal';
import { ChemStore } from './ChemStore';
import { PurchaseConfirmModal } from './PurchaseConfirmModal';
import { PlaceUnlockModal } from './PlaceUnlockModal';
import { GasStationDistributor } from './GasStationDistributor';
import { CollectionsAlbum } from './CollectionsAlbum';
import { OnboardingOverlay } from './OnboardingOverlay';
import { GachaScreen } from './gacha/GachaScreen';
import { CosmeticsInventory } from './gacha/CosmeticsInventory';

export const ChemCityRoot: React.FC = () => {
  const { currentUser } = useAuth();

  const view = useChemCityStore((s) => s.view);
  const isLoading = useChemCityStore((s) => s.isLoading);
  const error = useChemCityStore((s) => s.error);
  const loadAll = useChemCityStore((s) => s.loadAll);
  const teardown = useChemCityStore((s) => s.teardown);
  const dailyLoginOpen = useChemCityStore((s) => s.dailyLogin.showModal);
  const showOnboarding = useChemCityStore((s) => s.showOnboarding);

  useEffect(() => {
    if (!currentUser?.uid) return;
    loadAll(currentUser.uid);
    return () => {
      teardown();
    };
  }, [currentUser?.uid, loadAll, teardown]);

  if (!currentUser) {
    return (
      <div className="flex flex-col min-h-screen bg-slate-950 items-center justify-center gap-4 px-8">
        <span className="text-5xl">🧪</span>
        <p className="text-slate-400 text-sm text-center">Please sign in to access ChemCity.</p>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex flex-col min-h-screen bg-slate-950 items-center justify-center gap-4">
        <span className="text-5xl animate-pulse">🧪</span>
        <p className="text-slate-400 text-sm">Loading ChemCity...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col min-h-screen bg-slate-950 items-center justify-center gap-4 px-8">
        <span className="text-4xl">⚠️</span>
        <p className="text-red-400 text-sm text-center">{error}</p>
        <button
          onClick={() => window.location.reload()}
          className="bg-slate-700 hover:bg-slate-600 text-white rounded-lg px-4 py-2 text-sm"
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div className="relative flex flex-col min-h-screen bg-slate-950 text-white overflow-hidden">
      <CurrencyBar />

      <main className="flex-1 overflow-hidden flex flex-col">
        {view === 'map' && <ChemCityMap />}
        {view === 'place' && <PlaceView />}
        {view === 'inventory' && <CardInventory />}
        {view === 'store' && <ChemStore />}
        {view === 'gas_station_distributor' && <GasStationDistributor />}
        {view === 'collections' && <CollectionsAlbum />}
        {view === 'gacha' && <GachaScreen />}
        {view === 'cosmetics' && <CosmeticsInventory />}
      </main>

      <CardPicker />
      <CardDetail />

      <DailyLoginModal />
      {!dailyLoginOpen && <QuizRewardModal />}

      <PlaceUnlockModal />
      <PurchaseConfirmModal />

      {showOnboarding && <OnboardingOverlay />}
    </div>
  );
};


===== FILE: src/store/chemcityStore.ts =====

import { create } from 'zustand';
import { doc, getDoc, onSnapshot, type Unsubscribe } from 'firebase/firestore';
import { db } from '../firebase/config';
import { fetchSlimItems, fetchPlaces, fetchFullItem, fetchCollections } from '../lib/cache';
import type {
  UserChemCityData,
  UserProgressData,
  SlimItemDocument,
  PlaceDocument,
  FullItemDocument,
  CollectionDocument,
  Cosmetic,
  GachaBanner,
} from '../lib/chemcity/types';
import {
  callChemCityInitUser,
  callChemCityMigrateSlotIds,
  callChemCityEquipCard,
  callChemCityUnequipCard,
  callChemCityCollectPassiveIncome,
  callChemCityUnlockPlace,
  callChemCityUnlockSlot,
  callChemCityGetDailyLoginBonus,
  callChemCityQuizReward,
  callChemCityPurchaseCard,
  callChemCityUnlockStoreSlot,
  callChemCityClaimCollectionReward,
  callChemCityDevGrantCoins,
} from '../lib/chemcity/cloudFunctions';
import { estimateUnclaimedCoins } from '../lib/chemcity/income';
import { getDailyStoreItems, STORE_MIN_SLOTS } from '../lib/chemcity/dailyStore';
import type { QuizRewardRequest, QuizRewardResult } from '../lib/chemcity/types';
import { getActiveBanners, getCosmeticsMap } from '../lib/chemcity/gachaStaticCache';
import { getServerCacheVersion } from '../lib/cache';

const ONBOARDING_STORAGE_KEY = 'chemcity_onboarding_done_v1';
const DISABLE_FIRESTORE_LISTENERS =
  String((import.meta as any).env?.VITE_DISABLE_FIRESTORE_LISTENERS ?? '').trim() === '1';
const USER_POLL_INTERVAL_MS = 15_000;

function hasSeenOnboarding(): boolean {
  try {
    return localStorage.getItem(ONBOARDING_STORAGE_KEY) === '1';
  } catch {
    return false;
  }
}

function markOnboardingDone(): void {
  try {
    localStorage.setItem(ONBOARDING_STORAGE_KEY, '1');
  } catch {
    // ignore
  }
}

type View = 'map' | 'place' | 'inventory' | 'store' | 'gas_station_distributor' | 'collections';

type GachaView = 'gacha' | 'cosmetics';

type ExtendedView = View | GachaView;

type RootUserDoc = {
  chemcity?: UserChemCityData;
} & Record<string, unknown>;

interface ChemCityStore {
  user: UserChemCityData | null;
  userGender: 'boy' | 'girl' | null;
  progress: UserProgressData | null;
  slimItems: SlimItemDocument[];
  places: PlaceDocument[];
  collections: CollectionDocument[];

  cosmeticsMap: Map<string, Cosmetic>;
  activeBanners: GachaBanner[];
  gachaStaticLoaded: boolean;
  gachaStaticVersion: number | null;

  isLoading: boolean;
  error: string | null;

  view: ExtendedView;
  selectedPlaceId: string | null;

  cardPickerSlotId: string | null;

  cardDetailItemId: string | null;
  cardDetailData: FullItemDocument | null;
  cardDetailLoading: boolean;

  passiveDisplayCoins: number;

  // Phase 4: store + unlock modals
  dailyStoreItems: SlimItemDocument[];
  storeSlotCount: number;
  storePurchaseItemId: string | null;
  storePurchaseData: FullItemDocument | null;
  storePurchaseLoading: boolean;
  placeUnlockModalId: string | null;

  quizReward: {
    result: QuizRewardResult | null;
    correctAnswers: number;
    totalQuestions: number;
    isAwarding: boolean;
  };

  dailyLogin: {
    diamonds: number;
    coins: number;
    streak: number;
    showModal: boolean;
    checked: boolean;
  };

  showOnboarding: boolean;

  _unsubUser: Unsubscribe | null;
  _userPollTimer: number | null;

  loadAll: (userId: string) => Promise<void>;
  teardown: () => void;

  navigateToMap: () => void;
  navigateToPlace: (placeId: string) => void;
  navigateToInventory: () => void;
  navigateToStore: () => void;
  navigateToGasStationDistributor: () => void;
  navigateToCollections: () => void;
  navigateToGacha: () => void;
  navigateToCosmetics: () => void;

  openCardPicker: (slotId: string) => void;
  closeCardPicker: () => void;

  openCardDetail: (itemId: string) => Promise<void>;
  closeCardDetail: () => void;

  equipCard: (slotId: string, itemId: string) => Promise<void>;
  unequipCard: (slotId: string) => Promise<void>;

  collectIncome: () => Promise<{ coinsAwarded: number }>;

  unlockPlace: (placeId: string) => Promise<void>;
  unlockSlot: (placeId: string, slotId: string, useExtraSlotBudget?: boolean) => Promise<void>;

  tickPassiveDisplay: () => void;

  awardQuizReward: (request: QuizRewardRequest) => Promise<void>;
  clearQuizReward: () => void;

  checkDailyLogin: () => Promise<void>;
  dismissDailyLogin: () => void;

  computeDailyStore: (userId: string) => void;
  unlockStoreSlot: () => Promise<void>;

  devRefreshStaticData: () => Promise<void>;
  devGrantCoins: (amount: number) => Promise<void>;
  devRerollStore: () => void;

  loadGachaStatic: () => Promise<void>;

  openPurchaseConfirm: (itemId: string) => void;
  closePurchaseConfirm: () => void;
  purchaseCard: (itemId: string, currency: 'coins' | 'diamonds') => Promise<void>;

  openPlaceUnlockModal: (placeId: string) => void;
  closePlaceUnlockModal: () => void;

  claimCollectionReward: (collectionId: string) => Promise<void>;
  dismissOnboarding: () => void;
}

export const useChemCityStore = create<ChemCityStore>((set, get) => ({
  user: null,
  userGender: null,
  progress: null,
  slimItems: [],
  places: [],
  collections: [],

  cosmeticsMap: new Map(),
  activeBanners: [],
  gachaStaticLoaded: false,
  gachaStaticVersion: null,

  isLoading: false,
  error: null,

  view: 'map',
  selectedPlaceId: null,

  cardPickerSlotId: null,

  cardDetailItemId: null,
  cardDetailData: null,
  cardDetailLoading: false,

  passiveDisplayCoins: 0,

  dailyStoreItems: [],
  storeSlotCount: STORE_MIN_SLOTS,
  storePurchaseItemId: null,
  storePurchaseData: null,
  storePurchaseLoading: false,
  placeUnlockModalId: null,

  quizReward: {
    result: null,
    correctAnswers: 0,
    totalQuestions: 0,
    isAwarding: false,
  },

  dailyLogin: {
    diamonds: 0,
    coins: 0,
    streak: 0,
    showModal: false,
    checked: false,
  },

  showOnboarding: false,

  _unsubUser: null,
  _userPollTimer: null,

  loadAll: async (userId: string) => {
    set({ isLoading: true, error: null });
    try {
      const [slimItems, places, collections] = await Promise.all([
        fetchSlimItems(),
        fetchPlaces(),
        fetchCollections(),
      ]);

      await callChemCityInitUser();
      await callChemCityMigrateSlotIds();

      const userRef = doc(db, 'users', userId);
      const userSnap = await getDoc(userRef);
      const root = (userSnap.data() || {}) as RootUserDoc;
      const chemcity = (root.chemcity || null) as UserChemCityData | null;

      const progressRef = doc(db, 'users', userId, 'chemcity_progress', 'data');
      const progressSnap = await getDoc(progressRef);
      const progress = (progressSnap.data() || null) as UserProgressData | null;

      const existing = get()._unsubUser;
      if (existing) existing();
      const existingTimer = get()._userPollTimer;
      if (existingTimer) window.clearInterval(existingTimer);

      if (!DISABLE_FIRESTORE_LISTENERS) {
        const unsub = onSnapshot(userRef, (snap) => {
          if (!snap.exists()) return;
          const freshRoot = (snap.data() || {}) as RootUserDoc;
          const fresh = (freshRoot.chemcity || null) as UserChemCityData | null;
          const genderRaw = (freshRoot as any)?.gender;
          const userGender: 'boy' | 'girl' | null =
            genderRaw === 'girl' ? 'girl' : genderRaw === 'boy' ? 'boy' : null;

          // Phase 4: mirror storeSlotCount (default 3) + compute daily store items
          const slotCount = (fresh as any)?.storeSlotCount ?? STORE_MIN_SLOTS;
          const pool = get().slimItems;
          const dailyStoreItems = fresh ? getDailyStoreItems(userId, pool, slotCount) : [];

          set({ user: fresh, userGender, storeSlotCount: slotCount, dailyStoreItems });
        });

        const progressUnsub = onSnapshot(progressRef, (snap) => {
          if (!snap.exists()) return;
          set({ progress: (snap.data() || null) as any });
        });

        set({ _unsubUser: () => { unsub(); progressUnsub(); }, _userPollTimer: null });
      } else {
        // Fallback: polling to avoid Listen/channel transport issues in some environments.
        const poll = async () => {
          try {
            const snap = await getDoc(userRef);
            if (!snap.exists()) return;
            const freshRoot = (snap.data() || {}) as RootUserDoc;
            const fresh = (freshRoot.chemcity || null) as UserChemCityData | null;
            const genderRaw = (freshRoot as any)?.gender;
            const userGender: 'boy' | 'girl' | null =
              genderRaw === 'girl' ? 'girl' : genderRaw === 'boy' ? 'boy' : null;
            const slotCount = (fresh as any)?.storeSlotCount ?? STORE_MIN_SLOTS;
            const pool = get().slimItems;
            const dailyStoreItems = fresh ? getDailyStoreItems(userId, pool, slotCount) : [];
            set({ user: fresh, userGender, storeSlotCount: slotCount, dailyStoreItems });
          } catch {
            // ignore
          }
        };

        // Immediate poll then interval
        poll();
        const timer = window.setInterval(poll, USER_POLL_INTERVAL_MS);
        set({ _unsubUser: null, _userPollTimer: timer });
      }

      const showOnboarding = (() => {
        if (hasSeenOnboarding()) return false;
        const createdAt = (chemcity as any)?.createdAt;
        if (!createdAt) return true;
        const createdMs =
          typeof createdAt?.toMillis === 'function'
            ? createdAt.toMillis()
            : typeof createdAt === 'number'
              ? createdAt
              : Date.now();
        return Date.now() - createdMs < 90_000;
      })();

      set({
        user: chemcity,
        progress,
        slimItems,
        places,
        collections,
        isLoading: false,
        passiveDisplayCoins: 0,
        storeSlotCount: (chemcity as any)?.storeSlotCount ?? STORE_MIN_SLOTS,
        dailyStoreItems: chemcity
          ? getDailyStoreItems(userId, slimItems, (chemcity as any)?.storeSlotCount ?? STORE_MIN_SLOTS)
          : [],
        showOnboarding,
      });

      // Phase 3: check daily login bonus (non-blocking)
      get().checkDailyLogin();

      // Phase 4: compute store (non-blocking)
      setTimeout(() => get().computeDailyStore(userId), 200);

      // Gacha: load static catalog (non-blocking)
      setTimeout(() => get().loadGachaStatic(), 250);
    } catch (err: any) {
      set({ isLoading: false, error: err?.message || 'Failed to load ChemCity' });
    }
  },

  devGrantCoins: async (amount: number) => {
    if (!Number.isFinite(amount) || amount === 0) return;
    await callChemCityDevGrantCoins(amount);
  },

  devRerollStore: () => {
    const userId = get().user?.userId;
    if (!userId) return;
    const pool = get().slimItems;
    const slotCount = get().storeSlotCount ?? STORE_MIN_SLOTS;
    const salt = Math.random().toString(36).slice(2, 10);
    const dailyStoreItems = getDailyStoreItems(`${userId}:dev:${salt}`, pool, slotCount);
    set({ dailyStoreItems });
  },

  loadGachaStatic: async () => {
    try {
      const serverVersion = await getServerCacheVersion();
      const prevVersion = get().gachaStaticVersion;
      if (get().gachaStaticLoaded && prevVersion === serverVersion) return;

      const [cosmeticsMap, activeBanners] = await Promise.all([
        getCosmeticsMap(),
        getActiveBanners(),
      ]);
      set({ cosmeticsMap, activeBanners, gachaStaticLoaded: true, gachaStaticVersion: serverVersion });
    } catch (err: any) {
      console.error('[Gacha] Failed to load static data:', err);
      // Still mark as loaded so UI shows (with empty data if needed)
      set({ gachaStaticLoaded: true });
    }
  },

  teardown: () => {
    const unsub = get()._unsubUser;
    if (unsub) unsub();
    const t = get()._userPollTimer;
    if (t) window.clearInterval(t);
    set({ _unsubUser: null, _userPollTimer: null, userGender: null });
  },

  navigateToMap: () => set({ view: 'map', selectedPlaceId: null }),
  navigateToPlace: (placeId) => set({ view: 'place', selectedPlaceId: placeId }),
  navigateToInventory: () => set({ view: 'inventory' }),
  navigateToStore: () => set({ view: 'store' }),
  navigateToGasStationDistributor: () => set({ view: 'gas_station_distributor' }),
  navigateToCollections: () => set({ view: 'collections' }),
  navigateToGacha: () => set({ view: 'gacha' }),
  navigateToCosmetics: () => set({ view: 'cosmetics' }),

  openCardPicker: (slotId) => set({ cardPickerSlotId: slotId }),
  closeCardPicker: () => set({ cardPickerSlotId: null }),

  openCardDetail: async (itemId: string) => {
    set({ cardDetailItemId: itemId, cardDetailData: null, cardDetailLoading: true });
    try {
      const full = await fetchFullItem(itemId);
      set({ cardDetailData: full ?? null, cardDetailLoading: false });
    } catch {
      set({ cardDetailLoading: false });
    }
  },
  closeCardDetail: () => set({ cardDetailItemId: null, cardDetailData: null, cardDetailLoading: false }),

  equipCard: async (slotId, itemId) => {
    const { user } = get();
    if (!user) return;

    // Optimistic update - show equipped immediately
    const previousEquipped = user.equipped?.[slotId];
    set({
      user: {
        ...user,
        equipped: { ...user.equipped, [slotId]: itemId },
      },
    });

    try {
      await callChemCityEquipCard(slotId, itemId);
    } catch (err) {
      // Revert on error
      set({
        user: {
          ...user,
          equipped: { ...user.equipped, [slotId]: previousEquipped },
        },
      });
      throw err;
    }
  },

  unequipCard: async (slotId) => {
    const { user } = get();
    if (!user) return;

    // Optimistic update - show unequipped immediately
    const previousEquipped = user.equipped?.[slotId];
    const newEquipped = { ...user.equipped };
    delete newEquipped[slotId];

    set({
      user: {
        ...user,
        equipped: newEquipped,
      },
    });

    try {
      await callChemCityUnequipCard(slotId);
    } catch (err) {
      // Revert on error
      set({
        user: {
          ...user,
          equipped: { ...user.equipped, [slotId]: previousEquipped },
        },
      });
      throw err;
    }
  },

  collectIncome: async () => {
    const result = await callChemCityCollectPassiveIncome();
    set({ passiveDisplayCoins: 0 });
    return { coinsAwarded: Number(result.coinsAwarded || 0) };
  },

  unlockPlace: async (placeId) => {
    await callChemCityUnlockPlace(placeId);
  },

  unlockSlot: async (placeId, slotId, useExtraSlotBudget) => {
    await callChemCityUnlockSlot(placeId, slotId, useExtraSlotBudget);
  },

  computeDailyStore: (userId: string) => {
    const state = get();
    if (!state.user) return;
    const slotCount = state.storeSlotCount ?? STORE_MIN_SLOTS;
    const dailyStoreItems = getDailyStoreItems(userId, state.slimItems, slotCount);
    set({ dailyStoreItems });
  },

  devRefreshStaticData: async () => {
    try {
      localStorage.removeItem('cc_manifest');
      localStorage.removeItem('cc_slim_items');
      localStorage.removeItem('cc_places');
      localStorage.removeItem('cc_collections');
      localStorage.removeItem('cc_topics');
    } catch {
      // ignore
    }

    set({ gachaStaticLoaded: false, gachaStaticVersion: null });

    const userId = get().user?.userId;
    if (!userId) return;

    set({ isLoading: true, error: null });
    try {
      const [slimItems, places, collections] = await Promise.all([
        fetchSlimItems(),
        fetchPlaces(),
        fetchCollections(),
      ]);

      const slotCount = get().storeSlotCount ?? STORE_MIN_SLOTS;
      const dailyStoreItems = getDailyStoreItems(userId, slimItems, slotCount);

      set({ slimItems, places, collections, dailyStoreItems, isLoading: false });
    } catch (err: any) {
      set({ isLoading: false, error: err?.message || 'Failed to refresh ChemCity data' });
    }
  },

  unlockStoreSlot: async () => {
    await callChemCityUnlockStoreSlot();
  },

  openPurchaseConfirm: (itemId: string) => {
    set({ storePurchaseItemId: itemId, storePurchaseData: null, storePurchaseLoading: true });
    fetchFullItem(itemId)
      .then((data) => set({ storePurchaseData: data ?? null, storePurchaseLoading: false }))
      .catch(() => set({ storePurchaseLoading: false }));
  },

  closePurchaseConfirm: () =>
    set({ storePurchaseItemId: null, storePurchaseData: null, storePurchaseLoading: false }),

  purchaseCard: async (itemId: string, currency: 'coins' | 'diamonds') => {
    await callChemCityPurchaseCard(itemId, currency);
  },

  openPlaceUnlockModal: (placeId: string) => set({ placeUnlockModalId: placeId }),
  closePlaceUnlockModal: () => set({ placeUnlockModalId: null }),

  tickPassiveDisplay: () => {
    const user = get().user;
    if (!user) return;

    const lastCollected = (user.passiveIncome?.lastCollected ?? null) as any;
    const coins = estimateUnclaimedCoins(user.activeBonuses, lastCollected);
    set({ passiveDisplayCoins: coins });
  },

  awardQuizReward: async (request) => {
    set((s) => ({
      quizReward: {
        ...s.quizReward,
        isAwarding: true,
        result: null,
      },
    }));

    try {
      const result = await callChemCityQuizReward(request);
      set({
        quizReward: {
          result,
          correctAnswers: request.correctAnswers ?? 0,
          totalQuestions: request.totalQuestions ?? 0,
          isAwarding: false,
        },
      });
    } catch {
      set((s) => ({
        quizReward: { ...s.quizReward, isAwarding: false },
      }));
    }
  },

  clearQuizReward: () => {
    set({
      quizReward: {
        result: null,
        correctAnswers: 0,
        totalQuestions: 0,
        isAwarding: false,
      },
    });
  },

  checkDailyLogin: async () => {
    const { dailyLogin } = get();
    if (dailyLogin.checked) return;

    try {
      const result = await callChemCityGetDailyLoginBonus();
      const alreadyClaimed = Boolean((result as any)?.alreadyClaimed);
      if (alreadyClaimed) {
        set((s) => ({ dailyLogin: { ...s.dailyLogin, checked: true } }));
        return;
      }

      set({
        dailyLogin: {
          diamonds: Number((result as any)?.diamondsAwarded || 0),
          coins: Number((result as any)?.coinsAwarded || 0),
          streak: Number((result as any)?.currentStreak || 0),
          showModal: true,
          checked: true,
        },
      });
    } catch {
      set((s) => ({ dailyLogin: { ...s.dailyLogin, checked: true } }));
    }
  },

  dismissDailyLogin: () => {
    set((s) => ({ dailyLogin: { ...s.dailyLogin, showModal: false } }));
  },

  claimCollectionReward: async (collectionId: string) => {
    await callChemCityClaimCollectionReward(collectionId);
  },

  dismissOnboarding: () => {
    markOnboardingDone();
    set({ showOnboarding: false });
  },
}));


===== FILE: src/lib/chemcity/cloudFunctions.ts =====

import { getFunctions, httpsCallable } from 'firebase/functions';
import type {
  EquipCardRequest,
  UnequipCardRequest,
  PurchaseCardRequest,
  GachaDrawRequest,
  GachaDrawResponse,
  PurchaseCosmeticRequest,
  PurchaseCosmeticResponse,
  EquipCosmeticsRequest,
  EquipCosmeticsResponse,
  BuyTicketsRequest,
  BuyTicketsResponse,
  UnlockPlaceRequest,
  UnlockSlotRequest,
  QuizRewardRequest,
  QuizRewardResult,
} from './types';

function getFns() {
  return getFunctions(undefined, 'asia-east1');
}

export async function callChemCityInitUser(): Promise<void> {
  const fn = httpsCallable(getFns(), 'chemcityInitUser');
  await fn({});
}

export interface MigrateSlotIdsResult {
  ok: boolean;
  alreadyMigrated?: boolean;
  version?: number;
  equippedKeysMigrated?: number;
  unlockedSlotsMigrated?: number;
}

export async function callChemCityMigrateSlotIds(): Promise<MigrateSlotIdsResult> {
  const fn = httpsCallable(getFns(), 'chemcityMigrateSlotIds');
  const result = await fn({});
  return result.data as MigrateSlotIdsResult;
}

export async function callChemCityEquipCard(slotId: string, itemId: string): Promise<void> {
  const fn = httpsCallable<EquipCardRequest, { ok?: boolean }>(getFns(), 'chemcityEquipCard');
  await fn({ slotId, itemId });
}

export async function callChemCityUnequipCard(slotId: string): Promise<void> {
  const fn = httpsCallable<UnequipCardRequest, { ok?: boolean }>(getFns(), 'chemcityUnequipCard');
  await fn({ slotId });
}

export async function callChemCityCollectPassiveIncome(): Promise<{ coinsAwarded: number } & Record<string, unknown>> {
  const fn = httpsCallable<{}, { coinsAwarded: number } & Record<string, unknown>>(
    getFns(),
    'chemcityCollectPassiveIncome',
  );
  const result = await fn({});
  return result.data;
}

export async function callChemCityDevGrantCoins(amount: number): Promise<void> {
  const fn = httpsCallable<{ amount: number }, { ok?: boolean }>(getFns(), 'chemcityDevGrantCoins');
  await fn({ amount });
}

export async function callChemCityGetDailyLoginBonus(): Promise<Record<string, unknown>> {
  const fn = httpsCallable(getFns(), 'chemcityGetDailyLoginBonus');
  const result = await fn({});
  return result.data as Record<string, unknown>;
}

export async function callChemCityPurchaseCard(itemId: string, currency: 'coins' | 'diamonds'): Promise<void> {
  const fn = httpsCallable<PurchaseCardRequest, { ok?: boolean }>(getFns(), 'chemcityPurchaseCard');
  await fn({ itemId, currency });
}

export async function callChemCityGachaDraw(req: GachaDrawRequest): Promise<GachaDrawResponse> {
  const fn = httpsCallable<GachaDrawRequest, GachaDrawResponse>(getFns(), 'chemcityGachaDraw');
  const result = await fn(req);
  return result.data;
}

export async function callChemCityPurchaseCosmetic(
  req: PurchaseCosmeticRequest,
): Promise<PurchaseCosmeticResponse> {
  const fn = httpsCallable<PurchaseCosmeticRequest, PurchaseCosmeticResponse>(
    getFns(),
    'chemcityPurchaseCosmetic',
  );
  const result = await fn(req);
  return result.data;
}

export async function callChemCityEquipCosmetics(
  req: EquipCosmeticsRequest,
): Promise<EquipCosmeticsResponse> {
  const fn = httpsCallable<EquipCosmeticsRequest, EquipCosmeticsResponse>(
    getFns(),
    'chemcityEquipCosmetics',
  );
  const result = await fn(req);
  return result.data;
}

export async function callChemCityBuyTickets(req: BuyTicketsRequest): Promise<BuyTicketsResponse> {
  const fn = httpsCallable<BuyTicketsRequest, BuyTicketsResponse>(getFns(), 'chemcityBuyTickets');
  const result = await fn(req);
  return result.data;
}

export async function callChemCityUnlockStoreSlot(): Promise<Record<string, unknown>> {
  const fn = httpsCallable(getFns(), 'chemcityUnlockStoreSlot');
  const result = await fn({});
  return result.data as Record<string, unknown>;
}

export async function callChemCityUnlockPlace(placeId: string): Promise<void> {
  const fn = httpsCallable<UnlockPlaceRequest, { ok?: boolean }>(getFns(), 'chemcityUnlockPlace');
  await fn({ placeId });
}

export async function callChemCityUnlockSlot(
  placeId: string,
  slotId: string,
  useExtraSlotBudget?: boolean,
): Promise<void> {
  const fn = httpsCallable<UnlockSlotRequest, { ok?: boolean }>(getFns(), 'chemcityUnlockSlot');
  await fn({ placeId, slotId, useExtraSlotBudget });
}

export async function callChemCityQuizReward(req: QuizRewardRequest): Promise<QuizRewardResult> {
  const fn = httpsCallable<QuizRewardRequest, QuizRewardResult>(getFns(), 'chemcityQuizReward');
  const result = await fn(req);
  return result.data;
}

export interface ClaimCollectionRewardResult {
  ok: boolean;
  coinsAwarded: number;
  diamondsAwarded: number;
}

export async function callChemCityClaimCollectionReward(
  collectionId: string,
): Promise<ClaimCollectionRewardResult> {
  const fn = httpsCallable<{ collectionId: string }, ClaimCollectionRewardResult>(
    getFns(),
    'chemcityClaimCollectionReward',
  );
  const result = await fn({ collectionId });
  return result.data;
}

// ─── Phase 4 aliases (used by the Phase 4 handoff code) ───────────────────────

export const callPurchaseCard = (req: PurchaseCardRequest) =>
  callChemCityPurchaseCard(req.itemId, req.currency).then(() => ({ success: true }));

export const callUnlockPlace = (req: UnlockPlaceRequest) =>
  callChemCityUnlockPlace(req.placeId).then(() => ({ success: true, coinsDeducted: 0 }));

export const callUnlockSlot = (req: UnlockSlotRequest) =>
  httpsCallable<UnlockSlotRequest, { ok?: boolean }>(getFns(), 'chemcityUnlockSlot')(req).then((r) => ({
    success: true,
    ...((r.data as any) ?? {}),
  }));

export const callUnlockStoreSlot = (_req: Record<string, never>) =>
  callChemCityUnlockStoreSlot().then((data: any) => ({
    success: true,
    newSlotCount: data?.newSlotCount ?? data?.storeSlotCount ?? 0,
    coinsDeducted: data?.coinsDeducted ?? data?.cost ?? 0,
  }));


===== FILE: src/lib/chemcity/types.ts =====

// ============================================================
// ChemCity — TypeScript Types
// Single source of truth for all data shapes.
// DO NOT change field names once users have data in Firestore.
// ============================================================

// ─── Item Documents ──────────────────────────────────────────

/**
 * Slim fields only — what is cached in localStorage.
 * ~170 bytes per card. Never includes educational content.
 */
export interface SlimItemDocument {
  id: string;                  // e.g. "item_nacl"
  baseId?: string;              // optional grouping key for item variants, e.g. "chem_h2o"
  name: string;                // e.g. "Salt"
  chemicalFormula: string;     // e.g. "NaCl" (Unicode subscripts)
  emoji: string;               // e.g. "🧂"
  imageUrl?: string;
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';
  rarityValue: 1 | 2 | 3 | 4;
  placeId: PlaceId;            // which city location this belongs to
  validSlots: string[];        // slot IDs within that place
  shopData: {
    coinCost?: number;         // undefined = not coin-purchasable
    diamondCost?: number;      // undefined = not diamond-purchasable
  };
  skillContribution: number;   // this card's bonus value added to its place's skill total
  collections: string[];       // collection group IDs only — not full objects
  deprecated: boolean;         // true = hidden from UI, never delete the row
}

/**
 * Full fields — fetched from Firestore on card detail tap only.
 * ~800 bytes per card. NEVER stored in localStorage.
 */
export interface FullItemDocument extends SlimItemDocument {
  displayName: string;         // e.g. "The Seasoning of Life"
  description: string;
  cardBackground?: string;     // CSS gradient or colour token
  imageUrl?: string;
  topicConnections: string[];  // topic IDs this card relates to
  educational: {
    funFact: string;
    everydayUses: string[];
    category: 'element' | 'compound' | 'mixture' | 'process';
  };
  albumMetadata: {
    flavorText: string;
    sortOrder: number;
    tags: string[];
  };
}

// ─── Places ──────────────────────────────────────────────────

export type PlaceId =
  | 'lab'
  | 'kitchen'
  | 'toilet'
  | 'garden'
  | 'gas_station'
  | 'lifestyle_boutique'
  | 'beach'
  | 'school';

export interface SlotDocument {
  slotId: string;
  unlockCost?: number;         // undefined = free by default
  unlockCurrency?: 'coins' | 'diamonds';
  budgetOnly?: boolean;        // if true, can only be unlocked via extraSlotsBudget
  equippedItemId?: string;     // null = empty
}

export interface PlaceDocument {
  id: PlaceId;
  displayName: string;
  emoji: string;
  unlockCost: number;          // coin cost to unlock the place itself
  slots: SlotDocument[];
  skill: {
    description: string;
    formula: string;           // human-readable formula string for display
  };
}

// ─── User Documents ──────────────────────────────────────────

/**
 * Main user document — users/{userId}
 * Kept lean: only IDs and numbers, never full objects.
 */
export interface UserChemCityData {
  userId: string;
  currencies: {
    coins: number;
    diamonds: number;
    tickets?: number;
  };
  storeSlotCount: number;
  ownedItems: string[];        // array of item IDs only
  ownedCosmetics?: string[];
  equipped: {
    [slotId: string]: string;  // slotId → itemId
  };
  equippedCosmetics?: {
    avatarId?: string;
    backgroundId?: string;
    iconId?: string;
  };
  gachaState?: {
    [bannerId: string]: {
      sinceEpic: number;
      sinceLegendary: number;
      lifetimePulls: number;
      updatedAt?: unknown;
    };
  };
  activeBonuses: ActiveBonuses;
  unlockedPlaces: PlaceId[];
  unlockedSlots: string[];     // slot IDs unlocked by the user
  extraSlotsBudget: number;    // remaining Gas Station bonus slots to distribute
  passiveIncome: {
    lastCollected: Date | null; // Firestore Timestamp — set by server
  };
  streaks: {
    currentStreak: number;
    longestStreak: number;
    lastLoginDate: string;     // ISO date string YYYY-MM-DD
    streakFreezeCount: number;
  };
  cacheVersion: number;        // last known version when user doc was written
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Progress sub-document — users/{userId}/progress/data
 * Separated to protect the 1MB Firestore doc limit.
 */
export interface UserProgressData {
  collections: {
    [collectionId: string]: {
      collected: number;
      total: number;
      completed: boolean;
      rewardClaimed: boolean;
    };
  };
  topicMastery: {
    [topicId: string]: {
      quizzesCompleted: number;
      correctAnswers: number;
      totalQuestions: number;
    };
  };
}

// ─── Bonus Engine ─────────────────────────────────────────────

/**
 * Computed bonuses — recalculated after every equip/unequip.
 * Persisted to user doc so they're available instantly on load.
 */
export interface ActiveBonuses {
  passiveBaseCoinsPerHour: number;      // Garden: total_bonus × 10
  passiveMultiplier: number;            // Lab:    1 + (total_bonus × 0.1)
  quizFlatDiamondBonus: number;         // Kitchen: total_bonus × random(1,3) — stored as max
  quizDiamondMultiplier: number;        // School: 1 + (total_bonus × 0.1)
  quizDoubleChancePercent: number;      // Beach:  min(total_bonus × 5, 100)
  dailyLoginDiamonds: number;           // Toilet: 5 + (total_bonus × 2)
  extraSlotsTotal: number;              // Gas Station: total_bonus
  shopDiscountPercent: number;          // Boutique: min(total_bonus × 2, 50) — capped at 50%
}

// ─── Cache ────────────────────────────────────────────────────

export interface CacheManifest {
  version: number;
  fetchedAt: number;           // Date.now() timestamp
  itemIds: string[];           // IDs of what's cached
}

// ─── Collections ─────────────────────────────────────────────

export interface CollectionDocument {
  id: string;
  displayName: string;
  description: string;
  itemIds: string[];
  rewardCoins?: number;
  rewardDiamonds?: number;
}

// ─── Topics ──────────────────────────────────────────────────

export interface TopicDocument {
  id: string;
  name: string;
  dseUnit: string;
  description?: string;
}

// ─── Cosmetics + Gacha ───────────────────────────────────────

export type CosmeticType = 'avatar' | 'background' | 'icon';

export type Rarity = 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';

export interface FaceCropMeta {
  x: number;
  y: number;
  w: number;
  h: number;
}

export interface CosmeticAvailability {
  channels: {
    gacha: boolean;
    shop: boolean;
  };
  eventKey?: string;
  startAt?: unknown;
  endAt?: unknown;
}

export interface CosmeticShopData {
  coinCost?: number;
  diamondCost?: number;
  ticketCost?: number;
}

export interface Cosmetic {
  id: string;
  type: CosmeticType;
  name: string;
  rarity: Rarity;
  imageUrl: string;
  imageUrlBoy?: string;
  imageUrlGirl?: string;
  availability: CosmeticAvailability;
  shopData?: CosmeticShopData;
  faceCrop?: FaceCropMeta;
  tags?: string[];
  deprecated?: boolean;
}

export type RarityRates = Record<Rarity, number>;

export type DuplicateRefunds = Record<Rarity, number>;

export interface PityRules {
  epicEvery: number;
  legendaryEvery: number;
}

export interface GachaBanner {
  id: string;
  name: string;
  description?: string;
  bannerImageUrl?: string;
  active: boolean;
  startAt?: unknown;
  endAt?: unknown;
  eventKey?: string;
  rarityRates: RarityRates;
  duplicateRefundCoinsByRarity: DuplicateRefunds;
  pityRules: PityRules;
  cacheVersion: number;
}

export interface GachaDrawRequest {
  bannerId: string;
  count: 1 | 10;
  payWith: 'tickets' | 'coins';
}

export interface GachaDrawResult {
  cosmeticId: string;
  rarity: Rarity;
  isNew: boolean;
  refundCoins: number;
  pitied: boolean;
}

export interface GachaDrawResponse {
  success: true;
  results: GachaDrawResult[];
  newBalance: {
    coins: number;
    diamonds: number;
    tickets: number;
  };
  newGachaState: {
    sinceEpic: number;
    sinceLegendary: number;
    lifetimePulls: number;
    updatedAt?: unknown;
  };
}

export interface PurchaseCosmeticRequest {
  cosmeticId: string;
  currency: 'coins' | 'diamonds' | 'tickets';
}

export interface PurchaseCosmeticResponse {
  success: true;
  cosmeticId: string;
  newBalance: {
    coins: number;
    diamonds: number;
    tickets: number;
  };
}

export interface EquipCosmeticsRequest {
  avatarId?: string;
  backgroundId?: string;
  iconId?: string;
}

export interface EquipCosmeticsResponse {
  success: true;
  equippedCosmetics: {
    avatarId?: string;
    backgroundId?: string;
    iconId?: string;
  };
}

export interface BuyTicketsRequest {
  count: number;
}

export interface BuyTicketsResponse {
  success: true;
  count: number;
  newBalance: {
    coins: number;
    diamonds: number;
    tickets: number;
  };
}

// ─── Cloud Function Request/Response Types ────────────────────

export interface EquipCardRequest {
  slotId: string;
  itemId: string;
}

export interface UnequipCardRequest {
  slotId: string;
}

export interface PurchaseCardRequest {
  itemId: string;
  currency: 'coins' | 'diamonds';
}

export interface UnlockPlaceRequest {
  placeId: string;
}

export interface UnlockSlotRequest {
  placeId: string;
  slotId: string;
  useExtraSlotBudget?: boolean;
}

export interface QuizRewardRequest {
  baseCoins: number;
  baseDiamonds: number;
  topicId?: string;
  correctAnswers?: number;
  totalQuestions?: number;
}

export interface QuizRewardResult {
  coinsAwarded: number;
  diamondsAwarded: number;
  didDouble?: boolean;
  breakdown?: {
    flatBonus: number;
    afterSchool: number;
    afterBeach: number;
  };
  ok?: boolean;
}


===== FILE: functions/chemcity/gacha.js =====

'use strict';

const admin = require('firebase-admin');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { randomInt } = require('crypto');

const RARITY_ORDER = ['common', 'uncommon', 'rare', 'epic', 'legendary'];

const DRAW_COST = { tickets: 1, coins: 500 };

const TICKET_EXCHANGE = { coinsPerTicket: 250 };

function nowIso() {
  return new Date().toISOString();
}

function invalid(msg) {
  throw new HttpsError('invalid-argument', msg);
}

function precondition(msg) {
  throw new HttpsError('failed-precondition', msg);
}

async function ensureChemCityGachaFields(db, uid) {
  const userRef = db.collection('users').doc(uid);
  const snap = await userRef.get();
  if (!snap.exists) {
    throw new HttpsError('not-found', 'User profile not found.');
  }
  const data = snap.data() || {};
  const chemcity = data.chemcity && typeof data.chemcity === 'object' ? data.chemcity : null;
  if (!chemcity) {
    // Let the main chemcity init flow create the chemcity root. We only merge gacha fields.
    // Existing codebase already provides chemcityInitUser/ensureChemCityInitialized.
    await userRef.set(
      {
        chemcity: {
          currencies: { tickets: 0 },
          ownedCosmetics: [],
          equippedCosmetics: {
            avatarId: 'avatar_1_plain',
            backgroundId: 'bg_1',
          },
          gachaState: {},
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        },
      },
      { merge: true },
    );
    return;
  }

  const currencies = chemcity.currencies && typeof chemcity.currencies === 'object' ? chemcity.currencies : {};

  const patch = {};

  if (typeof currencies.tickets !== 'number') {
    patch['chemcity.currencies.tickets'] = 0;
  }
  if (!Array.isArray(chemcity.ownedCosmetics)) {
    patch['chemcity.ownedCosmetics'] = [];
  }
  if (!chemcity.equippedCosmetics || typeof chemcity.equippedCosmetics !== 'object') {
    patch['chemcity.equippedCosmetics'] = {
      avatarId: 'avatar_1_plain',
      backgroundId: 'bg_1',
    };
  }
  if (!chemcity.gachaState || typeof chemcity.gachaState !== 'object') {
    patch['chemcity.gachaState'] = {};
  }

  if (Object.keys(patch).length > 0) {
    patch['chemcity.updatedAt'] = admin.firestore.FieldValue.serverTimestamp();
    await userRef.update(patch);
  }

  // Gift defaults: ensure user owns and has equipped the starter cosmetics.
  // (Only applies when fields already exist; safe for repeated calls.)
  try {
    const data2 = (await userRef.get()).data() || {};
    const cc2 = data2.chemcity && typeof data2.chemcity === 'object' ? data2.chemcity : {};
    const owned = Array.isArray(cc2.ownedCosmetics) ? cc2.ownedCosmetics : [];
    const equipped = cc2.equippedCosmetics && typeof cc2.equippedCosmetics === 'object' ? cc2.equippedCosmetics : {};

    const needOwned = !owned.includes('avatar_1_plain') || !owned.includes('bg_1');
    const needEquipped = !equipped.avatarId || !equipped.backgroundId;

    if (needOwned || needEquipped) {
      const nextOwned = owned.slice();
      if (!nextOwned.includes('avatar_1_plain')) nextOwned.push('avatar_1_plain');
      if (!nextOwned.includes('bg_1')) nextOwned.push('bg_1');
      await userRef.update({
        'chemcity.ownedCosmetics': nextOwned,
        'chemcity.equippedCosmetics': {
          avatarId: equipped.avatarId || 'avatar_1_plain',
          backgroundId: equipped.backgroundId || 'bg_1',
          ...(equipped.iconId ? { iconId: equipped.iconId } : {}),
        },
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });
    }
  } catch {
    // ignore
  }
}

function secureRandom() {
  return randomInt(0, 2 ** 32) / 2 ** 32;
}

async function loadActiveBanner(db, bannerId) {
  const snap = await db.collection('gachaBanners').doc(bannerId).get();
  if (!snap.exists) invalid(`Banner "${bannerId}" not found.`);
  const banner = { id: snap.id, ...(snap.data() || {}) };
  if (!banner.active) precondition('Banner is not active.');

  const now = new Date();
  if (banner.startAt) {
    const start = typeof banner.startAt?.toDate === 'function' ? banner.startAt.toDate() : new Date(banner.startAt);
    if (now < start) precondition('Banner has not started yet.');
  }
  if (banner.endAt) {
    const end = typeof banner.endAt?.toDate === 'function' ? banner.endAt.toDate() : new Date(banner.endAt);
    if (now > end) precondition('Banner has ended.');
  }
  return banner;
}

async function loadCompiledPool(db, bannerId) {
  const snap = await db
    .collection('gachaBanners')
    .doc(bannerId)
    .collection('entries')
    .where('enabled', '==', true)
    .get();

  if (snap.empty) invalid('Banner has no enabled entries.');

  const byRarity = {};
  snap.docs.forEach((d) => {
    const entry = { cosmeticId: d.id, ...(d.data() || {}) };
    if (!entry.rarity) return;
    if (!byRarity[entry.rarity]) byRarity[entry.rarity] = [];
    byRarity[entry.rarity].push({ cosmeticId: entry.cosmeticId, weight: Number(entry.weight || 1) });
  });

  const compiled = {};
  for (const [rarity, entries] of Object.entries(byRarity)) {
    let total = 0;
    const items = entries.map((e) => {
      total += e.weight;
      return { cosmeticId: e.cosmeticId, cumulativeWeight: total };
    });
    compiled[rarity] = { items, totalWeight: total };
  }
  return compiled;
}

function selectRarity(rarityRates, pityRules, pityState) {
  const sinceEpic = Number(pityState?.sinceEpic || 0);
  const sinceLegendary = Number(pityState?.sinceLegendary || 0);
  const epicEvery = Number(pityRules?.epicEvery || 20);
  const legendaryEvery = Number(pityRules?.legendaryEvery || 40);

  if (sinceLegendary >= legendaryEvery - 1) {
    return { rarity: 'legendary', pitied: true };
  }

  if (sinceEpic >= epicEvery - 1) {
    const roll = secureRandom();
    const epicRate = Number(rarityRates?.epic ?? 0.05);
    const legRate = Number(rarityRates?.legendary ?? 0.02);
    const total = epicRate + legRate;
    if (!(total > 0)) return { rarity: 'epic', pitied: true };
    return { rarity: roll < legRate / total ? 'legendary' : 'epic', pitied: true };
  }

  const roll = secureRandom();
  let cumulative = 0;
  for (const rarity of [...RARITY_ORDER].reverse()) {
    cumulative += Number(rarityRates?.[rarity] ?? 0);
    if (roll <= cumulative) return { rarity, pitied: false };
  }
  return { rarity: 'common', pitied: false };
}

function selectCosmetic(compiledPool, rarity) {
  const rarityIndex = RARITY_ORDER.indexOf(rarity);

  for (let i = rarityIndex; i >= 0; i--) {
    const r = RARITY_ORDER[i];
    const pool = compiledPool[r];
    if (!pool || pool.totalWeight <= 0) continue;

    const roll = secureRandom() * pool.totalWeight;
    const entry = pool.items.find((e) => e.cumulativeWeight >= roll);
    return entry ? entry.cosmeticId : pool.items[pool.items.length - 1].cosmeticId;
  }

  for (const r of [...RARITY_ORDER].reverse()) {
    const pool = compiledPool[r];
    if (pool && pool.items?.length > 0) return pool.items[0].cosmeticId;
  }

  throw new HttpsError('internal', 'No cosmetics available in pool.');
}

function updatePity(currentState, rarity) {
  let sinceEpic = Number(currentState?.sinceEpic || 0);
  let sinceLegendary = Number(currentState?.sinceLegendary || 0);
  let lifetimePulls = Number(currentState?.lifetimePulls || 0);

  lifetimePulls += 1;

  if (rarity === 'legendary') {
    sinceEpic = 0;
    sinceLegendary = 0;
  } else if (rarity === 'epic') {
    sinceEpic = 0;
    sinceLegendary += 1;
  } else {
    sinceEpic += 1;
    sinceLegendary += 1;
  }

  return { sinceEpic, sinceLegendary, lifetimePulls, updatedAt: nowIso() };
}

exports.chemcityGachaDraw = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const bannerId = request.data?.bannerId;
    const count = request.data?.count;
    const payWith = request.data?.payWith;

    if (typeof bannerId !== 'string' || !bannerId) invalid('bannerId is required.');
    if (count !== 1 && count !== 10) invalid('count must be 1 or 10.');
    if (payWith !== 'tickets' && payWith !== 'coins') invalid('payWith must be "tickets" or "coins".');

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const [banner, compiledPool] = await Promise.all([
      loadActiveBanner(db, bannerId),
      loadCompiledPool(db, bannerId),
    ]);

    const totalCost = payWith === 'tickets' ? DRAW_COST.tickets * count : DRAW_COST.coins * count;

    const userRef = db.collection('users').doc(uid);

    let resultsOut = [];
    let newBalanceOut = null;
    let newGachaStateOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);
      const tickets = Number(currencies.tickets || 0);

      const ownedCosmeticsArr = Array.isArray(chemcity.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
      const ownedCosmetics = new Set(ownedCosmeticsArr);

      const gachaState = chemcity.gachaState && typeof chemcity.gachaState === 'object' ? chemcity.gachaState : {};
      const pityBefore = gachaState[bannerId] && typeof gachaState[bannerId] === 'object'
        ? gachaState[bannerId]
        : { sinceEpic: 0, sinceLegendary: 0, lifetimePulls: 0, updatedAt: nowIso() };

      if (payWith === 'tickets' && tickets < totalCost) {
        precondition(`Not enough tickets. Need ${totalCost}, have ${tickets}.`);
      }
      if (payWith === 'coins' && coins < totalCost) {
        precondition(`Not enough coins. Need ${totalCost}, have ${coins}.`);
      }

      let pity = { ...pityBefore };
      let coinRefundTotal = 0;
      const results = [];
      const rollTrace = [];

      for (let i = 0; i < count; i++) {
        const { rarity, pitied } = selectRarity(banner.rarityRates, banner.pityRules, pity);
        const cosmeticId = selectCosmetic(compiledPool, rarity);

        const isNew = !ownedCosmetics.has(cosmeticId);
        let refundCoins = 0;

        if (isNew) {
          ownedCosmetics.add(cosmeticId);
        } else {
          refundCoins = Number(banner.duplicateRefundCoinsByRarity?.[rarity] || 0);
          if (!Number.isFinite(refundCoins) || refundCoins < 0) refundCoins = 0;
          coinRefundTotal += refundCoins;
        }

        pity = updatePity(pity, rarity);

        results.push({ cosmeticId, rarity, isNew, refundCoins, pitied });
        rollTrace.push({ i, cosmeticId, rarity, pitied, isNew, refundCoins });
      }

      // 10-pull guarantee: ensure at least one Rare+ result.
      if (count === 10) {
        const hasRarePlus = results.some((r) => ['rare', 'epic', 'legendary'].includes(r.rarity));
        if (!hasRarePlus) {
          // Upgrade the last pull to Rare (no pity flag), and reroll cosmetic from the Rare pool.
          const upgradedCosmeticId = selectCosmetic(compiledPool, 'rare');
          const old = results[9];
          const wasNew = !ownedCosmetics.has(upgradedCosmeticId);
          let refundCoins = 0;

          if (wasNew) {
            ownedCosmetics.add(upgradedCosmeticId);
          } else {
            refundCoins = Number(banner.duplicateRefundCoinsByRarity?.['rare'] || 0);
            if (!Number.isFinite(refundCoins) || refundCoins < 0) refundCoins = 0;
          }

          // If we replaced a duplicate that previously refunded coins, remove that previous refund.
          if (!old.isNew && Number.isFinite(Number(old.refundCoins))) {
            coinRefundTotal -= Number(old.refundCoins || 0);
          }
          coinRefundTotal += refundCoins;

          results[9] = {
            cosmeticId: upgradedCosmeticId,
            rarity: 'rare',
            isNew: wasNew,
            refundCoins,
            pitied: false,
          };
          rollTrace.push({
            i: 9,
            cosmeticId: upgradedCosmeticId,
            rarity: 'rare',
            pitied: false,
            isNew: wasNew,
            refundCoins,
            guaranteed: true,
          });
        }
      }

      const nextCoins = payWith === 'coins'
        ? coins - totalCost + coinRefundTotal
        : coins + coinRefundTotal;
      const nextTickets = payWith === 'tickets' ? tickets - totalCost : tickets;

      const updatedCurrencies = {
        coins: nextCoins,
        diamonds,
        tickets: nextTickets,
      };

      const updatedOwnedCosmetics = Array.from(ownedCosmetics);
      const updatedGachaState = { ...gachaState, [bannerId]: pity };

      tx.update(userRef, {
        'chemcity.currencies': updatedCurrencies,
        'chemcity.ownedCosmetics': updatedOwnedCosmetics,
        'chemcity.gachaState': updatedGachaState,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      const drawLogRef = userRef.collection('chemcity_gacha_draws').doc();
      tx.set(drawLogRef, {
        bannerId,
        count,
        payWith,
        totalCost,
        coinRefundTotal,
        results: rollTrace,
        currenciesBefore: { coins, diamonds, tickets },
        currenciesAfter: updatedCurrencies,
        pityBefore,
        pityAfter: pity,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      resultsOut = results;
      newBalanceOut = updatedCurrencies;
      newGachaStateOut = pity;
    });

    return {
      success: true,
      results: resultsOut,
      newBalance: newBalanceOut,
      newGachaState: newGachaStateOut,
    };
  },
);

exports.chemcityPurchaseCosmetic = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const cosmeticId = request.data?.cosmeticId;
    const currency = request.data?.currency;

    if (typeof cosmeticId !== 'string' || !cosmeticId) invalid('cosmeticId is required.');
    if (currency !== 'coins' && currency !== 'diamonds' && currency !== 'tickets') {
      invalid('currency must be coins, diamonds, or tickets.');
    }

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const cosmeticSnap = await db.collection('cosmetics').doc(cosmeticId).get();
    if (!cosmeticSnap.exists) invalid(`Cosmetic "${cosmeticId}" not found.`);
    const cosmetic = cosmeticSnap.data() || {};

    if (cosmetic.deprecated === true) precondition('Cosmetic is no longer available.');
    if (!(cosmetic.availability?.channels?.shop === true)) {
      precondition('This cosmetic is not available in the shop.');
    }

    const now = new Date();
    if (cosmetic.availability?.startAt) {
      const start = typeof cosmetic.availability.startAt?.toDate === 'function'
        ? cosmetic.availability.startAt.toDate()
        : new Date(cosmetic.availability.startAt);
      if (now < start) precondition('Cosmetic is not yet available.');
    }
    if (cosmetic.availability?.endAt) {
      const end = typeof cosmetic.availability.endAt?.toDate === 'function'
        ? cosmetic.availability.endAt.toDate()
        : new Date(cosmetic.availability.endAt);
      if (now > end) precondition('Cosmetic is no longer available.');
    }

    const shopData = cosmetic.shopData && typeof cosmetic.shopData === 'object' ? cosmetic.shopData : {};
    const costField = currency === 'coins'
      ? 'coinCost'
      : currency === 'diamonds'
        ? 'diamondCost'
        : 'ticketCost';

    const cost = Number(shopData[costField] || 0);
    if (!Number.isFinite(cost) || cost <= 0) {
      precondition(`This cosmetic cannot be purchased with ${currency}.`);
    }

    const userRef = db.collection('users').doc(uid);

    let newBalanceOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);
      const tickets = Number(currencies.tickets || 0);

      const owned = Array.isArray(chemcity.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
      if (owned.includes(cosmeticId)) precondition('You already own this cosmetic.');

      const balance = currency === 'coins' ? coins : currency === 'diamonds' ? diamonds : tickets;
      if (balance < cost) precondition(`Not enough ${currency}. Need ${cost}, have ${balance}.`);

      const updatedCurrencies = {
        coins: currency === 'coins' ? coins - cost : coins,
        diamonds: currency === 'diamonds' ? diamonds - cost : diamonds,
        tickets: currency === 'tickets' ? tickets - cost : tickets,
      };

      tx.update(userRef, {
        'chemcity.currencies': updatedCurrencies,
        'chemcity.ownedCosmetics': admin.firestore.FieldValue.arrayUnion(cosmeticId),
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      const purchaseRef = userRef.collection('chemcity_purchases').doc();
      tx.set(purchaseRef, {
        cosmeticId,
        currency,
        cost,
        currenciesBefore: { coins, diamonds, tickets },
        currenciesAfter: updatedCurrencies,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      newBalanceOut = updatedCurrencies;
    });

    return {
      success: true,
      cosmeticId,
      newBalance: newBalanceOut,
    };
  },
);

exports.chemcityEquipCosmetics = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const avatarId = request.data?.avatarId;
    const backgroundId = request.data?.backgroundId;
    const iconId = request.data?.iconId;

    if (!avatarId && !backgroundId && !iconId) {
      invalid('Provide at least one of avatarId, backgroundId, or iconId.');
    }

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const userRef = db.collection('users').doc(uid);

    let updatedEquippedOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const owned = Array.isArray(chemcity.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
      const ownedSet = new Set(owned);

      if (typeof avatarId === 'string' && avatarId && !ownedSet.has(avatarId)) {
        precondition(`You do not own avatar "${avatarId}".`);
      }
      if (typeof backgroundId === 'string' && backgroundId && !ownedSet.has(backgroundId)) {
        precondition(`You do not own background "${backgroundId}".`);
      }
      if (typeof iconId === 'string' && iconId && !ownedSet.has(iconId)) {
        precondition(`You do not own icon "${iconId}".`);
      }

      const currentEquipped = chemcity.equippedCosmetics && typeof chemcity.equippedCosmetics === 'object'
        ? chemcity.equippedCosmetics
        : {};

      const updatedEquipped = {
        ...currentEquipped,
        ...(avatarId !== undefined ? { avatarId } : null),
        ...(backgroundId !== undefined ? { backgroundId } : null),
        ...(iconId !== undefined ? { iconId } : null),
      };

      tx.update(userRef, {
        'chemcity.equippedCosmetics': updatedEquipped,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      updatedEquippedOut = updatedEquipped;
    });

    return {
      success: true,
      equippedCosmetics: updatedEquippedOut,
    };
  },
);

exports.chemcityBuyTickets = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const count = request.data?.count;
    if (!Number.isFinite(Number(count)) || Number(count) <= 0) invalid('count must be a positive number.');
    const ticketCount = Math.floor(Number(count));
    if (ticketCount <= 0) invalid('count must be a positive integer.');

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const userRef = db.collection('users').doc(uid);

    let newBalanceOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};
      const currencies = chemcity.currencies || {};

      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);
      const tickets = Number(currencies.tickets || 0);

      const totalCost = TICKET_EXCHANGE.coinsPerTicket * ticketCount;
      if (coins < totalCost) precondition(`Not enough coins. Need ${totalCost}, have ${coins}.`);

      const updatedCurrencies = {
        coins: coins - totalCost,
        diamonds,
        tickets: tickets + ticketCount,
      };

      tx.update(userRef, {
        'chemcity.currencies': updatedCurrencies,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      const purchaseRef = userRef.collection('chemcity_purchases').doc();
      tx.set(purchaseRef, {
        type: 'tickets',
        ticketCount,
        currency: 'coins',
        cost: totalCost,
        currenciesBefore: { coins, diamonds, tickets },
        currenciesAfter: updatedCurrencies,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      newBalanceOut = updatedCurrencies;
    });

    return {
      success: true,
      count: ticketCount,
      newBalance: newBalanceOut,
    };
  },
);


===== FILE: functions/index.js =====

const admin = require('firebase-admin');
const { onSchedule } = require('firebase-functions/v2/scheduler');
const { onDocumentCreated, onDocumentUpdated, onDocumentDeleted } = require('firebase-functions/v2/firestore');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const algoliasearch = require('algoliasearch');

admin.initializeApp();

Object.assign(exports, require('./chemcity/gacha'));

function getChemCityDefaults(userId) {
  const now = admin.firestore.FieldValue.serverTimestamp();
  return {
    userId,
    currencies: {
      coins: 500,
      diamonds: 20,
    },
    storeSlotCount: 3,
    ownedItems: [],
    ownedCosmetics: ['avatar_1_plain', 'bg_1'],
    equipped: {},
    equippedCosmetics: {
      avatarId: 'avatar_1_plain',
      backgroundId: 'bg_1',
    },
    activeBonuses: {
      passiveBaseCoinsPerHour: 0,
      passiveMultiplier: 1,
      quizFlatDiamondBonus: 0,
      quizDiamondMultiplier: 1,
      quizDoubleChancePercent: 0,
      dailyLoginDiamonds: 5,
      extraSlotsTotal: 0,
      shopDiscountPercent: 0,
    },
    unlockedPlaces: ['lab'],
    unlockedSlots: [],
    extraSlotsBudget: 0,
    passiveIncome: {
      lastCollected: null,
    },
    streaks: {
      currentStreak: 0,
      longestStreak: 0,
      lastLoginDate: '',
      streakFreezeCount: 0,
    },
    cacheVersion: 0,
    createdAt: now,
    updatedAt: now,
  };
}

async function ensureChemCityInitialized(db, userId) {
  const userRef = db.collection('users').doc(userId);
  const snap = await userRef.get();
  if (!snap.exists) {
    throw new HttpsError('not-found', 'User profile not found.');
  }
  const userData = snap.data() || {};
  if (userData.chemcity && typeof userData.chemcity === 'object') {
    // Backfill starter cosmetics if missing (non-destructive).
    const cc = userData.chemcity;
    const patch = {};

    const owned = Array.isArray(cc.ownedCosmetics) ? cc.ownedCosmetics : null;
    if (!owned) {
      patch['chemcity.ownedCosmetics'] = ['avatar_1_plain', 'bg_1'];
    } else {
      const nextOwned = owned.slice();
      if (!nextOwned.includes('avatar_1_plain')) nextOwned.push('avatar_1_plain');
      if (!nextOwned.includes('bg_1')) nextOwned.push('bg_1');
      if (nextOwned.length !== owned.length) patch['chemcity.ownedCosmetics'] = nextOwned;
    }

    const equipped = cc.equippedCosmetics && typeof cc.equippedCosmetics === 'object' ? cc.equippedCosmetics : null;
    if (!equipped) {
      patch['chemcity.equippedCosmetics'] = { avatarId: 'avatar_1_plain', backgroundId: 'bg_1' };
    } else {
      if (!equipped.avatarId || !equipped.backgroundId) {
        patch['chemcity.equippedCosmetics'] = {
          avatarId: equipped.avatarId || 'avatar_1_plain',
          backgroundId: equipped.backgroundId || 'bg_1',
          ...(equipped.iconId ? { iconId: equipped.iconId } : {}),
        };
      }
    }

    if (Object.keys(patch).length > 0) {
      patch['chemcity.updatedAt'] = admin.firestore.FieldValue.serverTimestamp();
      await userRef.update(patch);
    }
    return;
  }

  const chemcity = getChemCityDefaults(userId);
  const progressRef = userRef.collection('chemcity_progress').doc('data');
  const batch = db.batch();
  batch.set(userRef, { chemcity }, { merge: true });
  batch.set(progressRef, { collections: {}, topicMastery: {} }, { merge: true });
  await batch.commit();
}

function calcGardenCoinsPerHour(totalBonus) {
  return totalBonus * 10;
}

function calcLabMultiplier(totalBonus) {
  return 1 + totalBonus * 0.1;
}

function calcKitchenMaxDiamonds(totalBonus) {
  return totalBonus * 3;
}

function calcSchoolMultiplier(totalBonus) {
  return 1 + totalBonus * 0.1;
}

function calcBeachDoubleChance(totalBonus) {
  return Math.min(totalBonus * 5, 100);
}

function calcToiletLoginDiamonds(totalBonus) {
  return 5 + totalBonus * 2;
}

function calcGasStationExtraSlots(totalBonus) {
  return totalBonus;
}

function calcBoutiqueDiscount(totalBonus) {
  return Math.min(totalBonus * 2, 50);
}

function getTodayUtcDateKey() {
  const d = new Date();
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth() + 1).padStart(2, '0');
  const day = String(d.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

function rollKitchenBonusFromMax(maxBonus) {
  const max = Number(maxBonus || 0);
  if (!Number.isFinite(max) || max <= 0) return 0;
  const totalBonus = Math.floor(max / 3);
  if (totalBonus <= 0) return 0;
  const min = totalBonus;
  const mx = totalBonus * 3;
  return Math.floor(Math.random() * (mx - min + 1)) + min;
}

function rollBeachDoubleFromPercent(percent) {
  const p = Number(percent || 0);
  if (!Number.isFinite(p) || p <= 0) return false;
  return Math.random() * 100 < Math.min(p, 100);
}

function getDiscountedCoinCost(baseCost, shopDiscountPercent) {
  const cost = Number(baseCost);
  if (!Number.isFinite(cost) || cost <= 0) return 0;
  const disc = Number(shopDiscountPercent || 0);
  if (!Number.isFinite(disc) || disc <= 0) return cost;
  const factor = 1 - Math.min(disc, 50) / 100;
  return Math.max(1, Math.floor(cost * factor));
}

const STORE_SLOT_UNLOCK_COSTS = {
  4: 1000,
  5: 2500,
  6: 5000,
};

async function computeChemCityActiveBonuses(db, equipped) {
  const itemIds = Object.values(equipped || {}).filter((x) => typeof x === 'string' && x.length > 0);
  const uniqueIds = Array.from(new Set(itemIds));

  const totals = {};
  if (uniqueIds.length > 0) {
    const refs = uniqueIds.map((id) => db.collection('items').doc(id));
    const snaps = await db.getAll(...refs);

    const itemMap = new Map();
    snaps.forEach((s) => {
      if (s.exists) itemMap.set(s.id, s.data() || {});
    });

    for (const id of itemIds) {
      const item = itemMap.get(id);
      if (!item || item.deprecated) continue;
      const placeId = String(item.placeId || '');
      const contrib = Number(item.skillContribution || 0);
      if (!placeId || !Number.isFinite(contrib)) continue;
      totals[placeId] = (totals[placeId] || 0) + contrib;
    }
  }

  const gardenBonus = totals.garden || 0;
  const labBonus = totals.lab || 0;
  const kitchenBonus = totals.kitchen || 0;
  const schoolBonus = totals.school || 0;
  const beachBonus = totals.beach || 0;
  const toiletBonus = totals.toilet || 0;
  const gasStationBonus = totals.gas_station || 0;
  const boutiqueBonus = totals.lifestyle_boutique || 0;

  const gardenBase = calcGardenCoinsPerHour(gardenBonus);
  const labMult = calcLabMultiplier(labBonus);

  return {
    passiveBaseCoinsPerHour: Math.round(gardenBase * labMult),
    passiveMultiplier: labMult,
    quizFlatDiamondBonus: calcKitchenMaxDiamonds(kitchenBonus),
    quizDiamondMultiplier: calcSchoolMultiplier(schoolBonus),
    quizDoubleChancePercent: calcBeachDoubleChance(beachBonus),
    dailyLoginDiamonds: calcToiletLoginDiamonds(toiletBonus),
    extraSlotsTotal: calcGasStationExtraSlots(gasStationBonus),
    shopDiscountPercent: calcBoutiqueDiscount(boutiqueBonus),
  };
}

function encodeKey(value) {
  const s = value == null ? '' : String(value);
  return encodeURIComponent(s);
}

function safeString(value) {
  return value == null ? '' : String(value);
}

function decodeKey(value) {
  const s = value == null ? '' : String(value);
  try {
    return decodeURIComponent(s);
  } catch {
    return s;
  }
}

function normalizeBucket(value) {
  const v = value == null ? '' : String(value);
  if (v === 'not_in_srs' || v === 'new' || v === 'progressing' || v === 'near' || v === 'archived') return v;
  return 'not_in_srs';
}

function getTopicFromMistake(m) {
  if (!m || typeof m !== 'object') return '';
  return safeString(m.Topic || m.topic || '');
}

function getBucketFromMistake(m) {
  if (!m || typeof m !== 'object') return 'not_in_srs';
  return normalizeBucket(m.srsBucket || 'not_in_srs');
}

function getIsActiveFromMistake(m) {
  if (!m || typeof m !== 'object') return false;
  return m.srsIsActive === true;
}

async function applyMistakeTopicStatsDelta(db, userId, delta, topic, bucket, isActive) {
  const uid = safeString(userId);
  const d = Number(delta);
  if (!uid || !Number.isFinite(d) || d === 0) return;

  const topicEnc = encodeKey(topic || '');
  if (!topicEnc) return;

  const b = normalizeBucket(bucket);
  const active = isActive === true;

  const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(statsRef);
    const prev = snap.exists ? (snap.data() || {}) : {};
    const prevTopics = prev.topics && typeof prev.topics === 'object' ? prev.topics : {};
    const prevEntry = prevTopics[topicEnc] && typeof prevTopics[topicEnc] === 'object' ? prevTopics[topicEnc] : {};

    const nextTopics = { ...prevTopics };
    const nextEntry = { ...prevEntry };

    const prevTotal = Number(nextEntry.total || 0);
    const nextTotal = Math.max(0, prevTotal + d);
    nextEntry.total = nextTotal;

    const bucketKey = `b_${b}`;
    const prevBucket = Number(nextEntry[bucketKey] || 0);
    const nextBucket = Math.max(0, prevBucket + d);
    if (nextBucket === 0) delete nextEntry[bucketKey];
    else nextEntry[bucketKey] = nextBucket;

    if (active) {
      const prevActive = Number(nextEntry.active || 0);
      const nextActive = Math.max(0, prevActive + d);
      nextEntry.active = nextActive;
    }

    // Prune empty
    if (nextEntry.total === 0) {
      delete nextTopics[topicEnc];
    } else {
      nextEntry.updatedAt = admin.firestore.FieldValue.serverTimestamp();
      nextTopics[topicEnc] = nextEntry;
    }

    tx.set(statsRef, {
      topics: nextTopics,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });
  });
}

async function applySrsAttemptDelta(db, userId, attemptedAtIso, deltaCorrect, statusBefore) {
  const uid = safeString(userId);
  const iso = safeString(attemptedAtIso);
  if (!uid || !iso) return;

  const dateKey = iso.slice(0, 10);
  if (!dateKey) return;

  const summaryRef = db.collection('users').doc(uid).collection('srs_daily_summaries').doc(dateKey);
  const dCorrect = Number.isFinite(deltaCorrect) ? deltaCorrect : 0;

  const normalizeStatus = (s) => {
    const v = safeString(s);
    if (v === 'new') return 'new';
    if (v === 'learning') return 'learning';
    if (v === 'review') return 'review';
    if (v === 'graduated') return 'graduated';
    return '';
  };

  const bucket = normalizeStatus(statusBefore);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(summaryRef);
    const prev = snap.exists ? (snap.data() || {}) : {};
    const next = { ...prev };

    next.date = dateKey;
    next.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    if (dCorrect !== 0) {
      const old = Number(prev.clearedCorrect || 0);
      next.clearedCorrect = Math.max(0, old + dCorrect);
    }

    if (bucket) {
      const field = bucket === 'new' ? 'statusNew'
        : bucket === 'learning' ? 'statusLearning'
        : bucket === 'review' ? 'statusReview'
        : 'statusGraduated';
      const old = Number(prev[field] || 0);
      next[field] = Math.max(0, old + 1);
    }

    tx.set(summaryRef, next, { merge: true });
  });
}

async function applyMistakeDocDelta(db, userId, before, after) {
  const beforeExists = before && typeof before === 'object' && Object.keys(before).length > 0;
  const afterExists = after && typeof after === 'object' && Object.keys(after).length > 0;

  if (!beforeExists && !afterExists) return;

  // Create
  if (!beforeExists && afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      1,
      getTopicFromMistake(after),
      getBucketFromMistake(after),
      getIsActiveFromMistake(after)
    );
    return;
  }

  // Delete
  if (beforeExists && !afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      -1,
      getTopicFromMistake(before),
      getBucketFromMistake(before),
      getIsActiveFromMistake(before)
    );
    return;
  }

  const beforeTopic = getTopicFromMistake(before);
  const afterTopic = getTopicFromMistake(after);
  const beforeBucket = getBucketFromMistake(before);
  const afterBucket = getBucketFromMistake(after);
  const beforeActive = getIsActiveFromMistake(before);
  const afterActive = getIsActiveFromMistake(after);

  const changed =
    beforeTopic !== afterTopic ||
    beforeBucket !== afterBucket ||
    beforeActive !== afterActive;

  if (!changed) return;

  // Remove old
  await applyMistakeTopicStatsDelta(db, userId, -1, beforeTopic, beforeBucket, beforeActive);
  // Add new
  await applyMistakeTopicStatsDelta(db, userId, 1, afterTopic, afterBucket, afterActive);
}

// Maintain mistake topic stats for global sidebar facets
exports.updateMistakeTopicStatsOnCreate = onDocumentCreated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const after = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, null, after);
  }
);

exports.chemcityUnlockStoreSlot = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const current = Number(chemcity.storeSlotCount || 3);
      if (!Number.isFinite(current) || current < 3) {
        throw new HttpsError('failed-precondition', 'Invalid storeSlotCount.');
      }
      if (current >= 6) {
        throw new HttpsError('failed-precondition', 'All store slots already unlocked.');
      }

      const next = current + 1;
      const cost = STORE_SLOT_UNLOCK_COSTS[next];
      if (!Number.isFinite(cost) || cost <= 0) {
        throw new HttpsError('failed-precondition', 'Invalid store slot unlock cost.');
      }

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      if (coins < cost) {
        throw new HttpsError('failed-precondition', 'Insufficient coins.');
      }

      tx.update(userRef, {
        'chemcity.currencies.coins': coins - cost,
        'chemcity.storeSlotCount': next,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, newSlotCount: next, coinsDeducted: cost };
    });
  }
);

exports.chemcityDevGrantCoins = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const amount = request.data?.amount;
    if (typeof amount !== 'number' || !Number.isFinite(amount) || amount === 0) {
      throw new HttpsError('invalid-argument', 'amount must be a non-zero number.');
    }

    const delta = Math.floor(amount);
    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    await db.runTransaction(async (tx) => {
      const snap = await tx.get(userRef);
      if (!snap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      tx.update(userRef, {
        'chemcity.currencies.coins': admin.firestore.FieldValue.increment(delta),
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });
    });

    return { ok: true, amount: delta };
  }
);

exports.chemcityClaimCollectionReward = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const collectionId = request.data?.collectionId;
    if (typeof collectionId !== 'string' || !collectionId) {
      throw new HttpsError('invalid-argument', 'collectionId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const progressRef = userRef.collection('chemcity_progress').doc('data');
    const colRef = db.collection('collections').doc(collectionId);

    return db.runTransaction(async (tx) => {
      const [userSnap, progressSnap, colSnap] = await Promise.all([
        tx.get(userRef),
        tx.get(progressRef),
        tx.get(colRef),
      ]);

      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      if (!colSnap.exists) {
        throw new HttpsError('not-found', `Collection '${collectionId}' not found.`);
      }

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const ownedItems = Array.isArray(chemcity.ownedItems) ? chemcity.ownedItems : [];
      const ownedSet = new Set(ownedItems.map(String));

      const colData = colSnap.data() || {};
      const itemIds = Array.isArray(colData.itemIds) ? colData.itemIds.map(String) : [];
      const rewardCoins = Number(colData.rewardCoins || 0);
      const rewardDiamonds = Number(colData.rewardDiamonds || 0);

      if (itemIds.length === 0) {
        throw new HttpsError('failed-precondition', 'Collection has no items.');
      }

      const allOwned = itemIds.every((id) => ownedSet.has(id));
      if (!allOwned) {
        throw new HttpsError('failed-precondition', 'You have not collected all items in this collection.');
      }

      const progress = progressSnap.exists ? (progressSnap.data() || {}) : {};
      const collectionsProgress = progress.collections && typeof progress.collections === 'object'
        ? progress.collections
        : {};
      const prevColProgress = collectionsProgress[collectionId] && typeof collectionsProgress[collectionId] === 'object'
        ? collectionsProgress[collectionId]
        : {};

      if (prevColProgress.rewardClaimed === true) {
        throw new HttpsError('already-exists', 'Reward for this collection has already been claimed.');
      }

      const update = {
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      };
      if (rewardCoins > 0) {
        update['chemcity.currencies.coins'] = admin.firestore.FieldValue.increment(rewardCoins);
      }
      if (rewardDiamonds > 0) {
        update['chemcity.currencies.diamonds'] = admin.firestore.FieldValue.increment(rewardDiamonds);
      }

      tx.update(userRef, update);

      tx.set(
        progressRef,
        {
          collections: {
            [collectionId]: {
              collected: itemIds.length,
              total: itemIds.length,
              completed: true,
              rewardClaimed: true,
              claimedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          },
        },
        { merge: true },
      );

      return {
        ok: true,
        coinsAwarded: Math.max(0, Math.floor(rewardCoins)),
        diamondsAwarded: Math.max(0, Math.floor(rewardDiamonds)),
      };
    });
  },
);

exports.chemcityPurchaseCard = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const itemId = request.data?.itemId;
    const currency = request.data?.currency;
    if (typeof itemId !== 'string' || !itemId) {
      throw new HttpsError('invalid-argument', 'itemId must be a non-empty string.');
    }
    if (currency !== 'coins' && currency !== 'diamonds') {
      throw new HttpsError('invalid-argument', 'currency must be "coins" or "diamonds".');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const itemRef = db.collection('items').doc(itemId);

    const itemSnap = await itemRef.get();
    if (!itemSnap.exists) {
      throw new HttpsError('not-found', 'Item not found.');
    }
    const item = itemSnap.data() || {};
    if (item.deprecated === true) {
      throw new HttpsError('failed-precondition', 'Item is deprecated.');
    }

    const shopData = item.shopData && typeof item.shopData === 'object' ? item.shopData : {};
    const baseCoinCost = shopData.coinCost;
    const baseDiamondCost = shopData.diamondCost;

    if (currency === 'coins' && !(Number.isFinite(Number(baseCoinCost)) && Number(baseCoinCost) > 0)) {
      throw new HttpsError('failed-precondition', 'Item is not purchasable with coins.');
    }
    if (currency === 'diamonds' && !(Number.isFinite(Number(baseDiamondCost)) && Number(baseDiamondCost) > 0)) {
      throw new HttpsError('failed-precondition', 'Item is not purchasable with diamonds.');
    }

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const owned = Array.isArray(chemcity.ownedItems) ? chemcity.ownedItems : [];
      if (owned.includes(itemId)) {
        throw new HttpsError('already-exists', 'Item already owned.');
      }

      const bonuses = chemcity.activeBonuses || {};
      const discountPercent = Number(bonuses.shopDiscountPercent || 0);

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);

      const effectiveCoinCost = currency === 'coins'
        ? getDiscountedCoinCost(baseCoinCost, discountPercent)
        : 0;
      const effectiveDiamondCost = currency === 'diamonds'
        ? Number(baseDiamondCost)
        : 0;

      if (currency === 'coins') {
        if (!Number.isFinite(effectiveCoinCost) || effectiveCoinCost <= 0) {
          throw new HttpsError('failed-precondition', 'Invalid coin cost.');
        }
        if (coins < effectiveCoinCost) {
          throw new HttpsError('failed-precondition', 'Insufficient coins.');
        }
      } else {
        if (!Number.isFinite(effectiveDiamondCost) || effectiveDiamondCost <= 0) {
          throw new HttpsError('failed-precondition', 'Invalid diamond cost.');
        }
        if (diamonds < effectiveDiamondCost) {
          throw new HttpsError('failed-precondition', 'Insufficient diamonds.');
        }
      }

      const update = {
        'chemcity.ownedItems': [...owned, itemId],
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      };

      if (currency === 'coins') {
        update['chemcity.currencies.coins'] = coins - effectiveCoinCost;
      } else {
        update['chemcity.currencies.diamonds'] = diamonds - effectiveDiamondCost;
      }

      tx.update(userRef, update);

      return {
        ok: true,
        itemId,
        currency,
        coinCost: currency === 'coins' ? effectiveCoinCost : null,
        diamondCost: currency === 'diamonds' ? effectiveDiamondCost : null,
      };
    });
  }
);

exports.chemcityUnlockPlace = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const placeId = request.data?.placeId;
    if (typeof placeId !== 'string' || !placeId) {
      throw new HttpsError('invalid-argument', 'placeId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const placeRef = db.collection('places').doc(placeId);

    const placeSnap = await placeRef.get();
    if (!placeSnap.exists) {
      throw new HttpsError('not-found', 'Place not found.');
    }
    const place = placeSnap.data() || {};
    const unlockCost = Number(place.unlockCost || 0);
    if (!Number.isFinite(unlockCost) || unlockCost < 0) {
      throw new HttpsError('failed-precondition', 'Invalid place unlock cost.');
    }

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const unlockedPlaces = Array.isArray(chemcity.unlockedPlaces) ? chemcity.unlockedPlaces : [];
      if (unlockedPlaces.includes(placeId)) {
        return { ok: true, alreadyUnlocked: true, placeId };
      }

      if (unlockCost === 0) {
        tx.update(userRef, {
          'chemcity.unlockedPlaces': [...unlockedPlaces, placeId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, placeId, cost: 0 };
      }

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      if (coins < unlockCost) {
        throw new HttpsError('failed-precondition', 'Insufficient coins.');
      }

      tx.update(userRef, {
        'chemcity.currencies.coins': coins - unlockCost,
        'chemcity.unlockedPlaces': [...unlockedPlaces, placeId],
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, placeId, cost: unlockCost };
    });
  }
);

exports.chemcityUnlockSlot = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const placeId = request.data?.placeId;
    const slotId = request.data?.slotId;
    const useExtraSlotBudget = request.data?.useExtraSlotBudget === true;

    if (typeof placeId !== 'string' || !placeId) {
      throw new HttpsError('invalid-argument', 'placeId must be a non-empty string.');
    }
    if (typeof slotId !== 'string' || !slotId) {
      throw new HttpsError('invalid-argument', 'slotId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const placeRef = db.collection('places').doc(placeId);

    const placeSnap = await placeRef.get();
    if (!placeSnap.exists) {
      throw new HttpsError('not-found', 'Place not found.');
    }
    const place = placeSnap.data() || {};
    const slots = Array.isArray(place.slots) ? place.slots : [];
    const slot = slots.find((s) => s && typeof s === 'object' && String(s.slotId || '') === slotId);
    if (!slot) {
      throw new HttpsError('failed-precondition', 'Invalid slotId.');
    }

    const isBudgetOnly = slot.budgetOnly === true;

    const unlockCost = slot.unlockCost == null ? null : Number(slot.unlockCost);
    const unlockCurrency = slot.unlockCurrency == null ? 'coins' : String(slot.unlockCurrency);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const unlockedPlaces = Array.isArray(chemcity.unlockedPlaces) ? chemcity.unlockedPlaces : [];
      if (!unlockedPlaces.includes(placeId)) {
        throw new HttpsError('failed-precondition', 'Place is locked.');
      }

      const unlockedSlots = Array.isArray(chemcity.unlockedSlots) ? chemcity.unlockedSlots : [];
      if (unlockedSlots.includes(slotId)) {
        return { ok: true, alreadyUnlocked: true, slotId };
      }

      // Budget-only slots can only be unlocked via extraSlotsBudget.
      if (isBudgetOnly) {
        if (!useExtraSlotBudget) {
          throw new HttpsError('failed-precondition', 'This slot can only be unlocked using extra slot budget.');
        }
        const budget = Number(chemcity.extraSlotsBudget || 0);
        if (budget <= 0) {
          throw new HttpsError('failed-precondition', 'No extra slot budget available.');
        }
        tx.update(userRef, {
          'chemcity.extraSlotsBudget': budget - 1,
          'chemcity.unlockedSlots': [...unlockedSlots, slotId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, slotId, usedExtraSlotBudget: true, budgetOnly: true };
      }

      // Non-budget slots must not spend extraSlotsBudget.
      if (useExtraSlotBudget) {
        throw new HttpsError('failed-precondition', 'This slot cannot be unlocked using extra slot budget.');
      }

      if (unlockCost == null) {
        tx.update(userRef, {
          'chemcity.unlockedSlots': [...unlockedSlots, slotId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, slotId, cost: 0, currency: null };
      }

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);

      if (unlockCurrency === 'diamonds') {
        if (!Number.isFinite(unlockCost) || unlockCost <= 0) {
          throw new HttpsError('failed-precondition', 'Invalid slot unlock cost.');
        }
        if (diamonds < unlockCost) {
          throw new HttpsError('failed-precondition', 'Insufficient diamonds.');
        }
        tx.update(userRef, {
          'chemcity.currencies.diamonds': diamonds - unlockCost,
          'chemcity.unlockedSlots': [...unlockedSlots, slotId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, slotId, cost: unlockCost, currency: 'diamonds' };
      }

      if (!Number.isFinite(unlockCost) || unlockCost <= 0) {
        throw new HttpsError('failed-precondition', 'Invalid slot unlock cost.');
      }
      if (coins < unlockCost) {
        throw new HttpsError('failed-precondition', 'Insufficient coins.');
      }
      tx.update(userRef, {
        'chemcity.currencies.coins': coins - unlockCost,
        'chemcity.unlockedSlots': [...unlockedSlots, slotId],
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });
      return { ok: true, slotId, cost: unlockCost, currency: 'coins' };
    });
  }
);

exports.chemcityGetDailyLoginBonus = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};
      const streaks = chemcity.streaks || {};

      const today = getTodayUtcDateKey();
      const lastLoginDate = typeof streaks.lastLoginDate === 'string' ? streaks.lastLoginDate : '';

      if (lastLoginDate === today) {
        return { ok: true, alreadyClaimed: true, date: today };
      }

      const prevStreak = Number(streaks.currentStreak || 0);

      let nextStreak = 1;
      if (lastLoginDate) {
        const last = new Date(`${lastLoginDate}T00:00:00.000Z`);
        const t = new Date(`${today}T00:00:00.000Z`);
        const diffDays = Math.floor((t.getTime() - last.getTime()) / (24 * 3600 * 1000));
        if (diffDays === 1) nextStreak = prevStreak + 1;
        else nextStreak = 1;
      }

      const longestStreak = Math.max(Number(streaks.longestStreak || 0), nextStreak);

      const bonuses = chemcity.activeBonuses || {};
      const diamondsAwarded = Math.max(0, Math.floor(Number(bonuses.dailyLoginDiamonds || 5)));

      tx.update(userRef, {
        'chemcity.currencies.diamonds': admin.firestore.FieldValue.increment(diamondsAwarded),
        'chemcity.streaks.currentStreak': nextStreak,
        'chemcity.streaks.longestStreak': longestStreak,
        'chemcity.streaks.lastLoginDate': today,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        ok: true,
        date: today,
        diamondsAwarded,
        currentStreak: nextStreak,
        longestStreak,
      };
    });
  }
);

exports.chemcityQuizReward = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const baseDiamonds = Number(request.data?.baseDiamonds || 0);
    const baseCoins = Number(request.data?.baseCoins || 0);
    const topicId = request.data?.topicId;
    const correctAnswers = Number(request.data?.correctAnswers || 0);
    const totalQuestions = Number(request.data?.totalQuestions || 0);

    if (!Number.isFinite(baseDiamonds) || baseDiamonds < 0) {
      throw new HttpsError('invalid-argument', 'baseDiamonds must be a non-negative number.');
    }
    if (!Number.isFinite(baseCoins) || baseCoins < 0) {
      throw new HttpsError('invalid-argument', 'baseCoins must be a non-negative number.');
    }
    if (topicId != null && typeof topicId !== 'string') {
      throw new HttpsError('invalid-argument', 'topicId must be a string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const progressRef = userRef.collection('chemcity_progress').doc('data');

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};
      const bonuses = chemcity.activeBonuses || {};

      let diamonds = Math.floor(baseDiamonds);

      const kitchenRoll = rollKitchenBonusFromMax(bonuses.quizFlatDiamondBonus);
      diamonds += kitchenRoll;

      const mult = Number(bonuses.quizDiamondMultiplier || 1);
      if (Number.isFinite(mult) && mult > 0) {
        diamonds = Math.floor(diamonds * mult);
      }

      if (rollBeachDoubleFromPercent(bonuses.quizDoubleChancePercent)) {
        diamonds *= 2;
      }

      diamonds = Math.max(0, diamonds);

      const updates = {
        'chemcity.currencies.coins': admin.firestore.FieldValue.increment(Math.floor(baseCoins)),
        'chemcity.currencies.diamonds': admin.firestore.FieldValue.increment(diamonds),
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      };

      tx.update(userRef, updates);

      if (typeof topicId === 'string' && topicId) {
        const progressSnap = await tx.get(progressRef);
        const progress = progressSnap.exists ? (progressSnap.data() || {}) : {};
        const tm = progress.topicMastery && typeof progress.topicMastery === 'object' ? progress.topicMastery : {};
        const prev = tm[topicId] && typeof tm[topicId] === 'object' ? tm[topicId] : {};

        const next = {
          quizzesCompleted: Number(prev.quizzesCompleted || 0) + 1,
          correctAnswers: Number(prev.correctAnswers || 0) + (Number.isFinite(correctAnswers) ? correctAnswers : 0),
          totalQuestions: Number(prev.totalQuestions || 0) + (Number.isFinite(totalQuestions) ? totalQuestions : 0),
        };

        const nextTm = { ...tm, [topicId]: next };
        tx.set(progressRef, { topicMastery: nextTm }, { merge: true });
      }

      return {
        ok: true,
        coinsAwarded: Math.floor(baseCoins),
        diamondsAwarded: diamonds,
      };
    });
  }
);

exports.chemcityEquipCard = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const slotId = request.data?.slotId;
    const itemId = request.data?.itemId;
    if (typeof slotId !== 'string' || !slotId) {
      throw new HttpsError('invalid-argument', 'slotId must be a non-empty string.');
    }
    if (typeof itemId !== 'string' || !itemId) {
      throw new HttpsError('invalid-argument', 'itemId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const itemRef = db.collection('items').doc(itemId);

    const itemSnap = await itemRef.get();
    if (!itemSnap.exists) {
      throw new HttpsError('not-found', 'Item not found.');
    }
    const item = itemSnap.data() || {};
    if (item.deprecated === true) {
      throw new HttpsError('failed-precondition', 'Item is deprecated.');
    }
    const baseId = typeof item.baseId === 'string' && item.baseId.trim() ? item.baseId.trim() : '';
    const itemPlaceId = String(item.placeId || '');
    const validSlots = Array.isArray(item.validSlots) ? item.validSlots.map(String) : [];
    if (!validSlots.includes(slotId)) {
      throw new HttpsError('failed-precondition', 'Item cannot be equipped in this slot.');
    }

    const placeRef = itemPlaceId ? db.collection('places').doc(itemPlaceId) : null;

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const owned = Array.isArray(chemcity.ownedItems) ? chemcity.ownedItems : [];
      if (!owned.includes(itemId)) {
        throw new HttpsError('failed-precondition', 'Item not owned.');
      }

      const unlockedPlaces = Array.isArray(chemcity.unlockedPlaces) ? chemcity.unlockedPlaces : [];
      if (itemPlaceId && !unlockedPlaces.includes(itemPlaceId)) {
        throw new HttpsError('failed-precondition', 'Place is locked.');
      }

      if (placeRef) {
        const placeSnap = await tx.get(placeRef);
        if (!placeSnap.exists) {
          throw new HttpsError('failed-precondition', 'Place config missing.');
        }
        const place = placeSnap.data() || {};
        const slots = Array.isArray(place.slots) ? place.slots : [];
        const slot = slots.find((s) => s && typeof s === 'object' && String(s.slotId || '') === slotId);
        if (!slot) {
          throw new HttpsError('failed-precondition', 'Invalid slotId.');
        }
        const unlockedSlots = Array.isArray(chemcity.unlockedSlots) ? chemcity.unlockedSlots : [];
        const isFree = slot.unlockCost == null;
        if (!isFree && !unlockedSlots.includes(slotId)) {
          throw new HttpsError('failed-precondition', 'Slot is locked.');
        }
      }

      const prevEquipped = chemcity.equipped && typeof chemcity.equipped === 'object' ? chemcity.equipped : {};
      const nextEquipped = { ...prevEquipped };

      if (baseId) {
        const entries = Object.entries(prevEquipped);
        for (const [equippedSlotId, equippedItemId] of entries) {
          if (equippedSlotId === slotId) continue;
          if (typeof equippedItemId !== 'string' || !equippedItemId) continue;

          const equippedRef = db.collection('items').doc(equippedItemId);
          const equippedSnap = await tx.get(equippedRef);
          if (!equippedSnap.exists) continue;
          const equipped = equippedSnap.data() || {};
          const equippedBaseId =
            typeof equipped.baseId === 'string' && equipped.baseId.trim() ? equipped.baseId.trim() : '';
          if (equippedBaseId && equippedBaseId === baseId) {
            delete nextEquipped[equippedSlotId];
          }
        }
      }

      nextEquipped[slotId] = itemId;

      const nextBonuses = await computeChemCityActiveBonuses(db, nextEquipped);

      tx.update(userRef, {
        'chemcity.equipped': nextEquipped,
        'chemcity.activeBonuses': nextBonuses,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, equipped: nextEquipped, activeBonuses: nextBonuses };
    });
  }
);

exports.chemcityUnequipCard = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const slotId = request.data?.slotId;
    if (typeof slotId !== 'string' || !slotId) {
      throw new HttpsError('invalid-argument', 'slotId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const prevEquipped = chemcity.equipped && typeof chemcity.equipped === 'object' ? chemcity.equipped : {};
      const nextEquipped = { ...prevEquipped };
      delete nextEquipped[slotId];

      const nextBonuses = await computeChemCityActiveBonuses(db, nextEquipped);

      tx.update(userRef, {
        'chemcity.equipped': nextEquipped,
        'chemcity.activeBonuses': nextBonuses,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, equipped: nextEquipped, activeBonuses: nextBonuses };
    });
  }
);

exports.chemcityInitUser = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);
    return { ok: true };
  }
);

exports.chemcityMigrateSlotIds = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const SLOT_ID_SCHEMA_VERSION = 2;

    const SLOT_ID_MAP = {
      // Lab
      lab_bench_1: 'lab_bench',
      lab_bench_2: 'lab_fume_hood',
      lab_bench_3: 'lab_acid_alkali_cabinet',
      lab_bench_4: 'lab_apparatus_1',
      lab_bench_5: 'lab_metal_shelf',
      lab_bench_6: 'lab_salt_shelf',
      lab_premium_1: 'lab_hazardous_chemical_shelf',
      lab_premium_2: 'lab_apparatus_2',
      lab_premium_3: 'lab_chemical_shelf',
      lab_premium_4: 'lab_gas_tank',
      // Kitchen
      kitchen_counter_1: 'kitchen_cutlery_drawer',
      kitchen_counter_2: 'kitchen_pantry_1',
      kitchen_counter_3: 'kitchen_stove_oven',
      kitchen_counter_4: 'kitchen_dinette',
      kitchen_shelf_1: 'kitchen_fridge',
      kitchen_shelf_2: 'kitchen_pantry_2',
      kitchen_shelf_3: 'kitchen_base_cabinet',
      kitchen_shelf_4: 'kitchen_countertop',
      // Toilet
      toilet_tank_1: 'toilet_faucet',
      toilet_tank_2: 'toilet_vanity_cabinet',
      toilet_tank_3: 'toilet_bathtub',
      toilet_tank_4: 'toilet_mirror_cabinet_1',
      toilet_cabinet_1: 'toilet_toilet',
      toilet_cabinet_2: 'toilet_vanity_top',
      toilet_cabinet_3: 'toilet_mirror_cabinet_2',
      // Garden
      garden_bed_1: 'garden_shed_1',
      garden_bed_2: 'garden_lawn',
      garden_bed_3: 'garden_greenhouse',
      garden_bed_4: 'garden_flower_bed',
      garden_plot_1: 'garden_mole_hill',
      garden_plot_2: 'garden_broadcast_spreader',
      garden_plot_3: 'garden_shed_2',
      // Gas Station
      gas_pump_1: 'gas_station_car_1',
      gas_pump_2: 'gas_station_construction_site',
      gas_pump_3: 'gas_station_factory',
      gas_pump_4: 'gas_station_petrol_pump',
      gas_shelf_1: 'gas_station_car_2',
      gas_shelf_2: 'gas_station_motel',
      gas_shelf_3: 'gas_station_street_light',
      gas_shelf_4: 'gas_station_firework',
      // Boutique
      boutique_shelf_1: 'lifestyle_boutique_poseur_table_1',
      boutique_shelf_2: 'lifestyle_boutique_service_desk',
      boutique_shelf_3: 'lifestyle_boutique_jewellery_display',
      boutique_shelf_4: 'lifestyle_boutique_power_essentials',
      boutique_display_1: 'lifestyle_boutique_apparel_gallery',
      boutique_display_2: 'lifestyle_boutique_poseur_table_2',
      // Beach
      beach_sand_1: 'beach_sky',
      beach_sand_2: 'beach_sea',
      beach_sand_3: 'beach_rock_1',
      beach_sand_4: 'beach_dry_sand',
      beach_pier_1: 'beach_strandline',
      beach_pier_2: 'beach_rock_2',
      beach_pier_3: 'beach_cliffside',
      // School
      school_desk_1: 'school_student_desk_1',
      school_desk_2: 'school_teacher_desk',
      school_desk_3: 'school_blackboard',
      school_desk_4: 'school_science_corner',
      school_desk_5: 'school_poster',
      school_locker_1: 'school_window_side_table',
      school_locker_2: 'school_student_desk_2',
    };

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const snap = await tx.get(userRef);
      if (!snap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = snap.data() || {};
      const chemcity = userData.chemcity || {};

      const currentVersion = Number(chemcity.slotIdSchemaVersion || 0);
      if (currentVersion >= SLOT_ID_SCHEMA_VERSION) {
        return { ok: true, alreadyMigrated: true, version: currentVersion };
      }

      const prevEquipped = chemcity.equipped && typeof chemcity.equipped === 'object' ? chemcity.equipped : {};
      const prevUnlockedSlots = Array.isArray(chemcity.unlockedSlots) ? chemcity.unlockedSlots.map(String) : [];

      const nextEquipped = {};
      let equippedKeysMigrated = 0;
      for (const [oldSlotId, itemId] of Object.entries(prevEquipped)) {
        const newSlotId = SLOT_ID_MAP[oldSlotId] || oldSlotId;
        if (newSlotId !== oldSlotId) equippedKeysMigrated++;
        nextEquipped[newSlotId] = itemId;
      }

      const nextUnlockedSlots = [];
      let unlockedSlotsMigrated = 0;
      const seen = new Set();
      for (const oldSlotId of prevUnlockedSlots) {
        const newSlotId = SLOT_ID_MAP[oldSlotId] || oldSlotId;
        if (newSlotId !== oldSlotId) unlockedSlotsMigrated++;
        if (seen.has(newSlotId)) continue;
        seen.add(newSlotId);
        nextUnlockedSlots.push(newSlotId);
      }

      const nextBonuses = await computeChemCityActiveBonuses(db, nextEquipped);

      tx.update(userRef, {
        'chemcity.equipped': nextEquipped,
        'chemcity.unlockedSlots': nextUnlockedSlots,
        'chemcity.activeBonuses': nextBonuses,
        'chemcity.slotIdSchemaVersion': SLOT_ID_SCHEMA_VERSION,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        ok: true,
        alreadyMigrated: false,
        version: SLOT_ID_SCHEMA_VERSION,
        equippedKeysMigrated,
        unlockedSlotsMigrated,
      };
    });
  }
);

exports.chemcityCollectPassiveIncome = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();

    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const MAX_HOURS = 24;

    return db.runTransaction(async (tx) => {
      const snap = await tx.get(userRef);
      if (!snap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = snap.data() || {};
      const chemcity = userData.chemcity || {};
      const bonuses = chemcity.activeBonuses || {};
      const passiveBase = Number(bonuses.passiveBaseCoinsPerHour || 0);

      if (!Number.isFinite(passiveBase) || passiveBase <= 0) {
        return {
          coinsAwarded: 0,
          message: 'No passive income yet — equip cards in the Garden and Lab.',
        };
      }

      const serverNow = admin.firestore.Timestamp.now();
      const lastCollected = chemcity.passiveIncome?.lastCollected || null;

      let elapsedSeconds = 0;
      if (lastCollected && typeof lastCollected.seconds === 'number') {
        elapsedSeconds = serverNow.seconds - lastCollected.seconds;
      }

      const cappedSeconds = Math.min(elapsedSeconds, MAX_HOURS * 3600);
      const elapsedHours = cappedSeconds / 3600;
      const coinsAwarded = Math.floor(passiveBase * elapsedHours);

      tx.update(userRef, {
        'chemcity.currencies.coins': admin.firestore.FieldValue.increment(coinsAwarded),
        'chemcity.passiveIncome.lastCollected': serverNow,
        'chemcity.updatedAt': serverNow,
      });

      return {
        coinsAwarded,
        elapsedHours: Number(elapsedHours.toFixed(2)),
        newLastCollected: serverNow.toDate().toISOString(),
      };
    });
  }
);

exports.normalizeMistakes = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to normalize mistakes');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');

    const pageSize = 800;
    let last = null;
    let processed = 0;
    let updated = 0;

    const nowIso = new Date().toISOString();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);

      const snap = await q.get();
      if (snap.empty) break;

      // Only write docs that truly need a patch.
      const toPatch = [];
      for (const docSnap of snap.docs) {
        const d = docSnap.data() || {};

        const topic = d.Topic ?? d.topic ?? null;
        const subtopic = d.Subtopic ?? d.subtopic ?? null;
        const lastWrongAt = d.lastWrongAt ?? d.lastAttempted ?? d.updatedAt ?? d.createdAt ?? nowIso;

        const needsTopic = d.Topic == null && d.topic != null;
        const needsSubtopic = d.Subtopic == null && d.subtopic != null;
        const needsLastWrongAt = d.lastWrongAt == null;

        if (needsTopic || needsSubtopic || needsLastWrongAt) {
          toPatch.push({
            ref: docSnap.ref,
            patch: {
              Topic: topic,
              Subtopic: subtopic,
              lastWrongAt,
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          });
        }
      }

      if (toPatch.length > 0) {
        for (let i = 0; i < toPatch.length; i += 450) {
          const batch = db.batch();
          const slice = toPatch.slice(i, i + 450);
          slice.forEach((x) => {
            batch.set(x.ref, x.patch, { merge: true });
          });
          await batch.commit();
          updated += slice.length;
        }
      }

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Make it easy to see when it was last run.
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');
    await statsRef.set({
      lastNormalizedAt: admin.firestore.FieldValue.serverTimestamp(),
      lastNormalizedProcessed: processed,
      lastNormalizedUpdated: updated,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, updated };
  }
);

exports.updateMistakeTopicStatsOnUpdate = onDocumentUpdated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || null;
    const after = event.data?.after?.data?.() || null;
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, after);
  }
);

exports.updateMistakeTopicStatsOnDelete = onDocumentDeleted(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const before = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, null);
  }
);

exports.rebuildMistakeTopicStats = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild mistake topic stats');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

    const topics = {};

    const pageSize = 800;
    let last = null;
    let processed = 0;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);
      const snap = await q.get();
      if (snap.empty) break;

      snap.docs.forEach((docSnap) => {
        const m = docSnap.data() || {};
        const topic = getTopicFromMistake(m);
        if (!topic) return;
        const topicEnc = encodeKey(topic);
        const bucket = getBucketFromMistake(m);
        const isActive = getIsActiveFromMistake(m);

        const entry = topics[topicEnc] && typeof topics[topicEnc] === 'object' ? topics[topicEnc] : {};
        entry.total = Number(entry.total || 0) + 1;
        const bucketKey = `b_${bucket}`;
        entry[bucketKey] = Number(entry[bucketKey] || 0) + 1;
        if (isActive) entry.active = Number(entry.active || 0) + 1;
        topics[topicEnc] = entry;
      });

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    await statsRef.set({
      topics,
      processed,
      rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, topics: Object.keys(topics).length };
  }
);

exports.pickMistakesForReview = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to pick mistakes');
    }

    const data = request.data && typeof request.data === 'object' ? request.data : {};
    const limitN = Math.min(Math.max(parseInt(data.limit || 40, 10) || 40, 1), 400);
    const filters = data.filters && typeof data.filters === 'object' ? data.filters : {};

    const datePeriod = safeString(filters.datePeriod || 'all');
    const selectedTopics = Array.isArray(filters.selectedTopics) ? filters.selectedTopics.filter(Boolean).map(String) : [];
    const selectedSubtopics = Array.isArray(filters.selectedSubtopics) ? filters.selectedSubtopics.filter(Boolean).map(String) : [];
    const selectedMasteryLevels = Array.isArray(filters.selectedMasteryLevels) ? filters.selectedMasteryLevels.filter(Boolean).map(String) : [];
    const srsPresence = safeString(filters.srsPresence || 'all');

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');

    const now = new Date();
    const weekAgo = new Date(now);
    weekAgo.setDate(weekAgo.getDate() - 7);
    const monthAgo = new Date(now);
    monthAgo.setMonth(monthAgo.getMonth() - 1);

    const matchesSrs = (row) => {
      if (srsPresence === 'in_srs') return row && row.srsIsActive === true;
      if (srsPresence === 'not_in_srs') return normalizeBucket((row && row.srsBucket) || 'not_in_srs') === 'not_in_srs';
      return true;
    };

    const topics = selectedTopics;
    const subs = selectedSubtopics;
    const lvls = selectedMasteryLevels;

    const baseParts = [];
    if (datePeriod === 'week') baseParts.push(['lastWrongAt', '>=', weekAgo.toISOString()]);
    if (datePeriod === 'month') baseParts.push(['lastWrongAt', '>=', monthAgo.toISOString()]);

    if (topics.length === 1) baseParts.push(['Topic', '==', topics[0]]);
    else if (topics.length >= 2 && topics.length <= 10) baseParts.push(['Topic', 'in', topics]);

    if (subs.length === 1 && topics.length <= 1) baseParts.push(['Subtopic', '==', subs[0]]);

    if (srsPresence !== 'not_in_srs' && lvls.length === 1) baseParts.push(['srsBucket', '==', normalizeBucket(lvls[0])]);

    if (srsPresence === 'in_srs') baseParts.push(['srsIsActive', '==', true]);
    if (srsPresence === 'not_in_srs') baseParts.push(['srsBucket', '==', 'not_in_srs']);

    const collected = [];
    let fetched = 0;
    const maxFetch = 1200;
    const pageSize = 250;
    let last = null;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      if (collected.length >= limitN) break;
      if (fetched >= maxFetch) break;

      let q = mistakesRef.orderBy('lastWrongAt', 'desc');
      baseParts.forEach(([f, op, v]) => { q = q.where(f, op, v); });
      if (last) q = q.startAfter(last);
      q = q.limit(Math.min(pageSize, maxFetch - fetched));

      let snap;
      try {
        snap = await q.get();
      } catch (err) {
        const code = err && (err.code || err.status || err.statusCode);
        const details = err && (err.details || err.message || String(err));
        // Firestore missing index => FAILED_PRECONDITION (gRPC code 9)
        if (code === 9 || code === 'FAILED_PRECONDITION') {
          throw new HttpsError('failed-precondition', details);
        }
        throw new HttpsError('internal', details);
      }
      if (snap.empty) break;
      fetched += snap.size;
      last = snap.docs[snap.docs.length - 1];

      for (const docSnap of snap.docs) {
        const row = docSnap.data() || {};

        if (topics.length > 10) {
          const tp = safeString(row.Topic || row.topic || '');
          if (!tp || !topics.includes(tp)) continue;
        }

        if (subs.length > 1) {
          const sb = safeString(row.Subtopic || row.subtopic || '');
          if (!sb || !subs.includes(sb)) continue;
        }

        if (srsPresence !== 'not_in_srs' && lvls.length > 1) {
          const b = normalizeBucket(row.srsBucket || 'not_in_srs');
          if (!lvls.includes(b)) continue;
        }

        if (!matchesSrs(row)) continue;

        collected.push(docSnap.id);
        if (collected.length >= limitN) break;
      }

      if (snap.size < pageSize) break;
    }

    return {
      ok: true,
      userId: uid,
      ids: collected.slice(0, limitN),
      requested: limitN,
      fetched,
    };
  }
);

async function applySrsSummaryDelta(db, userId, dateStr, delta, topic, subtopic) {
  const uid = safeString(userId);
  const dateKey = safeString(dateStr);
  if (!uid || !dateKey || !Number.isFinite(delta) || delta === 0) return;

  const topicKey = encodeKey(topic || '');
  const subtopicKey = encodeKey(subtopic || '');
  const hasTopic = Boolean(topicKey);
  const hasSubtopic = Boolean(topicKey) && Boolean(subtopicKey);
  const compoundSubKey = hasSubtopic ? `${topicKey}::${subtopicKey}` : '';

  const summaryRef = db.collection('users').doc(uid).collection('srs_daily_summaries').doc(dateKey);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(summaryRef);
    const prev = snap.exists ? (snap.data() || {}) : {};

    const next = { ...prev };
    next.date = dateKey;
    next.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    const prevTotal = Number(prev.dueTotal || 0);
    next.dueTotal = Math.max(0, prevTotal + delta);

    const prevTopics = prev.topicCounts && typeof prev.topicCounts === 'object' ? prev.topicCounts : {};
    const prevSubs = prev.subtopicCounts && typeof prev.subtopicCounts === 'object' ? prev.subtopicCounts : {};

    const nextTopics = { ...prevTopics };
    const nextSubs = { ...prevSubs };

    if (hasTopic) {
      const old = Number(nextTopics[topicKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextTopics[topicKey];
      else nextTopics[topicKey] = v;
    }

    if (hasSubtopic) {
      const old = Number(nextSubs[compoundSubKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextSubs[compoundSubKey];
      else nextSubs[compoundSubKey] = v;
    }

    next.topicCounts = nextTopics;
    next.subtopicCounts = nextSubs;

    tx.set(summaryRef, next, { merge: true });
  });
}

function isActiveCard(card) {
  if (!card || typeof card !== 'object') return false;
  if (card.isActive === false) return false;
  if (!card.userId) return false;
  if (!card.nextReviewDate) return false;
  return true;
}

// Define secrets (use new Firebase Functions params API)
const algoliaAppId = defineSecret('ALGOLIA_APP_ID');
const algoliaAdminKey = defineSecret('ALGOLIA_ADMIN_KEY');
const ALGOLIA_INDEX_NAME = 'forum_posts';

// Initialize Algolia client lazily at runtime
function getAlgoliaClient() {
  const appId = algoliaAppId.value();
  const adminKey = algoliaAdminKey.value();
  if (!appId || !adminKey) return null;
  return algoliasearch(appId, adminKey);
}

exports.aggregateCommentQuestionStatsOnCommentCreate = onDocumentCreated(
  {
    document: 'comments/{commentId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;

    const comment = snap.data() || {};
    const questionId = comment.questionId != null ? String(comment.questionId) : '';
    if (!questionId) return;

    const createdAt = typeof comment.createdAt === 'string'
      ? comment.createdAt
      : new Date().toISOString();

    const db = admin.firestore();
    const statsRef = db.collection('comment_question_stats').doc(questionId);

    await db.runTransaction(async (tx) => {
      const statsSnap = await tx.get(statsRef);
      const prev = statsSnap.exists ? (statsSnap.data() || {}) : {};

      const prevLast = typeof prev.lastActivity === 'string' ? prev.lastActivity : '';
      const nextLastActivity = prevLast && prevLast > createdAt ? prevLast : createdAt;

      tx.set(statsRef, {
        questionId,
        commentCount: admin.firestore.FieldValue.increment(1),
        lastActivity: nextLastActivity,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.rebuildSrsDailySummaries = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild summaries');
    }

    const db = admin.firestore();

    // Page through all active cards for this user
    const cardsRef = db.collection('spaced_repetition_cards');
    const pageSize = 500;
    let last = null;
    let totalCards = 0;

    // dateStr => { dueTotal, topicCounts, subtopicCounts }
    const aggregated = new Map();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = cardsRef
        .where('userId', '==', uid)
        .where('isActive', '==', true)
        .orderBy(admin.firestore.FieldPath.documentId())
        .limit(pageSize);

      if (last) {
        q = q.startAfter(last);
      }

      const snap = await q.get();
      if (snap.empty) break;

      for (const docSnap of snap.docs) {
        const card = docSnap.data() || {};
        if (!card.nextReviewDate) continue;

        const dateKey = safeString(card.nextReviewDate);
        const topicEnc = encodeKey(card.topic || '');
        const subEnc = encodeKey(card.subtopic || '');
        const compound = (topicEnc && subEnc) ? `${topicEnc}::${subEnc}` : '';

        if (!aggregated.has(dateKey)) {
          aggregated.set(dateKey, {
            date: dateKey,
            dueTotal: 0,
            topicCounts: {},
            subtopicCounts: {},
          });
        }

        const entry = aggregated.get(dateKey);
        entry.dueTotal += 1;

        if (topicEnc) {
          entry.topicCounts[topicEnc] = (entry.topicCounts[topicEnc] || 0) + 1;
        }
        if (compound) {
          entry.subtopicCounts[compound] = (entry.subtopicCounts[compound] || 0) + 1;
        }
      }

      totalCards += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Write summaries for encountered dates (overwrite those docs).
    const summariesRef = db.collection('users').doc(uid).collection('srs_daily_summaries');
    const dateKeys = Array.from(aggregated.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    let written = 0;
    for (let i = 0; i < dateKeys.length; i += 400) {
      const batch = db.batch();
      const slice = dateKeys.slice(i, i + 400);

      for (const dateKey of slice) {
        const data = aggregated.get(dateKey);
        const ref = summariesRef.doc(dateKey);
        batch.set(ref, {
          date: data.date,
          dueTotal: data.dueTotal,
          topicCounts: data.topicCounts,
          subtopicCounts: data.subtopicCounts,
          rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
      }

      await batch.commit();
      written += slice.length;
    }

    return {
      ok: true,
      userId: uid,
      cardsProcessed: totalCards,
      datesWritten: written,
    };
  }
);

// Maintain SRS daily summaries (cheap calendar counts)
exports.updateSrsDailySummaryOnCardCreate = onDocumentCreated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, 1, card.topic, card.subtopic);
  }
);

exports.updateSrsDailySummaryOnCardUpdate = onDocumentUpdated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || {};
    const after = event.data?.after?.data?.() || {};

    const beforeActive = isActiveCard(before);
    const afterActive = isActiveCard(after);

    const db = admin.firestore();

    // Removed from active set
    if (beforeActive && !afterActive) {
      await applySrsSummaryDelta(db, before.userId, before.nextReviewDate, -1, before.topic, before.subtopic);
      return;
    }

    // Added to active set
    if (!beforeActive && afterActive) {
      await applySrsSummaryDelta(db, after.userId, after.nextReviewDate, 1, after.topic, after.subtopic);
      return;
    }

    if (!beforeActive && !afterActive) return;

    const uid = after.userId || before.userId;
    const beforeDate = safeString(before.nextReviewDate);
    const afterDate = safeString(after.nextReviewDate);
    const beforeTopic = safeString(before.topic);
    const afterTopic = safeString(after.topic);
    const beforeSub = safeString(before.subtopic);
    const afterSub = safeString(after.subtopic);

    const dateChanged = beforeDate !== afterDate;
    const topicChanged = beforeTopic !== afterTopic;
    const subChanged = beforeSub !== afterSub;

    if (!dateChanged && !topicChanged && !subChanged) return;

    // Remove old
    await applySrsSummaryDelta(db, uid, beforeDate, -1, beforeTopic, beforeSub);
    // Add new
    await applySrsSummaryDelta(db, uid, afterDate, 1, afterTopic, afterSub);
  }
);

exports.updateSrsDailySummaryOnCardDelete = onDocumentDeleted(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, -1, card.topic, card.subtopic);
  }
);

// Maintain daily cleared/milestone stats from SRS review attempts
exports.updateSrsDailySummaryOnAttemptCreate = onDocumentCreated(
  {
    document: 'review_attempts/{attemptId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const attempt = snap.data() || {};

    const uid = safeString(attempt.userId);
    if (!uid) return;

    const attemptedAt = safeString(attempt.attemptedAt);
    if (!attemptedAt) return;

    const wasCorrect = attempt.wasCorrect === true;
    const statusBefore = attempt?.stateBefore?.status;

    const db = admin.firestore();
    await applySrsAttemptDelta(db, uid, attemptedAt, wasCorrect ? 1 : 0, statusBefore);
  }
);

 function toHongKongDate(dateObj) {
   // Convert an instant-in-time to a Date whose UTC fields represent Asia/Hong_Kong local time.
   // This avoids discrepancies between browser local time (HK) and Cloud Functions runtime (UTC).
   const d = dateObj instanceof Date ? dateObj : new Date(dateObj);
   return new Date(d.getTime() + 8 * 60 * 60 * 1000);
 }

function getWeeklyKeyForDate(dateObj) {
  // Use UTC getters so output is independent of the runtime's local timezone.
  const date = new Date(Date.UTC(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
  const yyyy = date.getUTCFullYear();
  return `leaderboard_weekly_${yyyy}-W${String(weekNo).padStart(2, '0')}`;
}

function weeklyTokensForRank(rank) {
  const r = Number(rank || 0);
  if (!Number.isFinite(r) || r <= 0) return 0;
  // Keep consistent with frontend logic: max(0, 11 - rank)
  return Math.max(0, 11 - r);
}

exports.aggregateWeeklyLeaderboardOnAttemptCreate = onDocumentCreated(
  {
    document: 'attempts/{attemptId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const attemptData = snap.data() || {};
    const userId = attemptData.userId;
    if (!userId) return;

    const attemptTs = attemptData.timestamp ? new Date(attemptData.timestamp) : new Date();
    const weekId = getWeeklyKeyForDate(toHongKongDate(attemptTs));

    const db = admin.firestore();
    const entryRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries').doc(userId);
    const userRef = db.collection('users').doc(userId);

    await db.runTransaction(async (tx) => {
      const [entrySnap, userSnap] = await Promise.all([
        tx.get(entryRef),
        tx.get(userRef),
      ]);

      const userData = userSnap.exists ? userSnap.data() : {};
      const prev = entrySnap.exists ? entrySnap.data() : {};

      const prevAttemptCount = Number(prev.attemptCount || 0);
      const prevTotalScore = Number(prev.totalScore || 0);
      const prevTotalQuestions = Number(prev.totalQuestions || 0);
      const prevTotalCorrect = Number(prev.totalCorrect || 0);

      const nextAttemptCount = prevAttemptCount + 1;
      const nextTotalScore = prevTotalScore + Number(attemptData.percentage || 0);
      const nextTotalQuestions = prevTotalQuestions + Number(attemptData.totalQuestions || 0);
      const nextTotalCorrect = prevTotalCorrect + Number(attemptData.correctAnswers || 0);
      const nextAverageScore = nextAttemptCount > 0 ? Math.round(nextTotalScore / nextAttemptCount) : 0;

      tx.set(entryRef, {
        userId,
        weekId,
        displayName: userData?.displayName || 'Unknown',
        level: userData?.level || null,
        equippedProfilePic: (userData?.equipped || {}).profilePic || 'flask_blue',
        equippedTheme: (userData?.equipped || {}).theme || 'default',
        streak: Number(userData?.streak || 0),
        attemptCount: nextAttemptCount,
        totalScore: nextTotalScore,
        averageScore: nextAverageScore,
        totalQuestions: nextTotalQuestions,
        totalCorrect: nextTotalCorrect,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.weeklyLeaderboardPayout = onSchedule(
  {
    schedule: '0 0 * * 1',
    timeZone: 'Asia/Hong_Kong',
    region: 'asia-east1',
  },
  async () => {
    const db = admin.firestore();

    // Run payout for LAST week (so the leaderboard is complete)
    const now = toHongKongDate(new Date());
    const lastWeekDate = new Date(now);
    lastWeekDate.setDate(lastWeekDate.getDate() - 7);
    const weekId = getWeeklyKeyForDate(toHongKongDate(lastWeekDate));

    const entriesRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries');
    const topSnap = await entriesRef.orderBy('averageScore', 'desc').limit(10).get();

    if (topSnap.empty) return;

    // Batch-like loop (transactions per user to keep idempotency + correct balances)
    const payoutPromises = topSnap.docs.map(async (docSnap, idx) => {
      const entry = docSnap.data() || {};
      const userId = entry.userId || docSnap.id;
      const rank = idx + 1;
      const tokens = weeklyTokensForRank(rank);
      if (!userId || tokens <= 0) return;

      const payoutRef = db
        .collection('weekly_leaderboards')
        .doc(weekId)
        .collection('payouts')
        .doc(userId);

      const userRef = db.collection('users').doc(userId);

      await db.runTransaction(async (tx) => {
        const [payoutSnap, userSnap] = await Promise.all([
          tx.get(payoutRef),
          tx.get(userRef),
        ]);

        if (payoutSnap.exists) {
          return; // already paid
        }

        if (!userSnap.exists) {
          // still record payout marker to avoid repeated attempts
          tx.set(payoutRef, {
            userId,
            weekId,
            rank,
            tokens,
            skipped: true,
            reason: 'User doc missing',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          });
          return;
        }

        const userData = userSnap.data() || {};
        const currentTokens = Number(userData.tokens || 0);
        const newTokens = currentTokens + tokens;

        tx.update(userRef, {
          tokens: newTokens,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const historyRef = userRef.collection('tokenHistory').doc();
        tx.set(historyRef, {
          amount: tokens,
          reason: `Leaderboard Reward: weekly #${rank}`,
          type: 'gain',
          timestamp: admin.firestore.FieldValue.serverTimestamp(),
          balanceAfter: newTokens,
          metadata: {
            category: 'leaderboard',
            period: 'weekly',
            rank,
            weekId,
          },
        });

        const notifRef = db.collection('notifications').doc();
        tx.set(notifRef, {
          recipientId: userId,
          senderId: 'system',
          type: 'leaderboard_reward',
          senderDisplayName: 'System',
          previewText: `Weekly leaderboard #${rank}: +${tokens} tokens`,
          read: false,
          createdAt: new Date().toISOString(),
          weekId,
          rank,
          tokens,
        });

        tx.set(payoutRef, {
          userId,
          weekId,
          rank,
          tokens,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      });
    });

    await Promise.all(payoutPromises);
  }
);

// === Algolia search sync for forum_posts ===

// Helper: prepare Algolia record from Firestore doc
function toAlgoliaRecord(postId, data) {
  return {
    objectID: postId,
    title: data.title || '',
    content: data.content || '',
    category: data.category || '',
    userDisplayName: data.userDisplayName || '',
    userId: data.userId || '',
    createdAt: data.createdAt || '',
    // You can add more fields if you want them searchable/filterable
  };
}

// Create: when a new forum post is created
exports.syncForumPostToAlgoliaOnCreate = onDocumentCreated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Update: when a forum post is updated
exports.syncForumPostToAlgoliaOnUpdate = onDocumentUpdated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.after.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Delete: when a forum post is deleted
exports.syncForumPostToAlgoliaOnDelete = onDocumentDeleted(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const postId = event.params.postId;
    await algoliaIndex.deleteObject(postId);
  }
);
