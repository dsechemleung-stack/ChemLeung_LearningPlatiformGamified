=== MistakeNotebookPage.jsx ===
// MistakeNotebookPage.jsx - Spaced Repetition Integration
import React, {
  useState, useEffect, useMemo, useCallback,
} from 'react';
import { createPortal } from 'react-dom';
import { useNavigate } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import ChemistryLoading from '../components/ChemistryLoading';
import { quizService } from '../services/quizService';
import { quizStorage } from '../utils/quizStorage';
import { useFloating, offset, flip, shift, autoUpdate } from '@floating-ui/react';
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { db } from '../firebase/config';
import app from '../firebase/config';
import { collection, doc, getCountFromServer, getDoc, getDocs, limit, orderBy, query, startAfter, where, writeBatch } from 'firebase/firestore';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { formatHKDateKey } from '../utils/hkTime';
import { getNow } from '../utils/timeTravel';
import {
  BookOpen, ArrowLeft, Play, AlertCircle, Target,
  CheckCircle, Filter, ChevronDown, Calendar, Hash, Tag,
  Clock, Zap, TrendingUp, Brain, BarChart2, Layers, X,
  AlertTriangle, Flame, Star, PlusCircle, Wand2, Eye, EyeOff, 
  Grid3x3, List as ListIcon, Command, Archive, Sparkles,
  ChevronRight, Maximize2, Check, Activity, LineChart,
} from 'lucide-react';

// ADD THIS IMPORT:
import { calendarService } from '../services/calendarService';
import { srsService } from '../services/srsService';

// ═══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════
const MASTERY_THRESHOLD = 3;
const ERROR_TYPES = [
  { value: 'misread', labelKey: 'notebook.errorTypeMisread', color: 'blue' },
  { value: 'calculation', labelKey: 'notebook.errorTypeCalculation', color: 'red' },
  { value: 'conceptual', labelKey: 'notebook.errorTypeConceptual', color: 'orange' },
  { value: 'careless', labelKey: 'notebook.errorTypeCareless', color: 'yellow' },
  { value: 'vocab', labelKey: 'notebook.errorTypeVocab', color: 'purple' },
  { value: 'diagram', labelKey: 'notebook.errorTypeDiagram', color: 'pink' },
];
const MASTERY_LEVELS = {
  not_in_srs:  { labelKey: 'notebook.masteryNotInSrs', color: 'slate' },
  new:        { labelKey: 'notebook.masteryNew', color: 'red' },
  progressing:{ labelKey: 'notebook.masteryDeveloping', color: 'amber' },
  near:       { labelKey: 'notebook.masteryNear', color: 'yellow' },
  archived:   { labelKey: 'notebook.mastered', color: 'green' },
};

function buildMistakeCountBaseConstraints({ userId, datePeriod, selectedTopics, selectedSubtopics, srsPresence }) {
  const now = getNow();
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);
  const monthAgo = new Date(now);
  monthAgo.setMonth(monthAgo.getMonth() - 1);

  const base = [collection(db, 'users', userId, 'mistakes')];

  if (datePeriod === 'week') {
    base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
  } else if (datePeriod === 'month') {
    base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
  }

  const topics = (Array.isArray(selectedTopics) ? selectedTopics : []).filter(Boolean);
  const subs = (Array.isArray(selectedSubtopics) ? selectedSubtopics : []).filter(Boolean);

  const canUseTopicsIn = topics.length >= 2 && topics.length <= 10;
  const canUseSubtopicsIn = subs.length >= 2 && subs.length <= 10;

  if (topics.length === 1) {
    base.push(where('Topic', '==', topics[0]));
  } else if (canUseTopicsIn) {
    base.push(where('Topic', 'in', topics));
  }

  const topicUsesIn = canUseTopicsIn;
  const topicUsesEq = topics.length === 1;

  if (subs.length === 1) {
    base.push(where('Subtopic', '==', subs[0]));
  } else if (canUseSubtopicsIn && !topicUsesIn) {
    base.push(where('Subtopic', 'in', subs));
  }

  return {
    base,
    needsClientTopicFilter: topics.length > 10,
    needsClientSubtopicFilter: (subs.length > 10) || (canUseSubtopicsIn && topicUsesIn) || (!topicUsesEq && subs.length > 0 && !canUseSubtopicsIn),
    needsClientSrsPresenceFilter: srsPresence !== 'all',
    topics,
    subs,
  };
}

async function backfillMistakeSrsFromActiveCards(userId) {
  const uid = String(userId || '');
  if (!uid) return false;

  const sessionKey = `mistake_srs_sync_active_v1_${uid}`;
  try {
    if (sessionStorage.getItem(sessionKey) === '1') return false;
    sessionStorage.setItem(sessionKey, '1');
  } catch {
    // ignore
  }

  try {
    const activeCards = await srsService.getActiveCards(uid, { limit: 800 });
    if (!activeCards || activeCards.length === 0) return false;

    const nowIso = new Date().toISOString();
    let wrote = false;

    for (let i = 0; i < activeCards.length; i += 450) {
      const batch = writeBatch(db);
      const slice = activeCards.slice(i, i + 450);
      slice.forEach((c) => {
        const qid = c?.questionId;
        if (!qid) return;
        let bucket = 'progressing';
        if (c.status === 'new') bucket = 'new';
        else if (c.status === 'learning') bucket = 'progressing';
        else if (c.status === 'review') bucket = 'near';
        else if (c.status === 'graduated') bucket = 'archived';

        batch.set(
          doc(db, 'users', uid, 'mistakes', String(qid)),
          {
            hasSrsCard: true,
            srsIsActive: true,
            srsStatus: c.status || null,
            srsBucket: bucket,
            srsCardId: c.id || null,
            srsUpdatedAt: nowIso,
            updatedAt: nowIso,
          },
          { merge: true }
        );
      });
      await batch.commit();
      wrote = true;
    }

    return wrote;
  } catch (e) {
    console.error('Failed to backfill mistakes from active SRS cards:', e);
    return false;
  }
}

async function backfillMissingTopicCaseForTopic(userId, topic) {
  const uid = String(userId || '');
  const t = String(topic || '');
  if (!uid || !t) return false;

  try {
    const snap = await getDocs(
      query(
        collection(db, 'users', uid, 'mistakes'),
        where('topic', '==', t),
        limit(500)
      )
    );

    const toFix = snap.docs
      .map((d) => ({ ref: d.ref, data: d.data() }))
      .filter((x) => !x?.data?.Topic);

    if (toFix.length === 0) return false;

    const nowIso = new Date().toISOString();
    const batch = writeBatch(db);
    toFix.slice(0, 450).forEach((x) => {
      batch.set(
        x.ref,
        {
          Topic: x?.data?.topic || t,
          Subtopic: x?.data?.Subtopic ?? x?.data?.subtopic ?? null,
          updatedAt: x?.data?.updatedAt || nowIso,
        },
        { merge: true }
      );
    });
    await batch.commit();
    return true;
  } catch (e) {
    console.error('Failed to backfill missing Topic field for topic:', e);
    return false;
  }
}

async function backfillMissingLastWrongAtForTopic(userId, topic) {
  const uid = String(userId || '');
  const t = String(topic || '');
  if (!uid || !t) return false;

  try {
    const snap = await getDocs(
      query(
        collection(db, 'users', uid, 'mistakes'),
        where('Topic', '==', t),
        limit(500)
      )
    );

    const toFix = snap.docs
      .map((d) => ({ ref: d.ref, data: d.data() }))
      .filter((x) => !x?.data?.lastWrongAt);

    if (toFix.length === 0) return false;

    const nowIso = new Date().toISOString();
    const batch = writeBatch(db);
    toFix.slice(0, 450).forEach((x) => {
      const fallback = x?.data?.lastAttempted || x?.data?.updatedAt || x?.data?.createdAt || nowIso;
      batch.set(
        x.ref,
        {
          lastWrongAt: fallback,
          updatedAt: x?.data?.updatedAt || nowIso,
        },
        { merge: true }
      );
    });
    await batch.commit();
    return true;
  } catch (e) {
    console.error('Failed to backfill missing lastWrongAt for topic:', e);
    return false;
  }
}

async function backfillMistakeSrsDefaults(userId, rows = []) {
  const uid = String(userId || '');
  if (!uid) return false;

  const targets = (Array.isArray(rows) ? rows : []).filter((r) => {
    const hasBucket = Object.prototype.hasOwnProperty.call(r || {}, 'srsBucket');
    const hasHasSrs = Object.prototype.hasOwnProperty.call(r || {}, 'hasSrsCard');
    const hasActive = Object.prototype.hasOwnProperty.call(r || {}, 'srsIsActive');

    const hasTopic = Object.prototype.hasOwnProperty.call(r || {}, 'Topic');
    const hasSubtopic = Object.prototype.hasOwnProperty.call(r || {}, 'Subtopic');
    const hasLastWrongAt = Object.prototype.hasOwnProperty.call(r || {}, 'lastWrongAt');

    const needsSrsDefaults = !(hasBucket && hasHasSrs && hasActive);
    const needsTopicShape = !(hasTopic && hasSubtopic && hasLastWrongAt);
    return needsSrsDefaults || needsTopicShape;
  });

  if (targets.length === 0) return false;

  try {
    const batch = writeBatch(db);
    const nowIso = new Date().toISOString();
    targets.slice(0, 450).forEach((r) => {
      const qid = r?.questionId ?? r?.ID ?? r?.docId ?? r?.id;
      if (!qid) return;

      const topic = r?.Topic ?? r?.topic ?? null;
      const subtopic = r?.Subtopic ?? r?.subtopic ?? null;
      const lastWrongAt = r?.lastWrongAt ?? r?.lastAttempted ?? r?.updatedAt ?? nowIso;

      batch.set(
        doc(db, 'users', uid, 'mistakes', String(qid)),
        {
          hasSrsCard: r?.hasSrsCard === true,
          srsIsActive: r?.srsIsActive === true,
          srsStatus: r?.srsStatus ?? null,
          srsBucket: r?.srsBucket ?? (r?.hasSrsCard ? 'progressing' : 'not_in_srs'),
          srsCardId: r?.srsCardId ?? null,
          srsUpdatedAt: nowIso,
          Topic: topic,
          Subtopic: subtopic,
          lastWrongAt,
          updatedAt: r?.updatedAt ?? nowIso,
        },
        { merge: true }
      );
    });
    await batch.commit();
    return true;
  } catch (e) {
    console.error('Failed to backfill mistake SRS defaults:', e);
    return false;
  }
}

function buildMistakeIndexQueryConstraints({ userId, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, cursor, pageSize }) {
  const now = getNow();
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);
  const monthAgo = new Date(now);
  monthAgo.setMonth(monthAgo.getMonth() - 1);

  const base = [collection(db, 'users', userId, 'mistakes')];

  if (datePeriod === 'week') {
    base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
  } else if (datePeriod === 'month') {
    base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
  }

  const topics = (Array.isArray(selectedTopics) ? selectedTopics : []).filter(Boolean);
  const subs = (Array.isArray(selectedSubtopics) ? selectedSubtopics : []).filter(Boolean);
  const masteryLevels = (Array.isArray(selectedMasteryLevels) ? selectedMasteryLevels : []).filter(Boolean);

  const canUseTopicsIn = topics.length >= 2 && topics.length <= 10;
  const canUseSubtopicsIn = subs.length >= 2 && subs.length <= 10;
  const canUseMasteryIn = masteryLevels.length >= 2 && masteryLevels.length <= 10;

  // Firestore limitation: you can't combine two different "in" filters in one query.
  // We prioritize Topic server-side; Subtopic may fall back to client-side filtering.
  if (topics.length === 1) {
    base.push(where('Topic', '==', topics[0]));
  } else if (canUseTopicsIn) {
    base.push(where('Topic', 'in', topics));
  }

  const topicUsesIn = canUseTopicsIn;
  const topicUsesEq = topics.length === 1;

  if (subs.length === 1) {
    base.push(where('Subtopic', '==', subs[0]));
  } else if (canUseSubtopicsIn && !topicUsesIn) {
    base.push(where('Subtopic', 'in', subs));
  }

  // SRS Presence (client-side)
  // Avoid composite index requirements (e.g. where(srsIsActive==true) + orderBy(lastWrongAt)).
  // We'll filter fetched rows by srsPresence during the bounded overfetch loop.

  // Mastery filter (srsBucket) is applied client-side.
  // Avoid composite index requirements (e.g. where(srsBucket==X) + orderBy(lastWrongAt)).

  base.push(orderBy('lastWrongAt', 'desc'));
  if (cursor) base.push(startAfter(cursor));
  base.push(limit(pageSize));

  return {
    q: query(...base),
    // Anything not encoded in the query needs a client-side filter.
    needsClientTopicFilter: topics.length > 10,
    needsClientSubtopicFilter: (subs.length > 10) || (canUseSubtopicsIn && topicUsesIn) || (!topicUsesEq && subs.length > 0 && !canUseSubtopicsIn),
    needsClientMasteryFilter: masteryLevels.length > 0,
    needsClientSrsPresenceFilter: srsPresence !== 'all',
    topics,
    subs,
    masteryLevels,
  };
}

function matchesSrsPresence(row, srsPresence) {
  if (srsPresence === 'in_srs') return row?.srsIsActive === true;
  if (srsPresence === 'not_in_srs') return (row?.srsBucket || 'not_in_srs') === 'not_in_srs';
  return true;
}

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════
function calculateMasteryPriority(mistake, recentTopics = []) {
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));
  const U = Math.pow(2, daysSinceLastAttempt / 7);
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);
  let R = 0.5;
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5;
  }
  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

function getSrsBucket(card) {
  if (!card) return 'not_in_srs';
  if (card?.srsBucket) return card.srsBucket;
  if (card?.hasSrsCard === false) return 'not_in_srs';
  const looksLikeSrsCard =
    card?.hasSrsCard === true ||
    !!card?.status ||
    !!card?.nextReviewDate ||
    !!card?.questionId;
  if (!looksLikeSrsCard) return 'not_in_srs';
  if (card.isActive === false) return 'archived';
  if (card.status === 'new') return 'new';
  if (card.status === 'learning') return 'progressing';
  if (card.status === 'review') return 'near';
  if (card.status === 'graduated') return 'archived';
  return 'progressing';
}

function getSrsBucketState(bucket) {
  if (bucket === 'not_in_srs') return { state: 0, labelKey: 'notebook.masteryNotInSrs', color: 'slate' };
  if (bucket === 'new') return { state: 0, labelKey: 'notebook.masteryNew', color: 'red' };
  if (bucket === 'progressing') return { state: 1, labelKey: 'notebook.masteryDeveloping', color: 'amber' };
  if (bucket === 'near') return { state: 2, labelKey: 'notebook.masteryNear', color: 'yellow' };
  if (bucket === 'archived') return { state: 3, labelKey: 'notebook.mastered', color: 'green' };
  return { state: 3, labelKey: 'notebook.masteryMastered', color: 'green' };
}

function getSrsContributionWeight(card) {
  if (!card) return 1;
  if (card.isActive === false) return 0.1;
  if (card.status === 'graduated') return 0.1;
  const rep = Number(card.repetitionCount || 0);
  const byRep = 1 / (1 + rep);
  if (card.status === 'review') return Math.max(0.2, byRep);
  if (card.status === 'learning') return Math.max(0.35, byRep);
  return 1;
}

function calcPriority(mistake) {
  const last = mistake.lastAttempted || mistake.lastReviewedAt || mistake.createdAt;
  const days = last ? (Date.now() - new Date(last).getTime()) / (1000 * 60 * 60 * 24) : 0;
  const rep = mistake.repetitionCount ?? mistake.improvementCount ?? 0;
  return days * 1.2 - rep * 2;
}

function masteryStyle(improvementCount) {
  if (improvementCount >= 2)
    return {
      border: 'border-green-300',
      bg: 'bg-green-50/60',
      badge: 'bg-green-100 text-green-700',
      dot: 'bg-green-500',
    };
  if (improvementCount === 1)
    return {
      border: 'border-amber-300',
      bg: 'bg-amber-50/60',
      badge: 'bg-amber-100 text-amber-700',
      dot: 'bg-amber-400',
    };
  return {
    border: 'border-red-200',
    bg: 'bg-white',
    badge: 'bg-red-100 text-red-700',
    dot: 'bg-red-500',
  };
}

function applyRuleOfThree(improvements) {
  return improvements;
}

// ═══════════════════════════════════════════════════════════════════════════════
// SPACED REPETITION INTEGRATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Schedule spaced repetition events for new mistakes
 */
async function scheduleSpacedRepetitionForMistakes(mistakesList, currentUser) {
  if (!currentUser?.uid) return;

  return;

  try {
    // Only schedule for mistakes that are new or need review
    const mistakesToSchedule = mistakesList.filter(m => m.attemptCount >= 1);

    // Schedule in batches to avoid overwhelming Firebase
    for (const mistake of mistakesToSchedule) {
      try {
        await calendarService.scheduleSpacedRepetition(currentUser.uid, {
          questionId: mistake.ID,
          topic: mistake.Topic,
          subtopic: mistake.Subtopic,
          attemptCount: mistake.attemptCount
        });
      } catch (error) {
        console.error('Error scheduling repetition for', mistake.ID, error);
        // Continue with other mistakes even if one fails
      }
    }
  } catch (error) {
    console.error('Error scheduling spaced repetitions:', error);
  }
}

/**
 * Call this function when processing quiz results for real-time scheduling
 */
async function handleMistakeCommitted(currentUser, question, attemptCount) {
  if (!currentUser?.uid) return;

  return;
  
  try {
    await calendarService.scheduleSpacedRepetition(currentUser.uid, {
      questionId: question.ID,
      topic: question.Topic,
      subtopic: question.Subtopic,
      attemptCount
    });
  } catch (error) {
    console.error('Error scheduling spaced repetition:', error);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// UI COMPONENTS
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * FullQuestionModal: Pop-up to show complete question details
 */
function FullQuestionModal({ mistake, errorTag, onTag, onClose }) {
  const { t } = useLanguage();
  const [selectedTag, setSelectedTag] = useState(errorTag || '');

  const handleTagSelect = (tag) => {
    setSelectedTag(tag);
    onTag(mistake.ID, tag);
  };

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[100] p-4 overflow-y-auto">
      <motion.div 
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl my-6"
      >
        {/* Header */}
        <div className="bg-gradient-to-r from-slate-700 to-slate-900 p-4 sm:p-6 rounded-t-2xl flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-black text-white mb-1">{t('notebook.questionDetail')}</h2>
            <p className="text-slate-300 text-sm">{mistake.Topic} → {mistake.Subtopic}</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <X size={24} />
          </button>
        </div>

        <div className="p-4 sm:p-8 space-y-6 max-h-[70vh] overflow-y-auto">
          {/* Question */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.question')}
            </h3>
            <div
              className="prose prose-slate max-w-none text-base bg-slate-50 p-4 rounded-xl border-2 border-slate-200"
              dangerouslySetInnerHTML={{ __html: mistake.Question }}
            />
          </div>

          {/* Image if exists */}
          {mistake.Pictureurl && (
            <div className="flex justify-center">
              <img 
                src={mistake.Pictureurl} 
                alt={t('notebook.questionDiagramAlt')} 
                className="max-h-96 object-contain rounded-lg border-2 border-slate-200 shadow-md" 
              />
            </div>
          )}

          {/* Options Grid */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.options')}
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {['A', 'B', 'C', 'D'].map((opt) => {
                const isUserAnswer = mistake.userAnswer === opt;
                const isCorrect = mistake.CorrectOption === opt;
                
                return (
                  <div
                    key={opt}
                    className={`p-4 rounded-xl border-2 ${
                      isCorrect
                        ? 'border-green-500 bg-green-50'
                        : isUserAnswer
                        ? 'border-red-500 bg-red-50'
                        : 'border-slate-200 bg-white'
                    }`}
                  >
                    <div className="flex items-start gap-3">
                      <div className={`w-8 h-8 rounded-full flex items-center justify-center font-black text-sm flex-shrink-0 ${
                        isCorrect
                          ? 'bg-green-500 text-white'
                          : isUserAnswer
                          ? 'bg-red-500 text-white'
                          : 'bg-slate-200 text-slate-600'
                      }`}>
                        {opt}
                      </div>
                      <div className="flex-1">
                        {isCorrect && (
                          <div className="text-xs font-bold text-green-700 mb-1 flex items-center gap-1">
                            <CheckCircle size={12} /> {t('notebook.correctAnswer')}
                          </div>
                        )}
                        {isUserAnswer && !isCorrect && (
                          <div className="text-xs font-bold text-red-700 mb-1">
                            {t('notebook.yourAnswer')}
                          </div>
                        )}
                        <div className={`text-sm ${
                          isCorrect ? 'text-green-900 font-semibold' : isUserAnswer ? 'text-red-900' : 'text-slate-700'
                        }`}>
                          {mistake[`Option${opt}`] || opt}
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* Explanation */}
          {mistake.Explanation && (
            <div>
              <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3 flex items-center gap-2">
                <BookOpen size={16} className="text-blue-600" />
                {t('notebook.explanation')}
              </h3>
              <div
                className="prose prose-slate max-w-none text-sm bg-blue-50 p-4 rounded-xl border-2 border-blue-200"
                dangerouslySetInnerHTML={{ __html: mistake.Explanation }}
              />
            </div>
          )}

          {/* Error Type Tagging */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.tagErrorType')}
            </h3>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {ERROR_TYPES.map((type) => (
                <button
                  key={type.value}
                  onClick={() => handleTagSelect(type.value)}
                  className={`p-3 rounded-lg text-sm font-bold border-2 transition-all ${
                    selectedTag === type.value
                      ? `border-${type.color}-500 bg-${type.color}-50 text-${type.color}-700`
                      : 'border-slate-200 bg-white text-slate-600 hover:border-slate-300'
                  }`}
                >
                  <div className="flex items-center gap-2">
                    <div className={`w-3 h-3 rounded-full bg-${type.color}-500`} />
                    <span>{t(type.labelKey)}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>

          {/* Stats */}
          <div className="grid grid-cols-3 gap-4 pt-4 border-t border-slate-200">
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.attempts')}
              </div>
              <div className="text-2xl font-black text-slate-700">{mistake.attemptCount || 1}</div>
            </div>
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.masteryLevel')}
              </div>
              <div className="text-2xl font-black text-amber-600">{mistake.improvementCount || 0}/3</div>
            </div>
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.lastAttempted')}
              </div>
              <div className="text-sm font-bold text-slate-700">
                {new Date(mistake.lastAttempted).toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: 'short'
                })}
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </div>
  );
}



function InfoIconButton({ title, body, onOpenModal, hoverCapable }) {
  const [open, setOpen] = useState(false);

  const showTooltip = hoverCapable && open;

  return (
    <span
      className="relative inline-flex"
      onMouseEnter={() => hoverCapable && setOpen(true)}
      onMouseLeave={() => hoverCapable && setOpen(false)}
    >
      <button
        type="button"
        onClick={() => onOpenModal?.()}
        className="w-5 h-5 rounded-full border border-amber-300 bg-amber-50 text-amber-700 font-black text-[11px] leading-none flex items-center justify-center hover:bg-amber-100 transition-all"
        aria-label={title}
        title={hoverCapable ? title : undefined}
      >
        !
      </button>

      {showTooltip && (
        <div className="absolute left-0 top-full mt-2 w-64 max-w-[calc(100vw-2rem)] bg-white border border-slate-200 shadow-lg rounded-xl p-3 text-xs text-slate-700 z-[90] break-words">
          <div className="font-bold text-slate-800 mb-1 normal-case">{title}</div>
          <div className="text-slate-600 leading-relaxed normal-case">{body}</div>
        </div>
      )}
    </span>
  );
}

function FilterInfoModal({ onClose }) {
  const { t } = useLanguage();
  return (
    <div className="fixed inset-0 bg-black/60 z-[100] p-4 flex items-center justify-center">
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-white w-11/12 max-w-md max-h-[85vh] overflow-y-auto rounded-2xl shadow-xl border border-slate-200"
      >
        <div className="p-6">
          <div className="flex items-start justify-between gap-4">
            <div className="flex-1">
              <div className="text-lg font-bold text-slate-800 normal-case">
                {t('notebook.filterInfoTitle')}
              </div>
              <div className="text-sm text-slate-600 mt-2 leading-relaxed normal-case">
                {t('notebook.filterInfoBody')}
              </div>
            </div>
            <button
              type="button"
              onClick={onClose}
              className="px-3 py-2 rounded-lg bg-slate-100 text-slate-700 font-black hover:bg-slate-200 transition-all flex-shrink-0"
            >
              {t('notebook.close')}
            </button>
          </div>
        </div>
      </motion.div>
    </div>
  );
}

/**
 * ProgressSegments: 3-segment progress bar
 */
function ProgressSegments({ current, target = 3, size = 'sm' }) {
  const sizeClasses = {
    sm: 'h-2',
    md: 'h-3',
    lg: 'h-4',
  };
  
  return (
    <div className={`flex gap-1 ${sizeClasses[size]}`}>
      {Array.from({ length: target }).map((_, i) => (
        <div
          key={i}
          className={`flex-1 rounded-full transition-all duration-300 ${
            i < current
              ? 'bg-green-500 shadow-lg'
              : i === current
              ? 'bg-amber-400'
              : 'bg-slate-200'
          }`}
        />
      ))}
    </div>
  );
}

/**
 * TooltipWithPortal: Floating tooltip
 */
function TooltipWithPortal({ trigger, content, placement = 'top' }) {
  const [open, setOpen] = useState(false);
  
  const { refs, floatingStyles } = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    middleware: [offset(10), flip(), shift({ padding: 8 })],
    whileElementsMounted: autoUpdate
  });
  
  return (
    <>
      <div
        ref={refs.setReference}
        onMouseEnter={() => setOpen(true)}
        onMouseLeave={() => setOpen(false)}
        className="cursor-help"
      >
        {trigger}
      </div>
      
      {open && createPortal(
        <div
          ref={refs.setFloating}
          style={floatingStyles}
          className="z-[9999] bg-slate-900 text-white text-xs rounded-xl p-3 shadow-2xl ring-1 ring-white/10 max-w-xs pointer-events-none"
        >
          {content}
        </div>,
        document.body
      )}
    </>
  );
}

/**
 * InteractiveTopicHeatmap: Clickable topic density chart with multi-select
 */
function InteractiveTopicHeatmap({ mistakes, selectedTopics, onTopicToggle }) {
  const { t, tf } = useLanguage();
  
  const errorDensity = useMemo(() => {
    const topicMap = {};
    mistakes.forEach(m => {
      if (!topicMap[m.Topic]) {
        topicMap[m.Topic] = { attempted: 0, wrong: 0 };
      }
      topicMap[m.Topic].wrong++;
      topicMap[m.Topic].attempted += Math.max(m.attemptCount, 1);
    });
    
    return Object.entries(topicMap).map(([topic, data]) => ({
      topic,
      errorDensity: Math.min(1.0, data.wrong / Math.max(data.attempted, 1)),
      wrongCount: data.wrong,
      attemptedCount: data.attempted
    })).sort((a, b) => b.errorDensity - a.errorDensity);
  }, [mistakes]);
  
  const getColor = (density, isSelected) => {
    const base = density < 0.2 ? 'yellow' 
      : density < 0.4 ? 'orange' 
      : density < 0.6 ? 'orange' 
      : density < 0.8 ? 'red'
      : 'red';
    
    if (isSelected) {
      return `from-${base}-600 to-${base}-700 text-white ring-2 ring-${base}-400 ring-offset-2`;
    }
    
    if (density < 0.2) return 'from-yellow-100 to-yellow-200 text-yellow-900 hover:from-yellow-200 hover:to-yellow-300';
    if (density < 0.4) return 'from-orange-200 to-orange-300 text-orange-900 hover:from-orange-300 hover:to-orange-400';
    if (density < 0.6) return 'from-orange-400 to-orange-500 text-white hover:from-orange-500 hover:to-orange-600';
    if (density < 0.8) return 'from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700';
    return 'from-red-700 to-red-800 text-white hover:from-red-800 hover:to-red-900';
  };
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-2 flex items-center gap-2">
        <BarChart2 size={20} className="text-orange-600" />
        {t('notebook.errorDensityByTopic')}
      </h3>
      <p className="text-xs text-slate-500 mb-4">
        {t('notebook.clickTopicsToFilter')} • {selectedTopics.length > 0 && tf('notebook.selectedCount', { count: selectedTopics.length })}
      </p>
      
      <div className="space-y-3">
        {errorDensity.map(({ topic, errorDensity: density, wrongCount, attemptedCount }) => {
          const isSelected = selectedTopics.includes(topic);
          return (
            <button
              key={topic}
              onClick={() => onTopicToggle(topic)}
              className={`w-full flex items-center gap-4 p-4 rounded-lg bg-gradient-to-r transition-all transform hover:scale-105 active:scale-95 cursor-pointer ${getColor(density, isSelected)}`}
            >
              <div className="w-24 sm:w-32 font-semibold text-sm text-left truncate flex items-center gap-2">
                {isSelected && <Check size={14} />}
                {topic}
              </div>
              <div className="flex-1 text-right font-bold text-sm">
                {(density * 100).toFixed(0)}% ({wrongCount}/{attemptedCount})
              </div>
              <ChevronRight size={16} />
            </button>
          );
        })}
      </div>
      
      {selectedTopics.length > 0 && (
        <button
          onClick={() => selectedTopics.forEach(onTopicToggle)}
          className="mt-4 w-full py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-bold transition-all"
        >
          {t('notebook.clearSelection')}
        </button>
      )}
    </div>
  );
}
/**
 * CalendarHeatmap: 30-day activity visualization
 */
function CalendarHeatmap({ attempts }) {
  const { t, tf } = useLanguage();
  
  const activityMap = useMemo(() => {
    const map = {};
    const now = new Date();
    
    for (let i = 0; i < 30; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split('T')[0];
      map[dateStr] = 0;
    }
    
    (attempts || []).forEach(a => {
      if (!a?.wasCorrect) return;
      const dateStr = a.attemptedAt ? new Date(a.attemptedAt).toISOString().split('T')[0] : null;
      if (dateStr && map[dateStr] !== undefined) map[dateStr]++;
    });
    
    return map;
  }, [attempts]);
  
  const days = Object.entries(activityMap).reverse();
  const maxActivity = Math.max(...Object.values(activityMap), 1);
  
  const getColor = (count) => {
    const intensity = count / maxActivity;
    if (intensity === 0) return 'bg-slate-100';
    if (intensity < 0.33) return 'bg-blue-200';
    if (intensity < 0.67) return 'bg-blue-400';
    return 'bg-blue-600';
  };
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <Calendar size={20} className="text-blue-600" />
        {t('notebook.mistakeClearingActivity')}
      </h3>
      
      <div className="grid grid-cols-7 gap-1">
        {[
          t('notebook.weekdaySunShort'),
          t('notebook.weekdayMonShort'),
          t('notebook.weekdayTueShort'),
          t('notebook.weekdayWedShort'),
          t('notebook.weekdayThuShort'),
          t('notebook.weekdayFriShort'),
          t('notebook.weekdaySatShort'),
        ].map((day, idx) => (
          <div key={`header-${idx}`} className="text-center text-xs font-bold text-slate-400 h-6">
            {day}
          </div>
        ))}
        
        {days.map(([dateStr, count]) => (
          <TooltipWithPortal
            key={dateStr}
            trigger={
              <div
                className={`w-8 h-8 rounded ${getColor(count)} flex items-center justify-center text-xs font-bold text-slate-700 hover:ring-2 ring-blue-400 transition-all cursor-pointer`}
              >
                {count > 0 && count}
              </div>
            }
            content={tf('notebook.activityTooltipCleared', { date: dateStr, count })}
          />
        ))}
      </div>
      
      <div className="flex items-center gap-2 mt-4 text-xs text-slate-500">
        <span>{t('notebook.less')}</span>
        <div className="flex gap-1">
          {[0, 0.33, 0.67, 1.0].map((i, idx) => (
            <div key={idx} className={`w-3 h-3 rounded ${getColor(i * maxActivity)}`} />
          ))}
        </div>
        <span>{t('notebook.more')}</span>
      </div>
    </div>
  );
}

/**
 * ImprovementTrendChart: 14-day mastery progression
 */
function ImprovementTrendChart({ cards, attempts }) {
  const { t } = useLanguage();
  
  const trendData = useMemo(() => {
    const now = new Date();
    const days = [];
    for (let i = 13; i >= 0; i--) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      days.push(d.toISOString().split('T')[0]);
    }

    const snapshotByDay = Object.fromEntries(days.map(d => [d, { New: 0, Developing: 0, 'Near-Mastery': 0, Mastered: 0 }]));

    // Baseline: today counts from current cards
    const today = days[days.length - 1];
    (cards || []).forEach(c => {
      const bucket = getSrsBucket(c);
      if (bucket === 'archived') snapshotByDay[today].Mastered++;
      else if (bucket === 'new') snapshotByDay[today].New++;
      else if (bucket === 'progressing') snapshotByDay[today].Developing++;
      else snapshotByDay[today]['Near-Mastery']++;
    });

    // For each attempt day, count stateAfter.status transitions as a lightweight trend signal
    (attempts || []).forEach(a => {
      const dateStr = a.attemptedAt ? new Date(a.attemptedAt).toISOString().split('T')[0] : null;
      if (!dateStr || !snapshotByDay[dateStr]) return;
      const s = a.stateAfter?.status;
      if (s === 'graduated') snapshotByDay[dateStr].Mastered++;
      else if (s === 'new') snapshotByDay[dateStr].New++;
      else if (s === 'learning') snapshotByDay[dateStr].Developing++;
      else if (s === 'review') snapshotByDay[dateStr]['Near-Mastery']++;
    });

    return days.map(d => ({ date: d, ...snapshotByDay[d] }));
  }, [cards, attempts]);
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <TrendingUp size={20} className="text-purple-600" />
        {t('notebook.improvementTrend')}
      </h3>
      
      <ResponsiveContainer width="100%" height={300}>
        <AreaChart data={trendData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Area type="monotone" dataKey="New" name={t('notebook.masteryNew')} stackId="1" stroke="#ef4444" fill="#fecaca" />
          <Area type="monotone" dataKey="Developing" name={t('notebook.masteryDeveloping')} stackId="1" stroke="#f59e0b" fill="#fed7aa" />
          <Area type="monotone" dataKey="Near-Mastery" name={t('notebook.masteryNear')} stackId="1" stroke="#eab308" fill="#fef08a" />
          <Area type="monotone" dataKey="Mastered" name={t('notebook.masteryMastered')} stackId="1" stroke="#22c55e" fill="#bbf7d0" />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}

/**
 * RetentionDashboard: Learning metrics overview
 */
function RetentionDashboard({ cards = [], attempts = [] }) {
  const { t, tf } = useLanguage();
  const [open, setOpen] = useState(true);
  
  const stats = useMemo(() => {
    const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const addedThisWeek = (cards || []).filter((c) => {
      const ts = c.createdAt ? new Date(c.createdAt).getTime() : 0;
      return ts >= weekAgo;
    }).length;

    const masteredThisWeek = (attempts || []).filter((a) => {
      const ts = a.attemptedAt ? new Date(a.attemptedAt).getTime() : 0;
      return ts >= weekAgo && a?.stateAfter?.status === 'graduated';
    }).length;
    
    const subtopicMap = {};
    (cards || []).filter(c => c.isActive !== false).forEach((c) => {
      const key = c.subtopic || 'Unknown';
      if (!subtopicMap[key]) subtopicMap[key] = { count: 0, repeats: 0 };
      subtopicMap[key].count++;
      if ((c.failedAttempts || 0) > 0) subtopicMap[key].repeats++;
    });
    
    const weakest = Object.entries(subtopicMap)
      .sort((a, b) => b[1].count + b[1].repeats * 2 - (a[1].count + a[1].repeats * 2))
      .slice(0, 6);
    
    return { addedThisWeek, masteredThisWeek, weakest };
  }, [cards, attempts]);
  
  const decayLabel =
    stats.addedThisWeek === 0 && stats.masteredThisWeek === 0
      ? '—'
      : stats.masteredThisWeek > stats.addedThisWeek
      ? t('notebook.decayImproving')
      : stats.masteredThisWeek === stats.addedThisWeek
      ? t('notebook.decayStable')
      : t('notebook.decayGrowing');
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden">
      <button
        onClick={() => setOpen((o) => !o)}
        className="w-full flex items-center justify-between p-5 hover:bg-slate-50 transition-all"
      >
        <div className="flex items-center gap-2">
          <Activity className="text-purple-600" size={20} />
          <span className="font-bold text-slate-800 text-lg">{t('notebook.retentionDashboard')}</span>
        </div>
        <ChevronDown
          size={20}
          className={`text-slate-400 transition-transform ${open ? 'rotate-180' : ''}`}
        />
      </button>
      
      <AnimatePresence>
        {open && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="border-t border-slate-200 overflow-hidden"
          >
            <div className="p-6 space-y-6 bg-slate-50">
              <div className="grid grid-cols-3 gap-4">
                <div className="bg-white rounded-xl p-4 border-2 border-slate-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.addedThisWeek')}
                  </div>
                  <div className="text-3xl font-black text-red-500">{stats.addedThisWeek}</div>
                </div>
                <div className="bg-white rounded-xl p-4 border-2 border-slate-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.masteredThisWeek')}
                  </div>
                  <div className="text-3xl font-black text-green-600">{stats.masteredThisWeek}</div>
                </div>
                <div className="bg-white rounded-xl p-4 border-2 border-purple-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.decayRate')}
                  </div>
                  <div className="text-lg font-black text-purple-700 mt-1">{decayLabel}</div>
                </div>
              </div>
              
              <div>
                <h3 className="text-sm font-black text-slate-600 uppercase tracking-widest mb-3 flex items-center gap-2">
                  <Flame size={14} className="text-red-500" />
                  {t('notebook.weakestSubtopics')}
                </h3>
                <div className="space-y-2">
                  {stats.weakest.map(([subtopic, data]) => {
                    const max = stats.weakest[0][1].count + stats.weakest[0][1].repeats * 2;
                    const score = data.count + data.repeats * 2;
                    const pct = max > 0 ? (score / max) * 100 : 0;
                    return (
                      <div key={subtopic} className="flex items-center gap-3">
                        <div className="w-32 text-xs text-slate-600 font-semibold truncate shrink-0">
                          {subtopic}
                        </div>
                        <div className="flex-1 bg-slate-200 rounded-full h-2">
                          <div
                            className="bg-gradient-to-r from-red-400 to-orange-400 h-2 rounded-full transition-all"
                            style={{ width: `${pct}%` }}
                          />
                        </div>
                        <div className="text-xs text-slate-500 shrink-0 w-8 text-right">
                          {data.count}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

/**
 * LIST VIEW: Compact expandable rows
 */
function ListViewDeck({ mistakes, errorTags, onTag, selectedIds, onToggleSelect, onToggleSelectAll, allSelected, onViewFull, moreHint, totalCount }) {
  const { t } = useLanguage();
  const [expandedId, setExpandedId] = useState(null);
  const selectedVisibleCount = (mistakes || []).reduce(
    (acc, m) => (selectedIds.has(m.ID) ? acc + 1 : acc),
    0
  );

  const denom = Number.isFinite(Number(totalCount)) && Number(totalCount) > 0
    ? Number(totalCount)
    : (mistakes?.length || 0);
  
  return (
    <div className="space-y-2">
      {/* Select All */}
      <div className="flex items-center gap-2 p-3 bg-slate-50 rounded-lg border border-slate-200">
        <input
          type="checkbox"
          checked={allSelected}
          onChange={onToggleSelectAll}
          className="w-4 h-4 rounded cursor-pointer"
        />
        <span className="text-sm font-bold text-slate-700">
          {t('notebook.selectAll')} ({selectedVisibleCount}/{denom})
          {moreHint ? <span className="text-slate-500 font-semibold"> {moreHint}</span> : null}
        </span>
      </div>
      
      {/* Mistake Rows */}
      <AnimatePresence>
        {mistakes.map((mistake) => {
          const style = masteryStyle(mistake.improvementCount ?? 0);
          const priority = calcPriority(mistake);
          const isExpanded = expandedId === mistake.ID;
          const isSelected = selectedIds.has(mistake.ID);
          const isUrgent = priority > 15;
          const reactKey = mistake?.docId ?? mistake?.ID;
          
          return (
            <motion.div
              key={reactKey}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className={`rounded-lg border-2 transition-all ${style.border} ${style.bg} ${
                isUrgent ? 'ring-2 ring-red-400' : ''
              }`}
            >
              {/* Row Header */}
              <div className="flex items-center gap-3 p-4">
                <input
                  type="checkbox"
                  checked={isSelected}
                  onChange={() => onToggleSelect(mistake.ID)}
                  className="w-4 h-4 rounded cursor-pointer"
                />
                <button
                  onClick={() => setExpandedId(isExpanded ? null : mistake.ID)}
                  className="flex-1 flex items-center justify-between hover:bg-white/50 p-2 rounded-lg transition-all"
                >
                  <div className="flex items-center gap-3 flex-1">
                    <div className="w-10 h-10 rounded bg-slate-200 flex items-center justify-center text-xs font-bold text-slate-600">
                      {mistake.Topic.slice(0, 2)}
                    </div>
                    <div className="text-left min-w-0 flex-1">
                      <div className="text-xs font-bold text-slate-600">
                        {mistake.Topic} → {mistake.Subtopic}
                      </div>
                      <div className="text-sm text-slate-800 font-semibold truncate">
                        {mistake.Question?.replace(/<[^>]*>/g, '').substring(0, 60)}...
                      </div>
                    </div>
                  </div>
                  <div className="flex items-center gap-2 shrink-0">
                    <div className="w-24">
                      <ProgressSegments current={mistake.improvementCount ?? 0} target={3} size="sm" />
                    </div>
                    <span className={`text-xs font-black px-2 py-1 rounded-full ${
                      isUrgent ? 'bg-red-100 text-red-700' : 'bg-slate-100 text-slate-600'
                    }`}>
                      {priority.toFixed(1)}
                    </span>
                    <ChevronRight size={16} className={`transition-transform ${isExpanded ? 'rotate-90' : ''}`} />
                  </div>
                </button>
                <button
                  onClick={() => onViewFull(mistake)}
                  className="p-2 bg-indigo-100 text-indigo-700 rounded-lg hover:bg-indigo-200 transition-all"
                  title={t('notebook.viewFullQuestion')}
                >
                  <Maximize2 size={18} />
                </button>
              </div>
              
              {/* Expanded Content */}
              <AnimatePresence>
                {isExpanded && (
                  <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="overflow-hidden"
                  >
                    <div className="p-4 border-t border-slate-300 space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        <div className="p-3 rounded-lg bg-red-50 border border-red-200">
                          <div className="text-xs font-bold text-red-700 mb-1">{t('notebook.yourAnswer')}</div>
                          <div className="text-sm font-semibold text-red-900">{mistake.userAnswer}</div>
                        </div>
                        <div className="p-3 rounded-lg bg-green-50 border border-green-200">
                          <div className="text-xs font-bold text-green-700 mb-1">{t('notebook.correctAnswer')}</div>
                          <div className="text-sm font-semibold text-green-900">{mistake.CorrectOption}</div>
                        </div>
                      </div>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </motion.div>
          );
        })}
      </AnimatePresence>
    </div>
  );
}

/**
 * KANBAN VIEW: 3-column layout (New, Developing, Near-Mastery)
 */
function KanbanViewDeck({ columns, errorTags, onTag, onViewFull }) {
  const { t } = useLanguage();
  const [expandedId, setExpandedId] = useState(null);
  
  const columnConfig = {
    new: { label: t('notebook.masteryNew'), color: 'red', icon: AlertTriangle, gradient: 'from-red-50 to-red-100', border: 'border-red-300' },
    progressing: { label: t('notebook.masteryDeveloping'), color: 'amber', icon: Flame, gradient: 'from-amber-50 to-amber-100', border: 'border-amber-300' },
    near: { label: t('notebook.masteryNear'), color: 'green', icon: Star, gradient: 'from-green-50 to-green-100', border: 'border-green-300' },
  };
  
  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 h-full">
      {Object.entries(columns).map(([key, mistakes]) => {
        const config = columnConfig[key];
        
        return (
          <motion.div
            key={key}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.3 }}
            className={`rounded-2xl border-2 ${config.border} bg-gradient-to-b ${config.gradient} p-4 flex flex-col`}
          >
            {/* Column Header */}
            <div className="mb-4 pb-3 border-b-2 border-slate-300">
              <h3 className="font-black text-lg text-slate-800 flex items-center gap-2">
                <config.icon size={20} className={`text-${config.color}-600`} />
                {config.label} ({mistakes.length})
              </h3>
            </div>
            
            {/* Column Cards */}
            <div className="flex-1 overflow-y-auto space-y-3 pr-2">
              {mistakes.length === 0 ? (
                <div className="text-center py-8">
                  <CheckCircle size={32} className={`text-${config.color}-300 mx-auto mb-2`} />
                  <p className={`text-xs font-bold text-${config.color}-700`}>
                    {t('notebook.allCaughtUp')}
                  </p>
                </div>
              ) : (
                <AnimatePresence>
                  {mistakes.map((mistake) => {
                    const priority = calcPriority(mistake);
                    const isUrgent = priority > 15;
                    const reactKey = mistake?.docId ?? mistake?.ID;
                    
                    return (
                      <motion.div
                        key={reactKey}
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.9 }}
                        className={`bg-white rounded-xl p-4 shadow-md border-2 border-slate-200 hover:shadow-lg transition-all ${
                          isUrgent ? 'ring-2 ring-red-400' : ''
                        }`}
                      >
                        {/* Card Header */}
                        <div className="mb-3">
                          <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mb-1">
                            {mistake.Topic}
                          </div>
                          <div className="text-sm font-bold text-slate-800 line-clamp-2">
                            {mistake.Question?.replace(/<[^>]*>/g, '').substring(0, 80)}...
                          </div>
                        </div>
                        
                        {/* Progress Bar */}
                        <div className="mb-3">
                          <ProgressSegments current={mistake.improvementCount ?? 0} target={3} size="md" />
                        </div>
                        
                        {/* Priority Badge */}
                        <div className={`inline-block text-xs font-black px-2 py-1 rounded-full mb-3 ${
                          isUrgent
                            ? 'bg-red-100 text-red-700'
                            : priority > 7
                            ? 'bg-amber-100 text-amber-700'
                            : 'bg-slate-100 text-slate-600'
                        }`}>
                          {t('notebook.priority')}: {priority.toFixed(1)}
                        </div>
                        
                        {/* View Full Button */}
                        <button
                          onClick={() => onViewFull(mistake)}
                          className="w-full py-2 bg-indigo-600 text-white rounded-lg font-bold text-sm hover:bg-indigo-700 transition-all flex items-center justify-center gap-2"
                        >
                          <Maximize2 size={14} />
                          {t('notebook.viewFull')}
                        </button>
                      </motion.div>
                    );
                  })}
                </AnimatePresence>
              )}
            </div>
          </motion.div>
        );
      })}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN COMPONENT
// ═══════════════════════════════════════════════════════════════════════════════
export default function MistakeNotebookPage({ questions = [] }) {
  const { currentUser } = useAuth();
  const { t, tf } = useLanguage();
  const navigate = useNavigate();
  
  // Core state
  const [mistakes, setMistakes] = useState([]);
  const [totalMistakesCount, setTotalMistakesCount] = useState(null);
  const [masteryCounts, setMasteryCounts] = useState({});
  const [srsBackfillTick, setSrsBackfillTick] = useState(0);
  const [facetMistakeRows, setFacetMistakeRows] = useState([]);
  const [topicStatsDoc, setTopicStatsDoc] = useState(null);
  const [topicCountOverrides, setTopicCountOverrides] = useState({});
  const [multiTopicOverrideCount, setMultiTopicOverrideCount] = useState(null);
  const [rebuildingTopicStats, setRebuildingTopicStats] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [srsCards, setSrsCards] = useState([]);
  const [reviewAttempts, setReviewAttempts] = useState([]);
  const [mistakeIndexRows, setMistakeIndexRows] = useState([]);
  const [mistakeIndexHasMore, setMistakeIndexHasMore] = useState(false);
  const [mistakeIndexCursor, setMistakeIndexCursor] = useState(null);
  const [loadingMoreMistakes, setLoadingMoreMistakes] = useState(false);
  const [errorTags, setErrorTags] = useState(() =>
    JSON.parse(localStorage.getItem('mistake_error_tags') || '{}')
  );
  const [recentQuizTopics, setRecentQuizTopics] = useState(() =>
    JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]')
  );
  const [archivedMistakes, setArchivedMistakes] = useState({});
  
  // Filter state
  const [questionCount, setQuestionCount] = useState('10');
  const [datePeriod, setDatePeriod] = useState('all');
  const [selectedTopics, setSelectedTopics] = useState([]);
  const [selectedSubtopics, setSelectedSubtopics] = useState([]);
  const [selectedMasteryLevels, setSelectedMasteryLevels] = useState([]);
  const [srsPresence, setSrsPresence] = useState('all');
  
  // Timer settings
  const [timerEnabled, setTimerEnabled] = useState(true);
  const [isTimedMode, setIsTimedMode] = useState(false);
  
  // UI state
  const [activeTab, setActiveTab] = useState('analytics');
  const [archiveSubTab, setArchiveSubTab] = useState('mastery');
  const [hoverCapable, setHoverCapable] = useState(true);
  const [viewMode, setViewMode] = useState('list');
  const [selectedMistakeIds, setSelectedMistakeIds] = useState(new Set());
  const [fullViewMistake, setFullViewMistake] = useState(null);
  const [showInfoModal, setShowInfoModal] = useState(false);
  const [showHelpPanel, setShowHelpPanel] = useState(false);
  const [filterInfoOpen, setFilterInfoOpen] = useState(false);
  const [archivedLoaded, setArchivedLoaded] = useState(false);
  
  // Load data
  useEffect(() => { loadMistakes(); }, [currentUser]);

  const refreshTopicStatsDoc = useCallback(async () => {
    if (!currentUser?.uid) return;
    try {
      const ref = doc(db, 'users', currentUser.uid, 'mistake_stats', 'topicBuckets');
      const snap = await getDoc(ref);
      setTopicStatsDoc(snap.exists() ? (snap.data() || {}) : null);
    } catch (e) {
      console.error('Error loading topic stats doc:', e);
      setTopicStatsDoc(null);
    }
  }, [currentUser?.uid]);

  const handleRebuildTopicStats = useCallback(async () => {
    if (!currentUser?.uid) return;
    if (rebuildingTopicStats) return;
    try {
      setRebuildingTopicStats(true);
      const { getFunctions, httpsCallable } = await import('firebase/functions');
      const functions = getFunctions(app, 'asia-east1');
      const callable = httpsCallable(functions, 'rebuildMistakeTopicStats');
      await callable({});
      await refreshTopicStatsDoc();
    } catch (e) {
      console.error('rebuildMistakeTopicStats failed:', e);
    } finally {
      setRebuildingTopicStats(false);
    }
  }, [currentUser?.uid, rebuildingTopicStats, refreshTopicStatsDoc]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setTopicStatsDoc(null);
      return;
    }
    refreshTopicStatsDoc();
  }, [currentUser?.uid]);

  useEffect(() => {
    if (!currentUser?.uid) return;
    if (datePeriod !== 'all') return;
    if (selectedTopics.length !== 1) return;
    if (selectedSubtopics.length > 0) return;
    if (selectedMasteryLevels.length > 0) return;
    if (srsPresence !== 'all') return;

    const topic = selectedTopics[0];
    const run = async () => {
      try {
        const snap = await getCountFromServer(
          query(
            collection(db, 'users', currentUser.uid, 'mistakes'),
            where('Topic', '==', topic)
          )
        );
        const count = Number(snap.data().count || 0);
        setTopicCountOverrides((prev) => ({
          ...prev,
          [String(topic)]: Number.isFinite(count) ? count : 0,
        }));
      } catch (e) {
        console.error('Error counting mistakes for topic override:', e);
      }
    };

    run();
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, srsBackfillTick]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (datePeriod !== 'all') {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (selectedSubtopics.length > 0) {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (selectedMasteryLevels.length > 0) {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (srsPresence !== 'all') {
      setMultiTopicOverrideCount(null);
      return;
    }

    const topics = (Array.isArray(selectedTopics) ? selectedTopics : []).filter(Boolean);
    if (topics.length < 2 || topics.length > 10) {
      setMultiTopicOverrideCount(null);
      return;
    }

    const run = async () => {
      try {
        const snap = await getCountFromServer(
          query(
            collection(db, 'users', currentUser.uid, 'mistakes'),
            where('Topic', 'in', topics)
          )
        );
        const count = Number(snap.data().count || 0);
        setMultiTopicOverrideCount(Number.isFinite(count) ? count : null);
      } catch (e) {
        console.error('Error counting mistakes for multi-topic override:', e);
        setMultiTopicOverrideCount(null);
      }
    };

    run();
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, srsBackfillTick]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setTotalMistakesCount(null);
      return;
    }

    const run = async () => {
      try {
        const now = getNow();
        const weekAgo = new Date(now);
        weekAgo.setDate(weekAgo.getDate() - 7);
        const monthAgo = new Date(now);
        monthAgo.setMonth(monthAgo.getMonth() - 1);

        const base = [collection(db, 'users', currentUser.uid, 'mistakes')];
        if (datePeriod === 'week') {
          base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
        } else if (datePeriod === 'month') {
          base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
        }

        const snap = await getCountFromServer(query(...base));
        setTotalMistakesCount(Number(snap.data().count || 0));
      } catch (e) {
        console.error('Error counting total mistakes:', e);
        setTotalMistakesCount(null);
      }
    };

    run();
  }, [currentUser, datePeriod]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setMasteryCounts({});
      return;
    }

    const run = async () => {
      try {
        const built = buildMistakeCountBaseConstraints({
          userId: currentUser.uid,
          datePeriod,
          selectedTopics,
          selectedSubtopics,
          srsPresence,
        });

        if (
          (built.needsClientTopicFilter && built.topics.length > 0) ||
          (built.needsClientSubtopicFilter && built.subs.length > 0) ||
          (srsPresence !== 'all') ||
          (built.topics.length > 0)
        ) {
          setMasteryCounts({});
          return;
        }

        const entries = await Promise.all(
          Object.keys(MASTERY_LEVELS).map(async (bucket) => {
            const parts = [...built.base, where('srsBucket', '==', bucket)];
            if (srsPresence === 'in_srs') {
              parts.push(where('srsIsActive', '==', true));
            }
            const snap = await getCountFromServer(query(...parts));
            return [bucket, Number(snap.data().count || 0)];
          })
        );

        const nextCounts = Object.fromEntries(entries);

        const sum = Object.values(nextCounts).reduce((a, b) => a + Number(b || 0), 0);
        // If user clearly has mistakes but none of the docs have srsBucket yet,
        // counts will be 0 across the board. In that case, keep fallback UI counts.
        if (sum === 0 && Number(totalMistakesCount || 0) > 0) {
          setMasteryCounts({});
        } else {
          setMasteryCounts(nextCounts);
        }
      } catch (e) {
        console.error('Error counting mastery buckets:', e);
        setMasteryCounts({});
      }
    };

    run();
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, srsBackfillTick, totalMistakesCount]);

  useEffect(() => {
    if (!currentUser) return;
    loadFacetMistakes();
  }, [currentUser, datePeriod]);

  // Reset pagination when date filter changes
  useEffect(() => {
    setMistakeIndexRows([]);
    setMistakeIndexHasMore(false);
    setMistakeIndexCursor(null);
    if (currentUser) loadMistakes();
  }, [datePeriod]);

  // Reset pagination when topic/subtopic filters change (server-side filtered query)
  useEffect(() => {
    setMistakeIndexRows([]);
    setMistakeIndexHasMore(false);
    setMistakeIndexCursor(null);
    if (currentUser) loadMistakes();
  }, [selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence]);

  // Lazy-load archived cards only when Archive tab is opened
  useEffect(() => {
    if (!currentUser) return;
    if (activeTab !== 'archive') return;
    if (archivedLoaded) return;

    const loadArchived = async () => {
      try {
        const questionMap = new Map((questions || []).map(q => [q.ID, q]));
        const archivedCards = await srsService.getArchivedCards(currentUser.uid);
        const archivedByQuestionId = {};

        (archivedCards || []).forEach((c) => {
          const questionData = questionMap.get(c.questionId) || {};
          archivedByQuestionId[c.questionId] = {
            ...c,
            ...questionData,
            ID: c.questionId,
            archivedAt: c.archivedAt,
            archiveReason: c.archiveReason || 'unknown'
          };
        });

        setArchivedMistakes(archivedByQuestionId);
        setArchivedLoaded(true);
      } catch (e) {
        console.error('Error loading archived cards:', e);
      }
    };

    loadArchived();
  }, [activeTab, archivedLoaded, currentUser, questions]);

  useEffect(() => {
    if (activeTab !== 'archive') return;
    setArchiveSubTab('mastery');
  }, [activeTab]);
  
  // Auto-archive overdue cards older than 14 days
  useEffect(() => {
    if (!currentUser) return;

    const runArchive = async () => {
      try {
        const archivedCount = await srsService.archiveOverdueCards(currentUser.uid);
        if (archivedCount > 0) {
          console.log(`🗄️ Auto-archived ${archivedCount} overdue cards`);
          // Reload data to refresh the archive
          loadMistakes();
        }
      } catch (error) {
        console.error('Error auto-archiving overdue cards:', error);
      }
    };

    runArchive();
  }, [currentUser]);
  
  async function loadMistakes() {
    if (!currentUser) { setLoading(false); return; }
    try {
      setLoading(true);
      setError(null);

      backfillMistakeSrsFromActiveCards(currentUser.uid)
        .then((didWrite) => {
          if (didWrite) setSrsBackfillTick((x) => x + 1);
        })
        .catch((e) => console.error('Active-card backfill failed:', e));

      const [srsAttempts, dueCards] = await Promise.all([
        srsService.getRecentReviewAttempts(currentUser.uid, 30),
        srsService.getDueCards(currentUser.uid, getNow(), { limit: 200 })
      ]);

      const now = getNow();
      const weekAgo = new Date(now);
      weekAgo.setDate(weekAgo.getDate() - 7);
      const monthAgo = new Date(now);
      monthAgo.setMonth(monthAgo.getMonth() - 1);

      const pageSize = 40;
      const firstBuilt = buildMistakeIndexQueryConstraints({
        userId: currentUser.uid,
        datePeriod,
        selectedTopics,
        selectedSubtopics,
        selectedMasteryLevels,
        srsPresence,
        cursor: null,
        pageSize,
      });

      let rows = [];
      let cursor = null;
      let hasMore = false;

      const needsClientFiltering =
        (firstBuilt.needsClientTopicFilter && firstBuilt.topics.length > 0) ||
        (firstBuilt.needsClientSubtopicFilter && firstBuilt.subs.length > 0) ||
        (firstBuilt.needsClientMasteryFilter && firstBuilt.masteryLevels.length > 0) ||
        firstBuilt.needsClientSrsPresenceFilter;

      if (!needsClientFiltering) {
        const snap = await getDocs(firstBuilt.q);
        rows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));
        cursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : null;
        hasMore = snap.docs.length === pageSize;
      } else {
        // If we must filter client-side, a single Firestore page can miss matches.
        // Over-fetch a bounded number of pages until we have enough matching rows.
        const maxPages = 6;
        let pagesFetched = 0;
        let fetchCursor = null;
        let lastSnapSize = 0;
        const topics = firstBuilt.topics;
        const subs = firstBuilt.subs;
        const masteryLevels = firstBuilt.masteryLevels;

        while (pagesFetched < maxPages && rows.length < pageSize) {
          const built = buildMistakeIndexQueryConstraints({
            userId: currentUser.uid,
            datePeriod,
            selectedTopics,
            selectedSubtopics,
            selectedMasteryLevels,
            srsPresence,
            cursor: fetchCursor,
            pageSize,
          });

          const snap = await getDocs(built.q);
          lastSnapSize = snap.docs.length;
          let pageRows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));

          if (built.needsClientTopicFilter && topics.length > 0) {
            pageRows = pageRows.filter((r) => topics.includes(r?.Topic ?? r?.topic));
          }
          if (built.needsClientSubtopicFilter && subs.length > 0) {
            pageRows = pageRows.filter((r) => subs.includes(r?.Subtopic ?? r?.subtopic));
          }
          if (built.needsClientMasteryFilter && masteryLevels.length > 0) {
            pageRows = pageRows.filter((r) => masteryLevels.includes(r.srsBucket || 'not_in_srs'));
          }
          if (built.needsClientSrsPresenceFilter) {
            pageRows = pageRows.filter((r) => matchesSrsPresence(r, srsPresence));
          }

          rows.push(...pageRows);

          fetchCursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : fetchCursor;
          pagesFetched += 1;

          if (lastSnapSize < pageSize) {
            break;
          }
        }

        cursor = fetchCursor;
        hasMore = lastSnapSize === pageSize;
        rows = rows.slice(0, pageSize);
      }

      if (await backfillMistakeSrsDefaults(currentUser.uid, rows)) {
        setSrsBackfillTick((x) => x + 1);
      }

      setMistakeIndexRows(rows);
      setMistakeIndexCursor(cursor);
      setMistakeIndexHasMore(hasMore);

      setReviewAttempts(srsAttempts);

      const questionMap = new Map((questions || []).map(q => [q.ID, q]));
      const dueByQuestionId = new Map((dueCards || []).map((c) => [String(c.questionId), c]));

      const deckAll = (rows || [])
        .map((row) => {
          const qid = row?.questionId ?? row?.ID ?? row?.docId ?? row?.id;
          const questionId = qid ? String(qid) : null;
          if (!questionId) return null;

          const q = questionMap.get(Number.isFinite(Number(questionId)) ? Number(questionId) : questionId) || questionMap.get(questionId);
          const dueCard = dueByQuestionId.get(questionId);

          return {
            ...(q || {}),
            ...row,
            ID: q?.ID ?? row?.ID ?? questionId,
            questionId,
            Topic: q?.Topic ?? row?.Topic ?? null,
            Subtopic: q?.Subtopic ?? row?.Subtopic ?? null,
            attemptCount: Number(row?.attemptCount || 0),
            lastAttempted: row?.lastAttempted || row?.lastWrongAt || row?.updatedAt || null,
            userAnswer: row?.lastUserAnswer ?? null,
            ...(dueCard || {}),
            // From mistake index denormalization
            hasSrsCard: row?.hasSrsCard === true,
            srsIsActive: row?.srsIsActive === true,
            srsStatus: row?.srsStatus ?? null,
            srsBucket: row?.srsBucket ?? (row?.hasSrsCard ? 'progressing' : 'not_in_srs'),
            srsCardId: row?.srsCardId ?? null,

            // Compatibility with existing UI/quiz mode checks
            id: row?.srsCardId ?? null,
            repetitionCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            improvementCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            status: dueCard?.status ?? row?.srsStatus ?? null,
            isActive: row?.srsIsActive ?? dueCard?.isActive ?? row?.isActive ?? true,
          };
        })
        .filter(Boolean)
        .filter((m) => {
          if (selectedTopics.length > 0 && !selectedTopics.includes(m.Topic)) return false;
          if (selectedSubtopics.length > 0 && !selectedSubtopics.includes(m.Subtopic)) return false;
          if (srsPresence !== 'all' && !matchesSrsPresence(m, srsPresence)) return false;
          if (selectedMasteryLevels.length > 0) {
            const bucket = getSrsBucket(m);
            if (!selectedMasteryLevels.includes(bucket)) return false;
          }
          return true;
        })
        .sort((a, b) => {
          const aDue = !!(a?.nextReviewDate && a?.nextReviewDate <= formatHKDateKey(getNow()) && a?.isActive !== false);
          const bDue = !!(b?.nextReviewDate && b?.nextReviewDate <= formatHKDateKey(getNow()) && b?.isActive !== false);
          if (aDue !== bDue) return aDue ? -1 : 1;
          return calcPriority(b) - calcPriority(a);
        });

      setMistakes(deckAll);
      setSrsCards(dueCards || []);

      // Reset archived cache; will lazy-load when opening Archive tab
      setArchivedMistakes({});
      setArchivedLoaded(false);
      
    } catch (err) {
      console.error(err);
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  async function loadFacetMistakes() {
    if (!currentUser?.uid) return;
    try {
      const now = getNow();
      const weekAgo = new Date(now);
      weekAgo.setDate(weekAgo.getDate() - 7);
      const monthAgo = new Date(now);
      monthAgo.setMonth(monthAgo.getMonth() - 1);

      const base = [collection(db, 'users', currentUser.uid, 'mistakes')];
      if (datePeriod === 'week') {
        base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
      } else if (datePeriod === 'month') {
        base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
      }
      base.push(orderBy('lastWrongAt', 'desc'));
      base.push(limit(200));

      const snap = await getDocs(query(...base));
      setFacetMistakeRows(snap.docs.map((d) => ({ docId: d.id, ...d.data() })));
    } catch (e) {
      console.error('Error loading facet mistakes:', e);
    }
  }

  async function loadMoreMistakes() {
    if (!currentUser?.uid) return;
    if (loadingMoreMistakes) return;
    if (!mistakeIndexHasMore) return;
    if (!mistakeIndexCursor) return;

    setLoadingMoreMistakes(true);
    try {
      const now = getNow();
      const weekAgo = new Date(now);
      weekAgo.setDate(weekAgo.getDate() - 7);
      const monthAgo = new Date(now);
      monthAgo.setMonth(monthAgo.getMonth() - 1);

      const pageSize = 40;
      const firstBuilt = buildMistakeIndexQueryConstraints({
        userId: currentUser.uid,
        datePeriod,
        selectedTopics,
        selectedSubtopics,
        selectedMasteryLevels,
        srsPresence,
        cursor: mistakeIndexCursor,
        pageSize,
      });

      let fetchedRows = [];
      let nextCursor = mistakeIndexCursor;
      let hasMore = false;

      const needsClientFiltering =
        (firstBuilt.needsClientTopicFilter && firstBuilt.topics.length > 0) ||
        (firstBuilt.needsClientSubtopicFilter && firstBuilt.subs.length > 0) ||
        (firstBuilt.needsClientMasteryFilter && firstBuilt.masteryLevels.length > 0);

      if (!needsClientFiltering) {
        const snap = await getDocs(firstBuilt.q);
        fetchedRows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));
        nextCursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : mistakeIndexCursor;
        hasMore = snap.docs.length === pageSize;
      } else {
        const maxPages = 6;
        let pagesFetched = 0;
        let fetchCursor = mistakeIndexCursor;
        let lastSnapSize = 0;
        const topics = firstBuilt.topics;
        const subs = firstBuilt.subs;
        const masteryLevels = firstBuilt.masteryLevels;

        while (pagesFetched < maxPages && fetchedRows.length < pageSize) {
          const built = buildMistakeIndexQueryConstraints({
            userId: currentUser.uid,
            datePeriod,
            selectedTopics,
            selectedSubtopics,
            selectedMasteryLevels,
            srsPresence,
            cursor: fetchCursor,
            pageSize,
          });

          const snap = await getDocs(built.q);
          lastSnapSize = snap.docs.length;
          let pageRows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));

          if (built.needsClientTopicFilter && topics.length > 0) {
            pageRows = pageRows.filter((r) => topics.includes(r?.Topic ?? r?.topic));
          }
          if (built.needsClientSubtopicFilter && subs.length > 0) {
            pageRows = pageRows.filter((r) => subs.includes(r?.Subtopic ?? r?.subtopic));
          }

          fetchedRows.push(...pageRows);

          fetchCursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : fetchCursor;
          pagesFetched += 1;

          if (lastSnapSize < pageSize) {
            break;
          }
        }

        fetchedRows = fetchedRows.slice(0, pageSize);
        nextCursor = fetchCursor;
        hasMore = lastSnapSize === pageSize;
      }

      if (await backfillMistakeSrsDefaults(currentUser.uid, fetchedRows)) {
        setSrsBackfillTick((x) => x + 1);
      }

      const mergedRows = [...mistakeIndexRows, ...fetchedRows];
      setMistakeIndexRows(mergedRows);
      setMistakeIndexCursor(nextCursor);
      setMistakeIndexHasMore(hasMore);

      const questionMap = new Map((questions || []).map(q => [q.ID, q]));
      const dueByQuestionId = new Map((srsCards || []).map((c) => [String(c.questionId), c]));

      const deckDeduped = (() => {
        const byId = new Map();
        const order = [];

        (mergedRows || []).forEach((row) => {
          const qid = row?.questionId ?? row?.ID ?? row?.docId ?? row?.id;
          const questionId = qid ? String(qid) : null;
          if (!questionId) return;

          const q =
            questionMap.get(Number.isFinite(Number(questionId)) ? Number(questionId) : questionId) ||
            questionMap.get(questionId);
          const dueCard = dueByQuestionId.get(questionId);

          const m = {
            ...(q || {}),
            ...row,
            ID: q?.ID ?? row?.ID ?? questionId,
            questionId,
            Topic: q?.Topic ?? row?.Topic ?? null,
            Subtopic: q?.Subtopic ?? row?.Subtopic ?? null,
            attemptCount: Number(row?.attemptCount || 0),
            lastAttempted: row?.lastAttempted || row?.lastWrongAt || row?.updatedAt || null,
            userAnswer: row?.lastUserAnswer ?? null,
            ...(dueCard || {}),
            hasSrsCard: row?.hasSrsCard === true,
            srsIsActive: row?.srsIsActive === true,
            srsStatus: row?.srsStatus ?? null,
            srsBucket: row?.srsBucket ?? (row?.hasSrsCard ? 'progressing' : 'not_in_srs'),
            srsCardId: row?.srsCardId ?? null,
            id: row?.srsCardId ?? null,
            repetitionCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            improvementCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            status: dueCard?.status ?? row?.srsStatus ?? null,
            isActive: row?.srsIsActive ?? dueCard?.isActive ?? row?.isActive ?? true,
          };

          if (!byId.has(questionId)) order.push(questionId);
          byId.set(questionId, m);
        });

        return order.map((k) => byId.get(k)).filter(Boolean);
      })();

      const deckFiltered = deckDeduped
        .filter((m) => {
          if (selectedTopics.length > 0 && !selectedTopics.includes(m.Topic)) return false;
          if (selectedSubtopics.length > 0 && !selectedSubtopics.includes(m.Subtopic)) return false;
          if (srsPresence !== 'all' && !matchesSrsPresence(m, srsPresence)) return false;
          if (selectedMasteryLevels.length > 0) {
            const bucket = getSrsBucket(m);
            if (!selectedMasteryLevels.includes(bucket)) return false;
          }
          return true;
        })
        .sort((a, b) => {
          const aDue = !!(a?.nextReviewDate && a?.nextReviewDate <= formatHKDateKey(getNow()) && a?.isActive !== false);
          const bDue = !!(b?.nextReviewDate && b?.nextReviewDate <= formatHKDateKey(getNow()) && b?.isActive !== false);
          if (aDue !== bDue) return aDue ? -1 : 1;
          return calcPriority(b) - calcPriority(a);
        });

      setMistakes(deckFiltered);
    } catch (e) {
      console.error('Error loading more mistakes:', e);
    }

    setLoadingMoreMistakes(false);
  }
  
  // Persistence effects
  useEffect(() => {
    localStorage.setItem('mistake_error_tags', JSON.stringify(errorTags));
  }, [errorTags]);
  
  useEffect(() => {
    applyRuleOfThree({});
  }, []);
  
  // Computed values
  const allTopics = useMemo(() => {
    if (datePeriod === 'all' && topicStatsDoc?.topics && typeof topicStatsDoc.topics === 'object') {
      return Object.keys(topicStatsDoc.topics)
        .map((k) => {
          try { return decodeURIComponent(k); } catch { return k; }
        })
        .filter(Boolean)
        .sort();
    }
    return [...new Set((facetMistakeRows || []).map((m) => m.Topic).filter(Boolean))].sort();
  }, [facetMistakeRows, topicStatsDoc, datePeriod]);

  const topicErrorDensity = useMemo(() => {
    const byTopic = {};
    const totalByTopic = {};

    (questions || []).forEach((q) => {
      if (!q?.Topic) return;
      totalByTopic[q.Topic] = (totalByTopic[q.Topic] || 0) + 1;
    });

    mistakes.forEach((m) => {
      const topic = m.Topic || m.topic;
      if (!topic) return;
      const wrongCount = Number(m.attemptCount || 0);
      const weight = getSrsContributionWeight(m);
      const score = wrongCount * weight;
      byTopic[topic] = (byTopic[topic] || 0) + score;
    });

    return Object.entries(byTopic)
      .map(([topic, score]) => {
        const total = totalByTopic[topic] || 0;
        const density = total > 0 ? score / total : score;
        return { topic, score, density, total };
      })
      .sort((a, b) => b.density - a.density);
  }, [mistakes, questions]);

  useEffect(() => {
    try {
      const top = (topicErrorDensity || []).slice(0, 4);
      localStorage.setItem('dashboard_topics_to_focus_cache_v1', JSON.stringify({
        updatedAt: new Date().toISOString(),
        top
      }));
    } catch {
      // ignore
    }
  }, [topicErrorDensity]);
  
  const availableSubtopics = useMemo(() => {
    const baseRows = facetMistakeRows || [];
    const base = selectedTopics.length > 0
      ? baseRows.filter((m) => selectedTopics.includes(m.Topic))
      : baseRows;
    return [...new Set(base.map((m) => m.Subtopic).filter(Boolean))].sort();
  }, [facetMistakeRows, selectedTopics]);
  
  useEffect(() => {
    setSelectedSubtopics((prev) => {
      const next = prev.filter((s) => availableSubtopics.includes(s));
      if (next.length === prev.length && next.every((v, i) => v === prev[i])) {
        return prev;
      }
      return next;
    });
  }, [availableSubtopics]);
  
  const filteredMistakes = useMemo(() => {
    let result = [...mistakes];
    // Topic/subtopic/date/mastery filters are applied in Firestore query when possible.
    // Any fallback client-side filtering happens during fetch.
    
    const noFilters =
      datePeriod === 'all' &&
      selectedTopics.length === 0 &&
      selectedSubtopics.length === 0 &&
      selectedMasteryLevels.length === 0 &&
      srsPresence === 'all';

    // Allow Load More to increase visible count beyond 40
    if (noFilters && !mistakeIndexHasMore && mistakeIndexRows.length <= 40) {
      return result.slice(0, 40);
    }

    return result;
  }, [mistakes, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, mistakeIndexHasMore, mistakeIndexRows.length]);

  const selectedMasteryTotalCount = useMemo(() => {
    if (!selectedMasteryLevels || selectedMasteryLevels.length === 0) return null;
    if (!masteryCounts || typeof masteryCounts !== 'object') return null;
    const sum = selectedMasteryLevels.reduce((acc, lvl) => acc + Number(masteryCounts?.[lvl] || 0), 0);
    return Number.isFinite(sum) ? sum : null;
  }, [masteryCounts, selectedMasteryLevels]);

  const globalFilteredTotalCount = useMemo(() => {
    if (datePeriod !== 'all') return null;

    // Subtopic counts aren't tracked globally yet.
    if (selectedSubtopics.length > 0) return null;

    // Topic counts are global only when topicStatsDoc is available (All Time).
    if (selectedTopics.length > 0) {
      if (selectedTopics.length === 1) {
        const topic = selectedTopics[0];
        const override = topicCountOverrides?.[String(topic)];
        if (override != null) {
          const v = Number(override);
          return Number.isFinite(v) ? v : null;
        }
      }

      if (selectedTopics.length >= 2 && selectedTopics.length <= 10 && multiTopicOverrideCount != null) {
        const v = Number(multiTopicOverrideCount);
        return Number.isFinite(v) ? v : null;
      }

      if (!topicStatsDoc?.topics || typeof topicStatsDoc.topics !== 'object') return null;

      const bucketKeys = selectedMasteryLevels.length > 0
        ? selectedMasteryLevels
        : Object.keys(MASTERY_LEVELS);

      const sum = selectedTopics.reduce((acc, topic) => {
        const key = encodeURIComponent(String(topic || ''));
        const entry = topicStatsDoc.topics[key];
        const e = entry && typeof entry === 'object' ? entry : {};

        if (srsPresence === 'in_srs') {
          return acc + Number(e.active || 0);
        }
        if (srsPresence === 'not_in_srs') {
          return acc + Number(e.b_not_in_srs || 0);
        }

        const topicSum = bucketKeys.reduce((bAcc, b) => bAcc + Number(e[`b_${b}`] || 0), 0);
        return acc + topicSum;
      }, 0);

      return Number.isFinite(sum) ? sum : null;
    }

    // If mastery buckets are selected with no topic/subtopic, we have a reliable global total.
    if (selectedMasteryTotalCount != null) return selectedMasteryTotalCount;

    if (srsPresence === 'not_in_srs') {
      if (masteryCounts && typeof masteryCounts === 'object') {
        const v = Number(masteryCounts?.not_in_srs || 0);
        return Number.isFinite(v) ? v : null;
      }
      return null;
    }

    // Otherwise, if masteryCounts exist, they should sum to total mistakes (All Time).
    if (masteryCounts && typeof masteryCounts === 'object' && Object.keys(masteryCounts).length > 0) {
      const sum = Object.values(masteryCounts).reduce((acc, v) => acc + Number(v || 0), 0);
      return Number.isFinite(sum) ? sum : null;
    }

    return totalMistakesCount != null ? Number(totalMistakesCount) : null;
  }, [datePeriod, selectedSubtopics, selectedTopics, topicStatsDoc, selectedMasteryLevels, srsPresence, selectedMasteryTotalCount, masteryCounts, totalMistakesCount, topicCountOverrides, multiTopicOverrideCount]);

  useEffect(() => {
    if (!currentUser?.uid) return;
    if (datePeriod !== 'all') return;
    if (selectedTopics.length === 0) return;
    if (loading) return;
    if (error) return;
    if (loadingMoreMistakes) return;

    // Only auto-normalize when Firestore says there are more docs, but our index query says there's no more.
    // This is the classic symptom of legacy docs missing required fields for the minimal-read query.
    const total = globalFilteredTotalCount;
    const loaded = Number(filteredMistakes?.length || 0);
    if (total == null) return;
    if (!Number.isFinite(Number(total))) return;
    if (!(Number(total) > loaded)) return;

    const doneKey = `normalize_mistakes_done_${currentUser.uid}`;
    const runningKey = `normalize_mistakes_running_${currentUser.uid}`;
    if (localStorage.getItem(doneKey) === '1') return;
    if (localStorage.getItem(runningKey) === '1') return;

    const run = async () => {
      try {
        localStorage.setItem(runningKey, '1');
        const functions = getFunctions(app, 'asia-east1');
        const callable = httpsCallable(functions, 'normalizeMistakes');
        await callable({});
        localStorage.setItem(doneKey, '1');
        localStorage.removeItem(runningKey);
        await refreshTopicStatsDoc();
        await loadMistakes();
      } catch (e) {
        localStorage.removeItem(runningKey);
        console.error('normalizeMistakes failed:', e);
      }
    };

    run();
  }, [
    currentUser?.uid,
    datePeriod,
    selectedTopics,
    selectedSubtopics,
    selectedMasteryLevels,
    srsPresence,
    loading,
    error,
    loadingMoreMistakes,
    globalFilteredTotalCount,
    filteredMistakes,
    refreshTopicStatsDoc,
  ]);

  const facetFilteredCount = useMemo(() => {
    let result = [...(facetMistakeRows || [])];
    if (selectedTopics.length > 0) {
      result = result.filter((m) => selectedTopics.includes(m.Topic));
    }
    if (selectedSubtopics.length > 0) {
      result = result.filter((m) => selectedSubtopics.includes(m.Subtopic));
    }
    if (srsPresence !== 'all') {
      result = result.filter((m) => matchesSrsPresence(m, srsPresence));
    }
    if (selectedMasteryLevels.length > 0) {
      result = result.filter((m) => selectedMasteryLevels.some((lvl) => getSrsBucket(m) === lvl));
    }
    return result.length;
  }, [facetMistakeRows, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence]);

  const topicFacetCountMap = useMemo(() => {
    if (datePeriod === 'all' && topicStatsDoc?.topics && typeof topicStatsDoc.topics === 'object') {
      const map = new Map();

      const bucketKeys = selectedMasteryLevels.length > 0
        ? selectedMasteryLevels
        : Object.keys(MASTERY_LEVELS);

      const includeActiveOnly = srsPresence === 'in_srs';
      const includeNotInSrsOnly = srsPresence === 'not_in_srs';

      Object.entries(topicStatsDoc.topics).forEach(([topicEnc, entry]) => {
        const topic = (() => {
          try { return decodeURIComponent(topicEnc); } catch { return topicEnc; }
        })();
        if (!topic) return;

        const e = entry && typeof entry === 'object' ? entry : {};
        let count = 0;

        if (includeActiveOnly) {
          // active count is maintained by the CF trigger
          count = Number(e.active || 0);
        } else if (includeNotInSrsOnly) {
          count = Number(e.b_not_in_srs || 0);
        } else {
          bucketKeys.forEach((b) => {
            const k = `b_${b}`;
            count += Number(e[k] || 0);
          });
        }

        map.set(topic, count);
      });

      if (topicCountOverrides && typeof topicCountOverrides === 'object') {
        Object.entries(topicCountOverrides).forEach(([topic, v]) => {
          const n = Number(v);
          if (!Number.isFinite(n)) return;
          map.set(topic, n);
        });
      }

      return map;
    }

    const base = [...(facetMistakeRows || [])]
      .filter((m) => (srsPresence === 'all' ? true : matchesSrsPresence(m, srsPresence)))
      .filter((m) => (selectedMasteryLevels.length === 0 ? true : selectedMasteryLevels.some((lvl) => getSrsBucket(m) === lvl)));

    const map = new Map();
    base.forEach((m) => {
      const topic = m?.Topic;
      if (!topic) return;
      map.set(topic, (map.get(topic) || 0) + 1);
    });
    if (topicCountOverrides && typeof topicCountOverrides === 'object') {
      Object.entries(topicCountOverrides).forEach(([topic, v]) => {
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        map.set(topic, n);
      });
    }
    return map;
  }, [facetMistakeRows, srsPresence, selectedMasteryLevels, topicStatsDoc, datePeriod, topicCountOverrides]);

  // Compute whether current filters force client-side search across all matches
  const needsClientSearch = useMemo(() => {
    const built = buildMistakeIndexQueryConstraints({
      userId: currentUser?.uid,
      datePeriod,
      selectedTopics,
      selectedSubtopics,
      selectedMasteryLevels,
      srsPresence,
      cursor: null,
      pageSize: 40,
    });
    return (built.needsClientTopicFilter && built.topics.length > 0) ||
           (built.needsClientSubtopicFilter && built.subs.length > 0) ||
           (built.needsClientMasteryFilter && built.masteryLevels.length > 0) ||
           built.needsClientSrsPresenceFilter;
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence]);

  useEffect(() => {
    if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') return;
    const mql = window.matchMedia('(hover: hover) and (pointer: fine)');
    const onChange = (e) => setHoverCapable(!!e.matches);
    setHoverCapable(!!mql.matches);
    if (typeof mql.addEventListener === 'function') {
      mql.addEventListener('change', onChange);
      return () => mql.removeEventListener('change', onChange);
    }
    mql.addListener(onChange);
    return () => mql.removeListener(onChange);
  }, []);

  const moreHint = useMemo(() => {
    // Avoid misleading +X when we don't have a reliable global count in filtered modes.
    if (needsClientSearch || srsPresence !== 'all') {
      if (mistakeIndexHasMore) return `(${t('notebook.moreQuestionsHidden')})`;
      return '';
    }

    if (globalFilteredTotalCount != null) {
      const loaded = Number(filteredMistakes?.length || 0);
      const remaining = Math.max(0, Number(globalFilteredTotalCount) - loaded);
      if (remaining > 0) return `(${tf('notebook.questionsHidden', { count: remaining })})`;
      if (mistakeIndexHasMore) return `(${t('notebook.moreQuestionsHidden')})`;
      return '';
    }

    // If we loaded less than a full page and there's no more, don't show hidden
    const loaded = filteredMistakes?.length || 0;
    if (!mistakeIndexHasMore && loaded < 40) {
      return '';
    }

    const hiddenLowerBound = Math.max(0, facetFilteredCount - loaded);
    if (hiddenLowerBound > 0) return `(${tf('notebook.questionsHidden', { count: hiddenLowerBound })})`;
    if (mistakeIndexHasMore) return `(${t('notebook.moreQuestionsHidden')})`;
    return '';
  }, [facetFilteredCount, filteredMistakes, mistakeIndexHasMore, needsClientSearch, srsPresence, globalFilteredTotalCount, t, tf]);

  useEffect(() => {
    setSelectedMistakeIds((prev) => {
      if (!prev || prev.size === 0) return prev;
      const allowed = new Set((filteredMistakes || []).map((m) => m.ID));
      const next = new Set([...prev].filter((id) => allowed.has(id)));
      if (next.size === prev.size) return prev;
      return next;
    });
  }, [filteredMistakes]);
  
  const practiceCount =
    questionCount === 'All'
      ? filteredMistakes.length
      : Math.min(parseInt(questionCount), filteredMistakes.length);
  
  // Kanban columns
  const kanbanColumns = useMemo(() => ({
    new: filteredMistakes.filter(m => getSrsBucket(m) === 'new'),
    progressing: filteredMistakes.filter(m => getSrsBucket(m) === 'progressing'),
    near: filteredMistakes.filter(m => getSrsBucket(m) === 'near'),
  }), [filteredMistakes]);
  
  // Handlers
  const handleTag = useCallback((questionId, tag) => {
    setErrorTags((prev) => {
      const next = { ...prev };
      if (tag === null) delete next[questionId];
      else next[questionId] = tag;
      return next;
    });
  }, []);
  
  const handleRestoreCard = async (questionId) => {
    if (!currentUser) return;
    
    try {
      // Find the archived card for this question
      const archivedCard = Object.values(archivedMistakes).find(card => card.questionId === questionId || card.ID === questionId);
      if (!archivedCard?.id) {
        console.error('Could not find archived card for question:', questionId);
        return;
      }
      
      await srsService.restoreArchivedCard(archivedCard.id);
      console.log('♻️ Restored card:', questionId);
      
      // Reload data to refresh the lists
      loadMistakes();
    } catch (error) {
      console.error('Error restoring card:', error);
    }
  };
  
  const toggleTopic = useCallback((topic) => {
    setSelectedTopics((prev) =>
      prev.includes(topic) ? prev.filter((t) => t !== topic) : [...prev, topic]
    );
  }, []);
  
  const toggleSubtopic = useCallback((sub) => {
    setSelectedSubtopics((prev) =>
      prev.includes(sub) ? prev.filter((s) => s !== sub) : [...prev, sub]
    );
  }, []);
  
  const toggleMasteryLevel = useCallback((lvl) => {
    setSelectedMasteryLevels((prev) =>
      prev.includes(lvl) ? prev.filter((l) => l !== lvl) : [...prev, lvl]
    );
  }, []);
  
  const handlePracticeMistakes = () => {
    if (filteredMistakes.length === 0) return;
    
    const selected = selectedMistakeIds.size > 0
      ? filteredMistakes.filter(m => selectedMistakeIds.has(m.ID))
      : [...filteredMistakes]
          .sort((a, b) => calcPriority(b) - calcPriority(a))
          .slice(0, practiceCount);
    
    quizStorage.clearQuizData();
    quizStorage.saveSelectedQuestions(selected);


=== functions/index.js ===
const admin = require('firebase-admin');
const { onSchedule } = require('firebase-functions/v2/scheduler');
const { onDocumentCreated, onDocumentUpdated, onDocumentDeleted } = require('firebase-functions/v2/firestore');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const algoliasearch = require('algoliasearch');

admin.initializeApp();

function encodeKey(value) {
  const s = value == null ? '' : String(value);
  return encodeURIComponent(s);
}

function safeString(value) {
  return value == null ? '' : String(value);
}

function decodeKey(value) {
  const s = value == null ? '' : String(value);
  try {
    return decodeURIComponent(s);
  } catch {
    return s;
  }
}

function normalizeBucket(value) {
  const v = value == null ? '' : String(value);
  if (v === 'not_in_srs' || v === 'new' || v === 'progressing' || v === 'near' || v === 'archived') return v;
  return 'not_in_srs';
}

function getTopicFromMistake(m) {
  if (!m || typeof m !== 'object') return '';
  return safeString(m.Topic || m.topic || '');
}

function getBucketFromMistake(m) {
  if (!m || typeof m !== 'object') return 'not_in_srs';
  return normalizeBucket(m.srsBucket || 'not_in_srs');
}

function getIsActiveFromMistake(m) {
  if (!m || typeof m !== 'object') return false;
  return m.srsIsActive === true;
}

async function applyMistakeTopicStatsDelta(db, userId, delta, topic, bucket, isActive) {
  const uid = safeString(userId);
  const d = Number(delta);
  if (!uid || !Number.isFinite(d) || d === 0) return;

  const topicEnc = encodeKey(topic || '');
  if (!topicEnc) return;

  const b = normalizeBucket(bucket);
  const active = isActive === true;

  const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(statsRef);
    const prev = snap.exists ? (snap.data() || {}) : {};
    const prevTopics = prev.topics && typeof prev.topics === 'object' ? prev.topics : {};
    const prevEntry = prevTopics[topicEnc] && typeof prevTopics[topicEnc] === 'object' ? prevTopics[topicEnc] : {};

    const nextTopics = { ...prevTopics };
    const nextEntry = { ...prevEntry };

    const prevTotal = Number(nextEntry.total || 0);
    const nextTotal = Math.max(0, prevTotal + d);
    nextEntry.total = nextTotal;

    const bucketKey = `b_${b}`;
    const prevBucket = Number(nextEntry[bucketKey] || 0);
    const nextBucket = Math.max(0, prevBucket + d);
    if (nextBucket === 0) delete nextEntry[bucketKey];
    else nextEntry[bucketKey] = nextBucket;

    if (active) {
      const prevActive = Number(nextEntry.active || 0);
      const nextActive = Math.max(0, prevActive + d);
      nextEntry.active = nextActive;
    }

    // Prune empty
    if (nextEntry.total === 0) {
      delete nextTopics[topicEnc];
    } else {
      nextEntry.updatedAt = admin.firestore.FieldValue.serverTimestamp();
      nextTopics[topicEnc] = nextEntry;
    }

    tx.set(statsRef, {
      topics: nextTopics,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });
  });
}

async function applyMistakeDocDelta(db, userId, before, after) {
  const beforeExists = before && typeof before === 'object' && Object.keys(before).length > 0;
  const afterExists = after && typeof after === 'object' && Object.keys(after).length > 0;

  if (!beforeExists && !afterExists) return;

  // Create
  if (!beforeExists && afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      1,
      getTopicFromMistake(after),
      getBucketFromMistake(after),
      getIsActiveFromMistake(after)
    );
    return;
  }

  // Delete
  if (beforeExists && !afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      -1,
      getTopicFromMistake(before),
      getBucketFromMistake(before),
      getIsActiveFromMistake(before)
    );
    return;
  }

  const beforeTopic = getTopicFromMistake(before);
  const afterTopic = getTopicFromMistake(after);
  const beforeBucket = getBucketFromMistake(before);
  const afterBucket = getBucketFromMistake(after);
  const beforeActive = getIsActiveFromMistake(before);
  const afterActive = getIsActiveFromMistake(after);

  const changed =
    beforeTopic !== afterTopic ||
    beforeBucket !== afterBucket ||
    beforeActive !== afterActive;

  if (!changed) return;

  // Remove old
  await applyMistakeTopicStatsDelta(db, userId, -1, beforeTopic, beforeBucket, beforeActive);
  // Add new
  await applyMistakeTopicStatsDelta(db, userId, 1, afterTopic, afterBucket, afterActive);
}

// Maintain mistake topic stats for global sidebar facets
exports.updateMistakeTopicStatsOnCreate = onDocumentCreated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const after = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, null, after);
  }
);

exports.normalizeMistakes = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to normalize mistakes');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');

    const pageSize = 800;
    let last = null;
    let processed = 0;
    let updated = 0;

    const nowIso = new Date().toISOString();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);

      const snap = await q.get();
      if (snap.empty) break;

      // Only write docs that truly need a patch.
      const toPatch = [];
      for (const docSnap of snap.docs) {
        const d = docSnap.data() || {};

        const topic = d.Topic ?? d.topic ?? null;
        const subtopic = d.Subtopic ?? d.subtopic ?? null;
        const lastWrongAt = d.lastWrongAt ?? d.lastAttempted ?? d.updatedAt ?? d.createdAt ?? nowIso;

        const needsTopic = d.Topic == null && d.topic != null;
        const needsSubtopic = d.Subtopic == null && d.subtopic != null;
        const needsLastWrongAt = d.lastWrongAt == null;

        if (needsTopic || needsSubtopic || needsLastWrongAt) {
          toPatch.push({
            ref: docSnap.ref,
            patch: {
              Topic: topic,
              Subtopic: subtopic,
              lastWrongAt,
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          });
        }
      }

      if (toPatch.length > 0) {
        for (let i = 0; i < toPatch.length; i += 450) {
          const batch = db.batch();
          const slice = toPatch.slice(i, i + 450);
          slice.forEach((x) => {
            batch.set(x.ref, x.patch, { merge: true });
          });
          await batch.commit();
          updated += slice.length;
        }
      }

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Make it easy to see when it was last run.
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');
    await statsRef.set({
      lastNormalizedAt: admin.firestore.FieldValue.serverTimestamp(),
      lastNormalizedProcessed: processed,
      lastNormalizedUpdated: updated,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, updated };
  }
);

exports.updateMistakeTopicStatsOnUpdate = onDocumentUpdated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || null;
    const after = event.data?.after?.data?.() || null;
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, after);
  }
);

exports.updateMistakeTopicStatsOnDelete = onDocumentDeleted(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const before = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, null);
  }
);

exports.rebuildMistakeTopicStats = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild mistake topic stats');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

    const topics = {};

    const pageSize = 800;
    let last = null;
    let processed = 0;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);
      const snap = await q.get();
      if (snap.empty) break;

      snap.docs.forEach((docSnap) => {
        const m = docSnap.data() || {};
        const topic = getTopicFromMistake(m);
        if (!topic) return;
        const topicEnc = encodeKey(topic);
        const bucket = getBucketFromMistake(m);
        const isActive = getIsActiveFromMistake(m);

        const entry = topics[topicEnc] && typeof topics[topicEnc] === 'object' ? topics[topicEnc] : {};
        entry.total = Number(entry.total || 0) + 1;
        const bucketKey = `b_${bucket}`;
        entry[bucketKey] = Number(entry[bucketKey] || 0) + 1;
        if (isActive) entry.active = Number(entry.active || 0) + 1;
        topics[topicEnc] = entry;
      });

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    await statsRef.set({
      topics,
      processed,
      rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, topics: Object.keys(topics).length };
  }
);

async function applySrsSummaryDelta(db, userId, dateStr, delta, topic, subtopic) {
  const uid = safeString(userId);
  const dateKey = safeString(dateStr);
  if (!uid || !dateKey || !Number.isFinite(delta) || delta === 0) return;

  const topicKey = encodeKey(topic || '');
  const subtopicKey = encodeKey(subtopic || '');
  const hasTopic = Boolean(topicKey);
  const hasSubtopic = Boolean(topicKey) && Boolean(subtopicKey);
  const compoundSubKey = hasSubtopic ? `${topicKey}::${subtopicKey}` : '';

  const summaryRef = db.collection('users').doc(uid).collection('srs_daily_summaries').doc(dateKey);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(summaryRef);
    const prev = snap.exists ? (snap.data() || {}) : {};

    const next = { ...prev };
    next.date = dateKey;
    next.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    const prevTotal = Number(prev.dueTotal || 0);
    next.dueTotal = Math.max(0, prevTotal + delta);

    const prevTopics = prev.topicCounts && typeof prev.topicCounts === 'object' ? prev.topicCounts : {};
    const prevSubs = prev.subtopicCounts && typeof prev.subtopicCounts === 'object' ? prev.subtopicCounts : {};

    const nextTopics = { ...prevTopics };
    const nextSubs = { ...prevSubs };

    if (hasTopic) {
      const old = Number(nextTopics[topicKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextTopics[topicKey];
      else nextTopics[topicKey] = v;
    }

    if (hasSubtopic) {
      const old = Number(nextSubs[compoundSubKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextSubs[compoundSubKey];
      else nextSubs[compoundSubKey] = v;
    }

    next.topicCounts = nextTopics;
    next.subtopicCounts = nextSubs;

    tx.set(summaryRef, next, { merge: true });
  });
}

function isActiveCard(card) {
  if (!card || typeof card !== 'object') return false;
  if (card.isActive === false) return false;
  if (!card.userId) return false;
  if (!card.nextReviewDate) return false;
  return true;
}

// Define secrets (use new Firebase Functions params API)
const algoliaAppId = defineSecret('ALGOLIA_APP_ID');
const algoliaAdminKey = defineSecret('ALGOLIA_ADMIN_KEY');
const ALGOLIA_INDEX_NAME = 'forum_posts';

// Initialize Algolia client lazily at runtime
function getAlgoliaClient() {
  const appId = algoliaAppId.value();
  const adminKey = algoliaAdminKey.value();
  if (!appId || !adminKey) return null;
  return algoliasearch(appId, adminKey);
}

exports.aggregateCommentQuestionStatsOnCommentCreate = onDocumentCreated(
  {
    document: 'comments/{commentId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;

    const comment = snap.data() || {};
    const questionId = comment.questionId != null ? String(comment.questionId) : '';
    if (!questionId) return;

    const createdAt = typeof comment.createdAt === 'string'
      ? comment.createdAt
      : new Date().toISOString();

    const db = admin.firestore();
    const statsRef = db.collection('comment_question_stats').doc(questionId);

    await db.runTransaction(async (tx) => {
      const statsSnap = await tx.get(statsRef);
      const prev = statsSnap.exists ? (statsSnap.data() || {}) : {};

      const prevLast = typeof prev.lastActivity === 'string' ? prev.lastActivity : '';
      const nextLastActivity = prevLast && prevLast > createdAt ? prevLast : createdAt;

      tx.set(statsRef, {
        questionId,
        commentCount: admin.firestore.FieldValue.increment(1),
        lastActivity: nextLastActivity,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.rebuildSrsDailySummaries = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild summaries');
    }

    const db = admin.firestore();

    // Page through all active cards for this user
    const cardsRef = db.collection('spaced_repetition_cards');
    const pageSize = 500;
    let last = null;
    let totalCards = 0;

    // dateStr => { dueTotal, topicCounts, subtopicCounts }
    const aggregated = new Map();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = cardsRef
        .where('userId', '==', uid)
        .where('isActive', '==', true)
        .orderBy(admin.firestore.FieldPath.documentId())
        .limit(pageSize);

      if (last) {
        q = q.startAfter(last);
      }

      const snap = await q.get();
      if (snap.empty) break;

      for (const docSnap of snap.docs) {
        const card = docSnap.data() || {};
        if (!card.nextReviewDate) continue;

        const dateKey = safeString(card.nextReviewDate);
        const topicEnc = encodeKey(card.topic || '');
        const subEnc = encodeKey(card.subtopic || '');
        const compound = (topicEnc && subEnc) ? `${topicEnc}::${subEnc}` : '';

        if (!aggregated.has(dateKey)) {
          aggregated.set(dateKey, {
            date: dateKey,
            dueTotal: 0,
            topicCounts: {},
            subtopicCounts: {},
          });
        }

        const entry = aggregated.get(dateKey);
        entry.dueTotal += 1;

        if (topicEnc) {
          entry.topicCounts[topicEnc] = (entry.topicCounts[topicEnc] || 0) + 1;
        }
        if (compound) {
          entry.subtopicCounts[compound] = (entry.subtopicCounts[compound] || 0) + 1;
        }
      }

      totalCards += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Write summaries for encountered dates (overwrite those docs).
    const summariesRef = db.collection('users').doc(uid).collection('srs_daily_summaries');
    const dateKeys = Array.from(aggregated.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    let written = 0;
    for (let i = 0; i < dateKeys.length; i += 400) {
      const batch = db.batch();
      const slice = dateKeys.slice(i, i + 400);

      for (const dateKey of slice) {
        const data = aggregated.get(dateKey);
        const ref = summariesRef.doc(dateKey);
        batch.set(ref, {
          date: data.date,
          dueTotal: data.dueTotal,
          topicCounts: data.topicCounts,
          subtopicCounts: data.subtopicCounts,
          rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
      }

      await batch.commit();
      written += slice.length;
    }

    return {
      ok: true,
      userId: uid,
      cardsProcessed: totalCards,
      datesWritten: written,
    };
  }
);

// Maintain SRS daily summaries (cheap calendar counts)
exports.updateSrsDailySummaryOnCardCreate = onDocumentCreated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, 1, card.topic, card.subtopic);
  }
);

exports.updateSrsDailySummaryOnCardUpdate = onDocumentUpdated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || {};
    const after = event.data?.after?.data?.() || {};

    const beforeActive = isActiveCard(before);
    const afterActive = isActiveCard(after);

    const db = admin.firestore();

    // Removed from active set
    if (beforeActive && !afterActive) {
      await applySrsSummaryDelta(db, before.userId, before.nextReviewDate, -1, before.topic, before.subtopic);
      return;
    }

    // Added to active set
    if (!beforeActive && afterActive) {
      await applySrsSummaryDelta(db, after.userId, after.nextReviewDate, 1, after.topic, after.subtopic);
      return;
    }

    if (!beforeActive && !afterActive) return;

    const uid = after.userId || before.userId;
    const beforeDate = safeString(before.nextReviewDate);
    const afterDate = safeString(after.nextReviewDate);
    const beforeTopic = safeString(before.topic);
    const afterTopic = safeString(after.topic);
    const beforeSub = safeString(before.subtopic);
    const afterSub = safeString(after.subtopic);

    const dateChanged = beforeDate !== afterDate;
    const topicChanged = beforeTopic !== afterTopic;
    const subChanged = beforeSub !== afterSub;

    if (!dateChanged && !topicChanged && !subChanged) return;

    // Remove old
    await applySrsSummaryDelta(db, uid, beforeDate, -1, beforeTopic, beforeSub);
    // Add new
    await applySrsSummaryDelta(db, uid, afterDate, 1, afterTopic, afterSub);
  }
);

exports.updateSrsDailySummaryOnCardDelete = onDocumentDeleted(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, -1, card.topic, card.subtopic);
  }
);

 function toHongKongDate(dateObj) {
   // Convert an instant-in-time to a Date whose UTC fields represent Asia/Hong_Kong local time.
   // This avoids discrepancies between browser local time (HK) and Cloud Functions runtime (UTC).
   const d = dateObj instanceof Date ? dateObj : new Date(dateObj);
   return new Date(d.getTime() + 8 * 60 * 60 * 1000);
 }

function getWeeklyKeyForDate(dateObj) {
  // Use UTC getters so output is independent of the runtime's local timezone.
  const date = new Date(Date.UTC(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
  const yyyy = date.getUTCFullYear();
  return `leaderboard_weekly_${yyyy}-W${String(weekNo).padStart(2, '0')}`;
}

function weeklyTokensForRank(rank) {
  const r = Number(rank || 0);
  if (!Number.isFinite(r) || r <= 0) return 0;
  // Keep consistent with frontend logic: max(0, 11 - rank)
  return Math.max(0, 11 - r);
}

exports.aggregateWeeklyLeaderboardOnAttemptCreate = onDocumentCreated(
  {
    document: 'attempts/{attemptId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const attemptData = snap.data() || {};
    const userId = attemptData.userId;
    if (!userId) return;

    const attemptTs = attemptData.timestamp ? new Date(attemptData.timestamp) : new Date();
    const weekId = getWeeklyKeyForDate(toHongKongDate(attemptTs));

    const db = admin.firestore();
    const entryRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries').doc(userId);
    const userRef = db.collection('users').doc(userId);

    await db.runTransaction(async (tx) => {
      const [entrySnap, userSnap] = await Promise.all([
        tx.get(entryRef),
        tx.get(userRef),
      ]);

      const userData = userSnap.exists ? userSnap.data() : {};
      const prev = entrySnap.exists ? entrySnap.data() : {};

      const prevAttemptCount = Number(prev.attemptCount || 0);
      const prevTotalScore = Number(prev.totalScore || 0);
      const prevTotalQuestions = Number(prev.totalQuestions || 0);
      const prevTotalCorrect = Number(prev.totalCorrect || 0);

      const nextAttemptCount = prevAttemptCount + 1;
      const nextTotalScore = prevTotalScore + Number(attemptData.percentage || 0);
      const nextTotalQuestions = prevTotalQuestions + Number(attemptData.totalQuestions || 0);
      const nextTotalCorrect = prevTotalCorrect + Number(attemptData.correctAnswers || 0);
      const nextAverageScore = nextAttemptCount > 0 ? Math.round(nextTotalScore / nextAttemptCount) : 0;

      tx.set(entryRef, {
        userId,
        weekId,
        displayName: userData?.displayName || 'Unknown',
        level: userData?.level || null,
        equippedProfilePic: (userData?.equipped || {}).profilePic || 'flask_blue',
        equippedTheme: (userData?.equipped || {}).theme || 'default',
        streak: Number(userData?.streak || 0),
        attemptCount: nextAttemptCount,
        totalScore: nextTotalScore,
        averageScore: nextAverageScore,
        totalQuestions: nextTotalQuestions,
        totalCorrect: nextTotalCorrect,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.weeklyLeaderboardPayout = onSchedule(
  {
    schedule: '0 0 * * 1',
    timeZone: 'Asia/Hong_Kong',
    region: 'asia-east1',
  },
  async () => {
    const db = admin.firestore();

    // Run payout for LAST week (so the leaderboard is complete)
    const now = toHongKongDate(new Date());
    const lastWeekDate = new Date(now);
    lastWeekDate.setDate(lastWeekDate.getDate() - 7);
    const weekId = getWeeklyKeyForDate(toHongKongDate(lastWeekDate));

    const entriesRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries');
    const topSnap = await entriesRef.orderBy('averageScore', 'desc').limit(10).get();

    if (topSnap.empty) return;

    // Batch-like loop (transactions per user to keep idempotency + correct balances)
    const payoutPromises = topSnap.docs.map(async (docSnap, idx) => {
      const entry = docSnap.data() || {};
      const userId = entry.userId || docSnap.id;
      const rank = idx + 1;
      const tokens = weeklyTokensForRank(rank);
      if (!userId || tokens <= 0) return;

      const payoutRef = db
        .collection('weekly_leaderboards')
        .doc(weekId)
        .collection('payouts')
        .doc(userId);

      const userRef = db.collection('users').doc(userId);

      await db.runTransaction(async (tx) => {
        const [payoutSnap, userSnap] = await Promise.all([
          tx.get(payoutRef),
          tx.get(userRef),
        ]);

        if (payoutSnap.exists) {
          return; // already paid
        }

        if (!userSnap.exists) {
          // still record payout marker to avoid repeated attempts
          tx.set(payoutRef, {
            userId,
            weekId,
            rank,
            tokens,
            skipped: true,
            reason: 'User doc missing',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          });
          return;
        }

        const userData = userSnap.data() || {};
        const currentTokens = Number(userData.tokens || 0);
        const newTokens = currentTokens + tokens;

        tx.update(userRef, {
          tokens: newTokens,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const historyRef = userRef.collection('tokenHistory').doc();
        tx.set(historyRef, {
          amount: tokens,
          reason: `Leaderboard Reward: weekly #${rank}`,
          type: 'gain',
          timestamp: admin.firestore.FieldValue.serverTimestamp(),
          balanceAfter: newTokens,
          metadata: {
            category: 'leaderboard',
            period: 'weekly',
            rank,
            weekId,
          },
        });

        const notifRef = db.collection('notifications').doc();
        tx.set(notifRef, {
          recipientId: userId,
          senderId: 'system',
          type: 'leaderboard_reward',
          senderDisplayName: 'System',
          previewText: `Weekly leaderboard #${rank}: +${tokens} tokens`,
          read: false,
          createdAt: new Date().toISOString(),
          weekId,
          rank,
          tokens,
        });

        tx.set(payoutRef, {
          userId,
          weekId,
          rank,
          tokens,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      });
    });

    await Promise.all(payoutPromises);
  }
);

// === Algolia search sync for forum_posts ===

// Helper: prepare Algolia record from Firestore doc
function toAlgoliaRecord(postId, data) {
  return {
    objectID: postId,
    title: data.title || '',
    content: data.content || '',
    category: data.category || '',
    userDisplayName: data.userDisplayName || '',
    userId: data.userId || '',
    createdAt: data.createdAt || '',
    // You can add more fields if you want them searchable/filterable
  };
}

// Create: when a new forum post is created
exports.syncForumPostToAlgoliaOnCreate = onDocumentCreated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Update: when a forum post is updated
exports.syncForumPostToAlgoliaOnUpdate = onDocumentUpdated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.after.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Delete: when a forum post is deleted
exports.syncForumPostToAlgoliaOnDelete = onDocumentDeleted(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const postId = event.params.postId;
    await algoliaIndex.deleteObject(postId);
  }
);

=== srsService.js ===
/**
 * SRS Service - Firestore Integration
 * 
 * Manages spaced repetition cards using Just-in-Time scheduling
 * 
 * CRITICAL: This service NEVER pre-schedules multiple reviews.
 * Reviews are created ONE AT A TIME as users complete them.
 */

import { db } from '../firebase/config';
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc,
  getDocs,
  getCountFromServer,
  updateDoc,
  deleteDoc,
  query, 
  where,
  orderBy,
  limit,
  Timestamp,
  writeBatch
} from 'firebase/firestore';
import { getNow } from '../utils/timeTravel';
import { formatHKDateKey } from '../utils/hkTime';
import {
  createNewCard,
  updateCardAfterReview,
  isCardDue,
  shouldArchiveCard,
  SRS_CONFIG
} from './srsAlgorithm';

// Collection names
const COLLECTIONS = {
  CARDS: 'spaced_repetition_cards',
  ATTEMPTS: 'review_attempts',
  SESSIONS: 'review_sessions'
};

function deriveSrsBucketFromCard(card) {
  if (!card || typeof card !== 'object') return 'not_in_srs';
  if (card.isActive === false) return 'archived';
  if (card.status === 'new') return 'new';
  if (card.status === 'learning') return 'progressing';
  if (card.status === 'review') return 'near';
  if (card.status === 'graduated') return 'archived';
  return 'progressing';
}

async function upsertMistakeSrsMeta(userId, questionId, cardOrNull) {
  if (!userId || !questionId) return;

  const ref = doc(db, 'users', userId, 'mistakes', String(questionId));

  if (!cardOrNull) {
    await setDoc(ref, {
      hasSrsCard: false,
      srsIsActive: false,
      srsStatus: null,
      srsBucket: 'not_in_srs',
      srsUpdatedAt: new Date().toISOString(),
    }, { merge: true });
    return;
  }

  await setDoc(ref, {
    hasSrsCard: true,
    srsIsActive: cardOrNull.isActive !== false,
    srsStatus: cardOrNull.status || null,
    srsBucket: deriveSrsBucketFromCard(cardOrNull),
    srsCardId: cardOrNull.id || null,
    srsUpdatedAt: new Date().toISOString(),
  }, { merge: true });
}

async function findAnyCardForQuestion(userId, questionId) {
  if (!userId || !questionId) return null;

  // Prefer deterministic ID (new behavior)
  const deterministicId = `card_${userId}_${questionId}`;
  const deterministicRef = doc(db, COLLECTIONS.CARDS, deterministicId);
  const deterministicSnap = await getDoc(deterministicRef);
  if (deterministicSnap.exists()) {
    return { id: deterministicSnap.id, ...deterministicSnap.data() };
  }

  // Backward-compatibility: legacy cards were session-scoped IDs.
  // We pick any existing card for this question.
  const q = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('questionId', '==', questionId),
    limit(1)
  );

  const snap = await getDocs(q);
  if (snap.empty) return null;
  const d = snap.docs[0];
  return { id: d.id, ...d.data() };
}

function resetCardForReactivation(card, { topic, subtopic, attemptId }) {
  const now = getNow();
  const nextReviewDate = formatHKDateKey(new Date(now.getTime() + 86400000));
  return {
    ...card,
    topic: topic ?? card.topic ?? null,
    subtopic: subtopic ?? card.subtopic ?? null,

    interval: 1,
    easeFactor: 2.5,
    repetitionCount: 0,
    status: 'new',
    currentAttemptNumber: 0,

    nextReviewDate,
    lastReviewedAt: null,
    isDue: false,

    totalAttempts: 0,
    successfulAttempts: 0,
    failedAttempts: 0,

    isActive: true,
    archivedAt: null,
    archiveReason: null,
    createdFromAttemptId: attemptId ?? card.createdFromAttemptId ?? null,
    updatedAt: now.toISOString(),
  };
}

/**
 * Create SRS cards for wrong answers from a quiz
 * 
 * @param {string} userId - User ID
 * @param {Array} wrongQuestions - Questions answered incorrectly
 * @param {string} sessionId - Original quiz session ID
 * @param {string} attemptId - Original quiz attempt ID
 * @returns {Promise<Array>} Created cards
 */
export async function createCardsFromMistakes(userId, wrongQuestions, sessionId, attemptId) {
  const batch = writeBatch(db);
  const createdCards = [];
  
  console.log(`📝 Creating ${wrongQuestions.length} SRS cards for user ${userId}`);
  
  for (const question of wrongQuestions) {
    const questionId = question?.ID;
    if (!questionId) continue;

    const existing = await findAnyCardForQuestion(userId, questionId);
    if (existing) {
      // If a card exists (active or archived), reuse it.
      // Archived/graduated cards are reactivated + reset.
      const next = existing.isActive === false
        ? resetCardForReactivation(existing, {
          topic: question.Topic,
          subtopic: question.Subtopic || null,
          attemptId,
        })
        : {
          ...existing,
          topic: question.Topic ?? existing.topic ?? null,
          subtopic: (question.Subtopic || null) ?? existing.subtopic ?? null,
          updatedAt: getNow().toISOString(),
        };

      batch.set(doc(db, COLLECTIONS.CARDS, existing.id), next);
      createdCards.push(next);

      console.log(`♻️ Reused SRS card: ${existing.id} (review on ${next.nextReviewDate})`);
      continue;
    }

    // No prior card -> create deterministic ID (one card per user+question)
    const card = createNewCard({
      questionId,
      userId,
      topic: question.Topic,
      subtopic: question.Subtopic || null,
      sessionId,
      attemptId
    });
    const deterministicId = `card_${userId}_${questionId}`;
    card.id = deterministicId;
    
    batch.set(doc(db, COLLECTIONS.CARDS, card.id), card);
    createdCards.push(card);
    
    console.log(`✅ Created SRS card: ${card.id} (review on ${card.nextReviewDate})`);
  }
  
  if (createdCards.length > 0) {
    await batch.commit();
    console.log(`🎉 Successfully created ${createdCards.length} SRS cards`);

    // Denormalize onto mistake index (writes only)
    await Promise.all(
      createdCards.map((c) => upsertMistakeSrsMeta(userId, c.questionId, c))
    );
  }
  
  return createdCards;
}

/**
 * Get all cards due for review (JIT query)
 * 
 * @param {string} userId - User ID
 * @param {Date} asOf - Check for cards due as of this date (defaults to today)
 * @param {Object} options - Query options
 * @param {number} options.limit - Max number of due cards to return
 * @returns {Promise<Array>} Due cards
 */
export async function getDueCards(userId, asOf = getNow(), options = {}) {
  const today = formatHKDateKey(asOf);
  const max = Number(options?.limit);
  
  console.log(`🔍 Fetching due cards for ${userId} as of ${today}`);
  
  const queryParts = [
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '<=', today),
    orderBy('nextReviewDate', 'asc')
  ];

  if (Number.isFinite(max) && max > 0) {
    queryParts.push(limit(max));
  }

  const cardsQuery = query(...queryParts);
  
  const snapshot = await getDocs(cardsQuery);
  const dueCards = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  
  console.log(`📊 Found ${dueCards.length} cards due for review`);
  
  return dueCards;
}

/**
 * Get cards due on an exact date (no overdue accumulation)
 *
 * This is useful for calendar scheduling when you only want to create
 * events for "today" (or a specific day) and avoid reading a large backlog.
 *
 * @param {string} userId - User ID
 * @param {string} dateStr - YYYY-MM-DD
 * @param {Object} options - Query options
 * @param {number} options.limit - Max number of cards to return
 * @returns {Promise<Array>} Cards due exactly on dateStr
 */
export async function getCardsDueOnDate(userId, dateStr, options = {}) {
  const max = Number(options?.limit);

  if (!dateStr) {
    throw new Error('getCardsDueOnDate requires dateStr (YYYY-MM-DD)');
  }

  console.log(`🔍 Fetching cards due on ${dateStr} for ${userId}`);

  const queryParts = [
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '==', dateStr),
    orderBy('nextReviewDate', 'asc')
  ];

  if (Number.isFinite(max) && max > 0) {
    queryParts.push(limit(max));
  }

  const cardsQuery = query(...queryParts);
  const snapshot = await getDocs(cardsQuery);
  const cards = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));

  console.log(`📊 Found ${cards.length} cards due on ${dateStr}`);
  return cards;
}

export async function getOverdueCount(userId, asOf = getNow()) {
  const todayStr = formatHKDateKey(asOf);
  const fourteenDaysAgo = new Date(asOf);
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
  const fourteenDaysAgoStr = formatHKDateKey(fourteenDaysAgo);

  const q = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '<', todayStr),
    where('nextReviewDate', '>=', fourteenDaysAgoStr)
  );

  const snap = await getCountFromServer(q);
  return Number(snap.data().count || 0);
}

/**
 * Archive overdue cards older than 14 days (recoverable)
 * 
 * @param {string} userId - User ID
 * @returns {Promise<number>} Number of archived cards
 */
export async function archiveOverdueCards(userId) {
  const today = new Date();
  const fourteenDaysAgo = new Date(today);
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
  const fourteenDaysAgoStr = formatHKDateKey(fourteenDaysAgo);
  
  console.log(`🗄️ Archiving overdue cards older than 14 days for user ${userId}`);
  
  // Find cards overdue by more than 14 days
  const overdueQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '<', fourteenDaysAgoStr)
  );
  
  const snapshot = await getDocs(overdueQuery);
  const cardsToArchive = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  
  if (cardsToArchive.length === 0) {
    console.log('✅ No cards to archive');
    return 0;
  }
  
  // Archive cards in batches
  const batchSize = 500;
  let archivedCount = 0;
  
  for (let i = 0; i < cardsToArchive.length; i += batchSize) {
    const batch = writeBatch(db);
    const batchCards = cardsToArchive.slice(i, i + batchSize);
    
    batchCards.forEach(card => {
      const cardRef = doc(db, COLLECTIONS.CARDS, card.id);
      batch.update(cardRef, {
        isActive: false,
        archivedAt: new Date().toISOString(),
        archiveReason: 'overdue_14_days',
        updatedAt: new Date().toISOString()
      });
    });
    
    await batch.commit();
    archivedCount += batchCards.length;
    console.log(`📦 Archived batch of ${batchCards.length} cards`);

    // Best-effort denormalization
    await Promise.all(
      batchCards.map((c) => upsertMistakeSrsMeta(userId, c.questionId, { ...c, isActive: false }))
    );
  }
  
  console.log(`🎉 Successfully archived ${archivedCount} overdue cards`);
  return archivedCount;
}

/**
 * Get archived cards for a user
 * 
 * @param {string} userId - User ID
 * @param {Object} options - Query options
 * @param {string} options.reason - Filter by archive reason
 * @param {number} options.limit - Max number of cards to return
 * @returns {Promise<Array>} Archived cards
 */
export async function getArchivedCards(userId, options = {}) {
  const { reason, limit } = options;
  
  const queryParts = [
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', false)
  ];
  
  if (reason) {
    queryParts.push(where('archiveReason', '==', reason));
  }
  
  queryParts.push(orderBy('archivedAt', 'desc'));
  
  if (Number.isFinite(limit) && limit > 0) {
    queryParts.push(limit(limit));
  }
  
  const cardsQuery = query(...queryParts);
  const snapshot = await getDocs(cardsQuery);
  
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * Restore an archived card
 * 
 * @param {string} cardId - Card ID
 * @returns {Promise<Object>} Restored card
 */
export async function restoreArchivedCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  
  await updateDoc(cardRef, {
    isActive: true,
    archivedAt: null,
    archiveReason: null,
    updatedAt: new Date().toISOString()
  });
  
  const updatedCard = await getCard(cardId);
  console.log(`♻️ Restored archived card: ${cardId}`);

  try {
    if (updatedCard) {
      await upsertMistakeSrsMeta(updatedCard.userId, updatedCard.questionId, updatedCard);
    }
  } catch (e) {
    console.error('⚠️ Failed to update mistake SRS meta on restore:', e);
  }
  
  return updatedCard;
}
/**
 * Save a single card (for debugging)
 * 
 * @param {Object} card - Card data
 * @returns {Promise<Object>} Saved card
 */
export async function saveCard(card) {
  const cardRef = doc(db, COLLECTIONS.CARDS, card.id);
  await setDoc(cardRef, card);
  return { id: card.id, ...card };
}

/**
 * Delete a card (for debugging)
 * 
 * @param {string} cardId - Card ID
 * @returns {Promise<void>}
 */
export async function deleteCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  await deleteDoc(cardRef);
}

/**
 * Get all SRS cards for a user
 */
export async function getAllCards(userId) {
  const cardsQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId)
  );

  const snapshot = await getDocs(cardsQuery);
  return snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
}

export async function getActiveCards(userId, options = {}) {
  const max = Number(options?.limit);

  if (!userId) return [];

  // Index-safe: avoid requiring a composite index on (userId, isActive).
  // We'll query by userId only and filter isActive client-side.
  const queryParts = [collection(db, COLLECTIONS.CARDS), where('userId', '==', userId)];
  if (Number.isFinite(max) && max > 0) queryParts.push(limit(max));

  const q = query(...queryParts);
  const snap = await getDocs(q);
  return snap.docs
    .map((d) => ({ id: d.id, ...d.data() }))
    .filter((c) => c?.isActive === true);
}

export async function getCardsByQuestionIds(userId, questionIds = []) {
  const ids = (Array.isArray(questionIds) ? questionIds : [])
    .map((x) => String(x))
    .filter(Boolean);

  if (!userId || ids.length === 0) return [];

  const chunkSize = 10;
  const results = [];

  for (let i = 0; i < ids.length; i += chunkSize) {
    const chunk = ids.slice(i, i + chunkSize);
    const q = query(
      collection(db, COLLECTIONS.CARDS),
      where('userId', '==', userId),
      where('questionId', 'in', chunk)
    );

    const snap = await getDocs(q);
    snap.docs.forEach((d) => results.push({ id: d.id, ...d.data() }));
  }

  return results;
}

/**
 * Get recent review attempts for analytics
 */
export async function getRecentReviewAttempts(userId, days = 30) {
  const since = new Date();
  since.setDate(since.getDate() - days);

  const attemptsQuery = query(
    collection(db, COLLECTIONS.ATTEMPTS),
    where('userId', '==', userId)
  );

  const snapshot = await getDocs(attemptsQuery);

  const sinceIso = since.toISOString();
  return snapshot.docs
    .map(docSnap => ({ id: docSnap.id, ...docSnap.data() }))
    .filter((a) => {
      const attemptedAt = a?.attemptedAt;
      if (!attemptedAt || typeof attemptedAt !== 'string') return false;
      return attemptedAt >= sinceIso;
    })
    .sort((a, b) => String(a?.attemptedAt || '').localeCompare(String(b?.attemptedAt || '')));
}

/**
 * Get specific card by ID
 * 
 * @param {string} cardId - Card ID
 * @returns {Promise<Object|null>} Card or null
 */
export async function getCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  const cardSnap = await getDoc(cardRef);
  
  if (!cardSnap.exists()) {
    return null;
  }
  
  return { id: cardSnap.id, ...cardSnap.data() };
}

/**
 * Submit a review attempt (CORE SRS FUNCTION)
 * 
 * This is where the magic happens:
 * 1. Records the attempt
 * 2. Updates card state based on result
 * 3. Calculates ONLY the next single review date
 * 
 * @param {string} cardId - Card ID
 * @param {boolean} wasCorrect - Did user answer correctly?
 * @param {Object} attemptData - Additional attempt data
 * @returns {Promise<Object>} Updated card and attempt record
 */
export async function submitReview(cardId, wasCorrect, attemptData = {}) {
  console.log(`📝 Processing review: ${cardId}, correct: ${wasCorrect}`);
  
  // 1. Get current card state
  const card = await getCard(cardId);
  if (!card) {
    throw new Error(`Card not found: ${cardId}`);
  }
  
  // 2. Create attempt record (for audit trail)
  const attemptId = `attempt_${cardId}_${Date.now()}`;
  const attempt = {
    id: attemptId,
    cardId,
    userId: card.userId,
    questionId: card.questionId,
    
    // Attempt details
    attemptNumber: (card.currentAttemptNumber || 0) + 1,
    wasCorrect,
    userAnswer: attemptData.userAnswer || null,
    correctAnswer: attemptData.correctAnswer || null,
    
    // Timing
    timeSpent: attemptData.timeSpent || null,
    attemptedAt: new Date().toISOString(),
    
    // State before attempt (audit)
    stateBefore: {
      interval: card.interval,
      easeFactor: card.easeFactor,
      repetitionCount: card.repetitionCount,
      status: card.status
    },
    
    // Review session
    reviewSessionId: attemptData.reviewSessionId || null,
    
    // Audit
    createdAt: new Date().toISOString()
  };
  
  // 3. Calculate new card state
  const updatedCard = updateCardAfterReview(card, wasCorrect);
  
  // Add state after to attempt record
  attempt.stateAfter = {
    interval: updatedCard.interval,
    easeFactor: updatedCard.easeFactor,
    repetitionCount: updatedCard.repetitionCount,
    status: updatedCard.status
  };
  
  // 4. Save both records in a batch
  const batch = writeBatch(db);
  
  // Save attempt
  batch.set(doc(db, COLLECTIONS.ATTEMPTS, attemptId), attempt);
  
  // Update card
  batch.set(doc(db, COLLECTIONS.CARDS, cardId), updatedCard);
  
  await batch.commit();
  
  console.log(`✅ Review processed successfully:`, {
    cardId,
    wasCorrect,
    nextReview: updatedCard.nextReviewDate,
    newInterval: updatedCard.interval,
    newStatus: updatedCard.status
  });
  
  // 5. Archive if graduated
  if (shouldArchiveCard(updatedCard)) {
    console.log(`🎓 Card graduated! Archiving: ${cardId}`);
    await archiveCard(cardId);
  }

  // Denormalize onto mistake index
  try {
    const fresh = shouldArchiveCard(updatedCard)
      ? { ...updatedCard, isActive: false }
      : updatedCard;
    await upsertMistakeSrsMeta(fresh.userId, fresh.questionId, fresh);
  } catch (e) {
    console.error('⚠️ Failed to update mistake SRS meta:', e);
  }
  
  return {
    card: updatedCard,
    attempt
  };
}

/**
 * Submit multiple reviews in one session
 * 
 * @param {string} userId - User ID
 * @param {Array} reviews - Array of {cardId, wasCorrect, userAnswer}
 * @param {string} sessionType - Session type identifier
 * @returns {Promise<Object>} Session summary
 */
export async function submitReviewSession(userId, reviews, sessionType = 'spaced_repetition') {
  const sessionId = `review_session_${Date.now()}`;
  const startTime = new Date();
  
  console.log(`🎯 Starting review session: ${sessionId} with ${reviews.length} cards`);
  
  let cardsCorrect = 0;
  let cardsFailed = 0;
  const results = [];
  
  // Process each review
  for (const review of reviews) {
    try {
      const result = await submitReview(review.cardId, review.wasCorrect, {
        userAnswer: review.userAnswer,
        correctAnswer: review.correctAnswer,
        timeSpent: review.timeSpent,
        reviewSessionId: sessionId
      });
      
      results.push(result);
      
      if (review.wasCorrect) {
        cardsCorrect++;
      } else {
        cardsFailed++;
      }
    } catch (error) {
      console.error(`❌ Error processing review for card ${review.cardId}:`, error);
      cardsFailed++;
    }
  }
  
  const endTime = new Date();
  const totalTimeSpent = Math.floor((endTime - startTime) / 1000);
  
  // Create session record
  const session = {
    id: sessionId,
    userId,
    
    // Stats
    cardsReviewed: reviews.length,
    cardsCorrect,
    cardsFailed,
    totalTimeSpent,
    
    // Metadata
    sessionType,
    startedAt: startTime.toISOString(),
    completedAt: endTime.toISOString(),
    
    // Audit
    createdAt: new Date().toISOString()
  };
  
  // Save session
  await setDoc(doc(db, COLLECTIONS.SESSIONS, sessionId), session);
  
  console.log(`✅ Review session completed:`, session);
  
  return {
    session,
    results
  };
}

/**
 * Archive a graduated card
 * 
 * @param {string} cardId - Card ID
 */
async function archiveCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  await updateDoc(cardRef, {
    isActive: false,
    archivedAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  });
}

/**
 * Get review statistics for a user
 * 
 * @param {string} userId - User ID
 * @returns {Promise<Object>} Statistics
 */
export async function getReviewStats(userId) {
  // Get all cards
  const cardsQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId)
  );
  
  const cardsSnapshot = await getDocs(cardsQuery);
  const cards = cardsSnapshot.docs.map(doc => doc.data());
  
  const stats = {
    total: cards.length,
    active: cards.filter(c => c.isActive).length,
    archived: cards.filter(c => !c.isActive).length,
    
    // By status
    new: cards.filter(c => c.status === SRS_CONFIG.STATUS.NEW).length,
    learning: cards.filter(c => c.status === SRS_CONFIG.STATUS.LEARNING).length,
    review: cards.filter(c => c.status === SRS_CONFIG.STATUS.REVIEW).length,
    graduated: cards.filter(c => c.status === SRS_CONFIG.STATUS.GRADUATED).length,
    
    // Due today
    dueToday: cards.filter(c => c.isActive && c.isDue).length,
    
    // Performance
    totalAttempts: cards.reduce((sum, c) => sum + (c.totalAttempts || 0), 0),
    successRate: calculateSuccessRate(cards)
  };
  
  return stats;
}

function calculateSuccessRate(cards) {
  const totalAttempts = cards.reduce((sum, c) => sum + (c.totalAttempts || 0), 0);
  const successfulAttempts = cards.reduce((sum, c) => sum + (c.successfulAttempts || 0), 0);
  
  if (totalAttempts === 0) return 0;
  return Math.round((successfulAttempts / totalAttempts) * 100);
}

/**
 * Update isDue flags for all cards (run daily)
 * 
 * @param {string} userId - User ID
 */
export async function updateDueFlags(userId) {
  const today = new Date().toISOString().split('T')[0];
  
  const cardsQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true)
  );
  
  const snapshot = await getDocs(cardsQuery);
  const batch = writeBatch(db);
  
  snapshot.docs.forEach(docSnap => {
    const card = docSnap.data();
    const isDue = isCardDue(card.nextReviewDate, new Date(today));
    
    if (card.isDue !== isDue) {
      batch.update(docSnap.ref, { isDue });
    }
  });
  
  await batch.commit();
}

export const srsService = {
  createCardsFromMistakes,
  getAllCards,
  getActiveCards,
  getCardsByQuestionIds,
  getRecentReviewAttempts,
  getDueCards,
  getCardsDueOnDate,
  getOverdueCount,
  getCard,
  submitReview,
  submitReviewSession,
  getReviewStats,
  updateDueFlags,
  archiveOverdueCards,
  getArchivedCards,
  restoreArchivedCard,
  saveCard,
  deleteCard
};

export default srsService;
=== LanguageContext.jsx (grep hits) ===
129:      masteryNewTitle: "New",
130:      masteryNewDesc: "Not attempted yet.",
133:      masteryMasteredTitle: "Mastered",
134:      masteryMasteredDesc: "3+ correct answers.",
173:      masteryNewTitle: "New",
174:      masteryNewDesc: "Not attempted yet.",
177:      masteryMasteredTitle: "Mastered",
178:      masteryMasteredDesc: "3+ correct answers.",
933:      masteryNotInSrs: "Not in SRS",
934:      masteryNew: "New",
935:      masteryDeveloping: "Developing",
937:      masteryNear: "Near-Mastery",
938:      masteryMastered: "Mastered",
1072:      questionsHidden: "{count} questions hidden…",
1073:      moreQuestionsHidden: "more questions hidden…",
1396:      masteryNewTitle: "未開始",
1397:      masteryNewDesc: "尚未嘗試。",
1400:      masteryMasteredTitle: "已掌握",
1401:      masteryMasteredDesc: "3+ 次答對。",
1975:      masteryNew: "新",
1976:      masteryNotInSrs: "未加入 SRS",
1977:      masteryDeveloping: "發展中",
1979:      masteryNear: "接近精通",
1980:      masteryMastered: "已精通",
2101:      questionsHidden: "{count} 條題目隱藏…",
2102:      moreQuestionsHidden: "更多題目隱藏…",
