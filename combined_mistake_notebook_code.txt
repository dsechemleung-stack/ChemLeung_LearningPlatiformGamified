========================================================================================================================
FILE: functions/index.js
------------------------------------------------------------------------------------------------------------------------
const admin = require('firebase-admin');
const { onSchedule } = require('firebase-functions/v2/scheduler');
const { onDocumentCreated, onDocumentUpdated, onDocumentDeleted } = require('firebase-functions/v2/firestore');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const algoliasearch = require('algoliasearch');

admin.initializeApp();

function encodeKey(value) {
  const s = value == null ? '' : String(value);
  return encodeURIComponent(s);
}

function safeString(value) {
  return value == null ? '' : String(value);
}

function decodeKey(value) {
  const s = value == null ? '' : String(value);
  try {
    return decodeURIComponent(s);
  } catch {
    return s;
  }
}

function normalizeBucket(value) {
  const v = value == null ? '' : String(value);
  if (v === 'not_in_srs' || v === 'new' || v === 'progressing' || v === 'near' || v === 'archived') return v;
  return 'not_in_srs';
}

function getTopicFromMistake(m) {
  if (!m || typeof m !== 'object') return '';
  return safeString(m.Topic || m.topic || '');
}

function getBucketFromMistake(m) {
  if (!m || typeof m !== 'object') return 'not_in_srs';
  return normalizeBucket(m.srsBucket || 'not_in_srs');
}

function getIsActiveFromMistake(m) {
  if (!m || typeof m !== 'object') return false;
  return m.srsIsActive === true;
}

async function applyMistakeTopicStatsDelta(db, userId, delta, topic, bucket, isActive) {
  const uid = safeString(userId);
  const d = Number(delta);
  if (!uid || !Number.isFinite(d) || d === 0) return;

  const topicEnc = encodeKey(topic || '');
  if (!topicEnc) return;

  const b = normalizeBucket(bucket);
  const active = isActive === true;

  const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(statsRef);
    const prev = snap.exists ? (snap.data() || {}) : {};
    const prevTopics = prev.topics && typeof prev.topics === 'object' ? prev.topics : {};
    const prevEntry = prevTopics[topicEnc] && typeof prevTopics[topicEnc] === 'object' ? prevTopics[topicEnc] : {};

    const nextTopics = { ...prevTopics };
    const nextEntry = { ...prevEntry };

    const prevTotal = Number(nextEntry.total || 0);
    const nextTotal = Math.max(0, prevTotal + d);
    nextEntry.total = nextTotal;

    const bucketKey = `b_${b}`;
    const prevBucket = Number(nextEntry[bucketKey] || 0);
    const nextBucket = Math.max(0, prevBucket + d);
    if (nextBucket === 0) delete nextEntry[bucketKey];
    else nextEntry[bucketKey] = nextBucket;

    if (active) {
      const prevActive = Number(nextEntry.active || 0);
      const nextActive = Math.max(0, prevActive + d);
      nextEntry.active = nextActive;
    }

    // Prune empty
    if (nextEntry.total === 0) {
      delete nextTopics[topicEnc];
    } else {
      nextEntry.updatedAt = admin.firestore.FieldValue.serverTimestamp();
      nextTopics[topicEnc] = nextEntry;
    }

    tx.set(statsRef, {
      topics: nextTopics,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });
  });
}

async function applyMistakeDocDelta(db, userId, before, after) {
  const beforeExists = before && typeof before === 'object' && Object.keys(before).length > 0;
  const afterExists = after && typeof after === 'object' && Object.keys(after).length > 0;

  if (!beforeExists && !afterExists) return;

  // Create
  if (!beforeExists && afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      1,
      getTopicFromMistake(after),
      getBucketFromMistake(after),
      getIsActiveFromMistake(after)
    );
    return;
  }

  // Delete
  if (beforeExists && !afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      -1,
      getTopicFromMistake(before),
      getBucketFromMistake(before),
      getIsActiveFromMistake(before)
    );
    return;
  }

  const beforeTopic = getTopicFromMistake(before);
  const afterTopic = getTopicFromMistake(after);
  const beforeBucket = getBucketFromMistake(before);
  const afterBucket = getBucketFromMistake(after);
  const beforeActive = getIsActiveFromMistake(before);
  const afterActive = getIsActiveFromMistake(after);

  const changed =
    beforeTopic !== afterTopic ||
    beforeBucket !== afterBucket ||
    beforeActive !== afterActive;

  if (!changed) return;

  // Remove old
  await applyMistakeTopicStatsDelta(db, userId, -1, beforeTopic, beforeBucket, beforeActive);
  // Add new
  await applyMistakeTopicStatsDelta(db, userId, 1, afterTopic, afterBucket, afterActive);
}

// Maintain mistake topic stats for global sidebar facets
exports.updateMistakeTopicStatsOnCreate = onDocumentCreated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const after = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, null, after);
  }
);

exports.normalizeMistakes = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to normalize mistakes');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');

    const pageSize = 800;
    let last = null;
    let processed = 0;
    let updated = 0;

    const nowIso = new Date().toISOString();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);

      const snap = await q.get();
      if (snap.empty) break;

      // Only write docs that truly need a patch.
      const toPatch = [];
      for (const docSnap of snap.docs) {
        const d = docSnap.data() || {};

        const topic = d.Topic ?? d.topic ?? null;
        const subtopic = d.Subtopic ?? d.subtopic ?? null;
        const lastWrongAt = d.lastWrongAt ?? d.lastAttempted ?? d.updatedAt ?? d.createdAt ?? nowIso;

        const needsTopic = d.Topic == null && d.topic != null;
        const needsSubtopic = d.Subtopic == null && d.subtopic != null;
        const needsLastWrongAt = d.lastWrongAt == null;

        if (needsTopic || needsSubtopic || needsLastWrongAt) {
          toPatch.push({
            ref: docSnap.ref,
            patch: {
              Topic: topic,
              Subtopic: subtopic,
              lastWrongAt,
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          });
        }
      }

      if (toPatch.length > 0) {
        for (let i = 0; i < toPatch.length; i += 450) {
          const batch = db.batch();
          const slice = toPatch.slice(i, i + 450);
          slice.forEach((x) => {
            batch.set(x.ref, x.patch, { merge: true });
          });
          await batch.commit();
          updated += slice.length;
        }
      }

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Make it easy to see when it was last run.
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');
    await statsRef.set({
      lastNormalizedAt: admin.firestore.FieldValue.serverTimestamp(),
      lastNormalizedProcessed: processed,
      lastNormalizedUpdated: updated,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, updated };
  }
);

exports.updateMistakeTopicStatsOnUpdate = onDocumentUpdated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || null;
    const after = event.data?.after?.data?.() || null;
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, after);
  }
);

exports.updateMistakeTopicStatsOnDelete = onDocumentDeleted(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const before = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, null);
  }
);

exports.rebuildMistakeTopicStats = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild mistake topic stats');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

    const topics = {};

    const pageSize = 800;
    let last = null;
    let processed = 0;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);
      const snap = await q.get();
      if (snap.empty) break;

      snap.docs.forEach((docSnap) => {
        const m = docSnap.data() || {};
        const topic = getTopicFromMistake(m);
        if (!topic) return;
        const topicEnc = encodeKey(topic);
        const bucket = getBucketFromMistake(m);
        const isActive = getIsActiveFromMistake(m);

        const entry = topics[topicEnc] && typeof topics[topicEnc] === 'object' ? topics[topicEnc] : {};
        entry.total = Number(entry.total || 0) + 1;
        const bucketKey = `b_${bucket}`;
        entry[bucketKey] = Number(entry[bucketKey] || 0) + 1;
        if (isActive) entry.active = Number(entry.active || 0) + 1;
        topics[topicEnc] = entry;
      });

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    await statsRef.set({
      topics,
      processed,
      rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, topics: Object.keys(topics).length };
  }
);

async function applySrsSummaryDelta(db, userId, dateStr, delta, topic, subtopic) {
  const uid = safeString(userId);
  const dateKey = safeString(dateStr);
  if (!uid || !dateKey || !Number.isFinite(delta) || delta === 0) return;

  const topicKey = encodeKey(topic || '');
  const subtopicKey = encodeKey(subtopic || '');
  const hasTopic = Boolean(topicKey);
  const hasSubtopic = Boolean(topicKey) && Boolean(subtopicKey);
  const compoundSubKey = hasSubtopic ? `${topicKey}::${subtopicKey}` : '';

  const summaryRef = db.collection('users').doc(uid).collection('srs_daily_summaries').doc(dateKey);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(summaryRef);
    const prev = snap.exists ? (snap.data() || {}) : {};

    const next = { ...prev };
    next.date = dateKey;
    next.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    const prevTotal = Number(prev.dueTotal || 0);
    next.dueTotal = Math.max(0, prevTotal + delta);

    const prevTopics = prev.topicCounts && typeof prev.topicCounts === 'object' ? prev.topicCounts : {};
    const prevSubs = prev.subtopicCounts && typeof prev.subtopicCounts === 'object' ? prev.subtopicCounts : {};

    const nextTopics = { ...prevTopics };
    const nextSubs = { ...prevSubs };

    if (hasTopic) {
      const old = Number(nextTopics[topicKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextTopics[topicKey];
      else nextTopics[topicKey] = v;
    }

    if (hasSubtopic) {
      const old = Number(nextSubs[compoundSubKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextSubs[compoundSubKey];
      else nextSubs[compoundSubKey] = v;
    }

    next.topicCounts = nextTopics;
    next.subtopicCounts = nextSubs;

    tx.set(summaryRef, next, { merge: true });
  });
}

function isActiveCard(card) {
  if (!card || typeof card !== 'object') return false;
  if (card.isActive === false) return false;
  if (!card.userId) return false;
  if (!card.nextReviewDate) return false;
  return true;
}

// Define secrets (use new Firebase Functions params API)
const algoliaAppId = defineSecret('ALGOLIA_APP_ID');
const algoliaAdminKey = defineSecret('ALGOLIA_ADMIN_KEY');
const ALGOLIA_INDEX_NAME = 'forum_posts';

// Initialize Algolia client lazily at runtime
function getAlgoliaClient() {
  const appId = algoliaAppId.value();
  const adminKey = algoliaAdminKey.value();
  if (!appId || !adminKey) return null;
  return algoliasearch(appId, adminKey);
}

exports.aggregateCommentQuestionStatsOnCommentCreate = onDocumentCreated(
  {
    document: 'comments/{commentId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;

    const comment = snap.data() || {};
    const questionId = comment.questionId != null ? String(comment.questionId) : '';
    if (!questionId) return;

    const createdAt = typeof comment.createdAt === 'string'
      ? comment.createdAt
      : new Date().toISOString();

    const db = admin.firestore();
    const statsRef = db.collection('comment_question_stats').doc(questionId);

    await db.runTransaction(async (tx) => {
      const statsSnap = await tx.get(statsRef);
      const prev = statsSnap.exists ? (statsSnap.data() || {}) : {};

      const prevLast = typeof prev.lastActivity === 'string' ? prev.lastActivity : '';
      const nextLastActivity = prevLast && prevLast > createdAt ? prevLast : createdAt;

      tx.set(statsRef, {
        questionId,
        commentCount: admin.firestore.FieldValue.increment(1),
        lastActivity: nextLastActivity,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.rebuildSrsDailySummaries = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild summaries');
    }

    const db = admin.firestore();

    // Page through all active cards for this user
    const cardsRef = db.collection('spaced_repetition_cards');
    const pageSize = 500;
    let last = null;
    let totalCards = 0;

    // dateStr => { dueTotal, topicCounts, subtopicCounts }
    const aggregated = new Map();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = cardsRef
        .where('userId', '==', uid)
        .where('isActive', '==', true)
        .orderBy(admin.firestore.FieldPath.documentId())
        .limit(pageSize);

      if (last) {
        q = q.startAfter(last);
      }

      const snap = await q.get();
      if (snap.empty) break;

      for (const docSnap of snap.docs) {
        const card = docSnap.data() || {};
        if (!card.nextReviewDate) continue;

        const dateKey = safeString(card.nextReviewDate);
        const topicEnc = encodeKey(card.topic || '');
        const subEnc = encodeKey(card.subtopic || '');
        const compound = (topicEnc && subEnc) ? `${topicEnc}::${subEnc}` : '';

        if (!aggregated.has(dateKey)) {
          aggregated.set(dateKey, {
            date: dateKey,
            dueTotal: 0,
            topicCounts: {},
            subtopicCounts: {},
          });
        }

        const entry = aggregated.get(dateKey);
        entry.dueTotal += 1;

        if (topicEnc) {
          entry.topicCounts[topicEnc] = (entry.topicCounts[topicEnc] || 0) + 1;
        }
        if (compound) {
          entry.subtopicCounts[compound] = (entry.subtopicCounts[compound] || 0) + 1;
        }
      }

      totalCards += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Write summaries for encountered dates (overwrite those docs).
    const summariesRef = db.collection('users').doc(uid).collection('srs_daily_summaries');
    const dateKeys = Array.from(aggregated.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    let written = 0;
    for (let i = 0; i < dateKeys.length; i += 400) {
      const batch = db.batch();
      const slice = dateKeys.slice(i, i + 400);

      for (const dateKey of slice) {
        const data = aggregated.get(dateKey);
        const ref = summariesRef.doc(dateKey);
        batch.set(ref, {
          date: data.date,
          dueTotal: data.dueTotal,
          topicCounts: data.topicCounts,
          subtopicCounts: data.subtopicCounts,
          rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
      }

      await batch.commit();
      written += slice.length;
    }

    return {
      ok: true,
      userId: uid,
      cardsProcessed: totalCards,
      datesWritten: written,
    };
  }
);

// Maintain SRS daily summaries (cheap calendar counts)
exports.updateSrsDailySummaryOnCardCreate = onDocumentCreated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, 1, card.topic, card.subtopic);
  }
);

exports.updateSrsDailySummaryOnCardUpdate = onDocumentUpdated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || {};
    const after = event.data?.after?.data?.() || {};

    const beforeActive = isActiveCard(before);
    const afterActive = isActiveCard(after);

    const db = admin.firestore();

    // Removed from active set
    if (beforeActive && !afterActive) {
      await applySrsSummaryDelta(db, before.userId, before.nextReviewDate, -1, before.topic, before.subtopic);
      return;
    }

    // Added to active set
    if (!beforeActive && afterActive) {
      await applySrsSummaryDelta(db, after.userId, after.nextReviewDate, 1, after.topic, after.subtopic);
      return;
    }

    if (!beforeActive && !afterActive) return;

    const uid = after.userId || before.userId;
    const beforeDate = safeString(before.nextReviewDate);
    const afterDate = safeString(after.nextReviewDate);
    const beforeTopic = safeString(before.topic);
    const afterTopic = safeString(after.topic);
    const beforeSub = safeString(before.subtopic);
    const afterSub = safeString(after.subtopic);

    const dateChanged = beforeDate !== afterDate;
    const topicChanged = beforeTopic !== afterTopic;
    const subChanged = beforeSub !== afterSub;

    if (!dateChanged && !topicChanged && !subChanged) return;

    // Remove old
    await applySrsSummaryDelta(db, uid, beforeDate, -1, beforeTopic, beforeSub);
    // Add new
    await applySrsSummaryDelta(db, uid, afterDate, 1, afterTopic, afterSub);
  }
);

exports.updateSrsDailySummaryOnCardDelete = onDocumentDeleted(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, -1, card.topic, card.subtopic);
  }
);

 function toHongKongDate(dateObj) {
   // Convert an instant-in-time to a Date whose UTC fields represent Asia/Hong_Kong local time.
   // This avoids discrepancies between browser local time (HK) and Cloud Functions runtime (UTC).
   const d = dateObj instanceof Date ? dateObj : new Date(dateObj);
   return new Date(d.getTime() + 8 * 60 * 60 * 1000);
 }

function getWeeklyKeyForDate(dateObj) {
  // Use UTC getters so output is independent of the runtime's local timezone.
  const date = new Date(Date.UTC(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
  const yyyy = date.getUTCFullYear();
  return `leaderboard_weekly_${yyyy}-W${String(weekNo).padStart(2, '0')}`;
}

function weeklyTokensForRank(rank) {
  const r = Number(rank || 0);
  if (!Number.isFinite(r) || r <= 0) return 0;
  // Keep consistent with frontend logic: max(0, 11 - rank)
  return Math.max(0, 11 - r);
}

exports.aggregateWeeklyLeaderboardOnAttemptCreate = onDocumentCreated(
  {
    document: 'attempts/{attemptId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const attemptData = snap.data() || {};
    const userId = attemptData.userId;
    if (!userId) return;

    const attemptTs = attemptData.timestamp ? new Date(attemptData.timestamp) : new Date();
    const weekId = getWeeklyKeyForDate(toHongKongDate(attemptTs));

    const db = admin.firestore();
    const entryRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries').doc(userId);
    const userRef = db.collection('users').doc(userId);

    await db.runTransaction(async (tx) => {
      const [entrySnap, userSnap] = await Promise.all([
        tx.get(entryRef),
        tx.get(userRef),
      ]);

      const userData = userSnap.exists ? userSnap.data() : {};
      const prev = entrySnap.exists ? entrySnap.data() : {};

      const prevAttemptCount = Number(prev.attemptCount || 0);
      const prevTotalScore = Number(prev.totalScore || 0);
      const prevTotalQuestions = Number(prev.totalQuestions || 0);
      const prevTotalCorrect = Number(prev.totalCorrect || 0);

      const nextAttemptCount = prevAttemptCount + 1;
      const nextTotalScore = prevTotalScore + Number(attemptData.percentage || 0);
      const nextTotalQuestions = prevTotalQuestions + Number(attemptData.totalQuestions || 0);
      const nextTotalCorrect = prevTotalCorrect + Number(attemptData.correctAnswers || 0);
      const nextAverageScore = nextAttemptCount > 0 ? Math.round(nextTotalScore / nextAttemptCount) : 0;

      tx.set(entryRef, {
        userId,
        weekId,
        displayName: userData?.displayName || 'Unknown',
        level: userData?.level || null,
        equippedProfilePic: (userData?.equipped || {}).profilePic || 'flask_blue',
        equippedTheme: (userData?.equipped || {}).theme || 'default',
        streak: Number(userData?.streak || 0),
        attemptCount: nextAttemptCount,
        totalScore: nextTotalScore,
        averageScore: nextAverageScore,
        totalQuestions: nextTotalQuestions,
        totalCorrect: nextTotalCorrect,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.weeklyLeaderboardPayout = onSchedule(
  {
    schedule: '0 0 * * 1',
    timeZone: 'Asia/Hong_Kong',
    region: 'asia-east1',
  },
  async () => {
    const db = admin.firestore();

    // Run payout for LAST week (so the leaderboard is complete)
    const now = toHongKongDate(new Date());
    const lastWeekDate = new Date(now);
    lastWeekDate.setDate(lastWeekDate.getDate() - 7);
    const weekId = getWeeklyKeyForDate(toHongKongDate(lastWeekDate));

    const entriesRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries');
    const topSnap = await entriesRef.orderBy('averageScore', 'desc').limit(10).get();

    if (topSnap.empty) return;

    // Batch-like loop (transactions per user to keep idempotency + correct balances)
    const payoutPromises = topSnap.docs.map(async (docSnap, idx) => {
      const entry = docSnap.data() || {};
      const userId = entry.userId || docSnap.id;
      const rank = idx + 1;
      const tokens = weeklyTokensForRank(rank);
      if (!userId || tokens <= 0) return;

      const payoutRef = db
        .collection('weekly_leaderboards')
        .doc(weekId)
        .collection('payouts')
        .doc(userId);

      const userRef = db.collection('users').doc(userId);

      await db.runTransaction(async (tx) => {
        const [payoutSnap, userSnap] = await Promise.all([
          tx.get(payoutRef),
          tx.get(userRef),
        ]);

        if (payoutSnap.exists) {
          return; // already paid
        }

        if (!userSnap.exists) {
          // still record payout marker to avoid repeated attempts
          tx.set(payoutRef, {
            userId,
            weekId,
            rank,
            tokens,
            skipped: true,
            reason: 'User doc missing',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          });
          return;
        }

        const userData = userSnap.data() || {};
        const currentTokens = Number(userData.tokens || 0);
        const newTokens = currentTokens + tokens;

        tx.update(userRef, {
          tokens: newTokens,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const historyRef = userRef.collection('tokenHistory').doc();
        tx.set(historyRef, {
          amount: tokens,
          reason: `Leaderboard Reward: weekly #${rank}`,
          type: 'gain',
          timestamp: admin.firestore.FieldValue.serverTimestamp(),
          balanceAfter: newTokens,
          metadata: {
            category: 'leaderboard',
            period: 'weekly',
            rank,
            weekId,
          },
        });

        const notifRef = db.collection('notifications').doc();
        tx.set(notifRef, {
          recipientId: userId,
          senderId: 'system',
          type: 'leaderboard_reward',
          senderDisplayName: 'System',
          previewText: `Weekly leaderboard #${rank}: +${tokens} tokens`,
          read: false,
          createdAt: new Date().toISOString(),
          weekId,
          rank,
          tokens,
        });

        tx.set(payoutRef, {
          userId,
          weekId,
          rank,
          tokens,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      });
    });

    await Promise.all(payoutPromises);
  }
);

// === Algolia search sync for forum_posts ===

// Helper: prepare Algolia record from Firestore doc
function toAlgoliaRecord(postId, data) {
  return {
    objectID: postId,
    title: data.title || '',
    content: data.content || '',
    category: data.category || '',
    userDisplayName: data.userDisplayName || '',
    userId: data.userId || '',
    createdAt: data.createdAt || '',
    // You can add more fields if you want them searchable/filterable
  };
}

// Create: when a new forum post is created
exports.syncForumPostToAlgoliaOnCreate = onDocumentCreated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Update: when a forum post is updated
exports.syncForumPostToAlgoliaOnUpdate = onDocumentUpdated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.after.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Delete: when a forum post is deleted
exports.syncForumPostToAlgoliaOnDelete = onDocumentDeleted(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const postId = event.params.postId;
    await algoliaIndex.deleteObject(postId);
  }
);

========================================================================================================================
FILE: src/pages/MistakeNotebookPage.jsx
------------------------------------------------------------------------------------------------------------------------
// MistakeNotebookPage.jsx - Spaced Repetition Integration
import React, {
  useState, useEffect, useMemo, useCallback, useRef,
} from 'react';
import { createPortal } from 'react-dom';
import { useNavigate } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import ChemistryLoading from '../components/ChemistryLoading';
import { quizService } from '../services/quizService';
import { quizStorage } from '../utils/quizStorage';
import { useFloating, offset, flip, shift, autoUpdate } from '@floating-ui/react';
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { db } from '../firebase/config';
import app from '../firebase/config';
import { collection, doc, getCountFromServer, getDoc, getDocs, limit, orderBy, query, startAfter, where, writeBatch } from 'firebase/firestore';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { formatHKDateKey } from '../utils/hkTime';
import { getNow } from '../utils/timeTravel';
import {
  BookOpen, ArrowLeft, Play, AlertCircle, Target,
  CheckCircle, Filter, ChevronDown, Calendar, Hash, Tag,
  Clock, Zap, TrendingUp, Brain, BarChart2, Layers, X,
  AlertTriangle, Flame, Star, PlusCircle, Wand2, Eye, EyeOff, 
  Grid3x3, List as ListIcon, Command, Archive, Sparkles,
  ChevronRight, Maximize2, Check, Activity, LineChart,
} from 'lucide-react';

// ADD THIS IMPORT:
import { calendarService } from '../services/calendarService';
import { srsService } from '../services/srsService';

// ═══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════
const MASTERY_THRESHOLD = 3;
const ERROR_TYPES = [
  { value: 'misread', labelKey: 'notebook.errorTypeMisread', color: 'blue' },
  { value: 'calculation', labelKey: 'notebook.errorTypeCalculation', color: 'red' },
  { value: 'conceptual', labelKey: 'notebook.errorTypeConceptual', color: 'orange' },
  { value: 'careless', labelKey: 'notebook.errorTypeCareless', color: 'yellow' },
  { value: 'vocab', labelKey: 'notebook.errorTypeVocab', color: 'purple' },
  { value: 'diagram', labelKey: 'notebook.errorTypeDiagram', color: 'pink' },
];
const MASTERY_LEVELS = {
  not_in_srs:  { labelKey: 'notebook.masteryNotInSrs', color: 'slate' },
  new:        { labelKey: 'notebook.masteryNew', color: 'red' },
  progressing:{ labelKey: 'notebook.masteryDeveloping', color: 'amber' },
  near:       { labelKey: 'notebook.masteryNear', color: 'yellow' },
  archived:   { labelKey: 'notebook.mastered', color: 'green' },
};

function buildMistakeCountBaseConstraints({ userId, datePeriod, selectedTopics, selectedSubtopics, srsPresence }) {
  const now = getNow();
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);
  const monthAgo = new Date(now);
  monthAgo.setMonth(monthAgo.getMonth() - 1);

  const base = [collection(db, 'users', userId, 'mistakes')];

  if (datePeriod === 'week') {
    base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
  } else if (datePeriod === 'month') {
    base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
  }

  const topics = (Array.isArray(selectedTopics) ? selectedTopics : []).filter(Boolean);
  const subs = (Array.isArray(selectedSubtopics) ? selectedSubtopics : []).filter(Boolean);

  const canUseTopicsIn = topics.length >= 2 && topics.length <= 10;
  const canUseSubtopicsIn = subs.length >= 2 && subs.length <= 10;

  if (topics.length === 1) {
    base.push(where('Topic', '==', topics[0]));
  } else if (canUseTopicsIn) {
    base.push(where('Topic', 'in', topics));
  }

  const topicUsesIn = canUseTopicsIn;
  const topicUsesEq = topics.length === 1;

  if (subs.length === 1) {
    base.push(where('Subtopic', '==', subs[0]));
  } else if (canUseSubtopicsIn && !topicUsesIn) {
    base.push(where('Subtopic', 'in', subs));
  }

  return {
    base,
    needsClientTopicFilter: topics.length > 10,
    needsClientSubtopicFilter: (subs.length > 10) || (canUseSubtopicsIn && topicUsesIn) || (!topicUsesEq && subs.length > 0 && !canUseSubtopicsIn),
    needsClientSrsPresenceFilter: srsPresence !== 'all',
    topics,
    subs,
  };
}

async function backfillMistakeSrsFromActiveCards(userId) {
  const uid = String(userId || '');
  if (!uid) return false;

  const sessionKey = `mistake_srs_sync_active_v1_${uid}`;
  try {
    if (sessionStorage.getItem(sessionKey) === '1') return false;
    sessionStorage.setItem(sessionKey, '1');
  } catch {
    // ignore
  }

  try {
    const activeCards = await srsService.getActiveCards(uid, { limit: 800 });
    if (!activeCards || activeCards.length === 0) return false;

    const nowIso = new Date().toISOString();
    let wrote = false;

    for (let i = 0; i < activeCards.length; i += 450) {
      const batch = writeBatch(db);
      const slice = activeCards.slice(i, i + 450);
      slice.forEach((c) => {
        const qid = c?.questionId;
        if (!qid) return;
        let bucket = 'progressing';
        if (c.status === 'new') bucket = 'new';
        else if (c.status === 'learning') bucket = 'progressing';
        else if (c.status === 'review') bucket = 'near';
        else if (c.status === 'graduated') bucket = 'archived';

        batch.set(
          doc(db, 'users', uid, 'mistakes', String(qid)),
          {
            hasSrsCard: true,
            srsIsActive: true,
            srsStatus: c.status || null,
            srsBucket: bucket,
            srsCardId: c.id || null,
            srsUpdatedAt: nowIso,
            updatedAt: nowIso,
          },
          { merge: true }
        );
      });
      await batch.commit();
      wrote = true;
    }

    return wrote;
  } catch (e) {
    console.error('Failed to backfill mistakes from active SRS cards:', e);
    return false;
  }
}

async function backfillMissingTopicCaseForTopic(userId, topic) {
  const uid = String(userId || '');
  const t = String(topic || '');
  if (!uid || !t) return false;

  try {
    const snap = await getDocs(
      query(
        collection(db, 'users', uid, 'mistakes'),
        where('topic', '==', t),
        limit(500)
      )
    );

    const toFix = snap.docs
      .map((d) => ({ ref: d.ref, data: d.data() }))
      .filter((x) => !x?.data?.Topic);

    if (toFix.length === 0) return false;

    const nowIso = new Date().toISOString();
    const batch = writeBatch(db);
    toFix.slice(0, 450).forEach((x) => {
      batch.set(
        x.ref,
        {
          Topic: x?.data?.topic || t,
          Subtopic: x?.data?.Subtopic ?? x?.data?.subtopic ?? null,
          updatedAt: x?.data?.updatedAt || nowIso,
        },
        { merge: true }
      );
    });
    await batch.commit();
    return true;
  } catch (e) {
    console.error('Failed to backfill missing Topic field for topic:', e);
    return false;
  }
}

async function backfillMissingLastWrongAtForTopic(userId, topic) {
  const uid = String(userId || '');
  const t = String(topic || '');
  if (!uid || !t) return false;

  try {
    const snap = await getDocs(
      query(
        collection(db, 'users', uid, 'mistakes'),
        where('Topic', '==', t),
        limit(500)
      )
    );

    const toFix = snap.docs
      .map((d) => ({ ref: d.ref, data: d.data() }))
      .filter((x) => !x?.data?.lastWrongAt);

    if (toFix.length === 0) return false;

    const nowIso = new Date().toISOString();
    const batch = writeBatch(db);
    toFix.slice(0, 450).forEach((x) => {
      const fallback = x?.data?.lastAttempted || x?.data?.updatedAt || x?.data?.createdAt || nowIso;
      batch.set(
        x.ref,
        {
          lastWrongAt: fallback,
          updatedAt: x?.data?.updatedAt || nowIso,
        },
        { merge: true }
      );
    });
    await batch.commit();
    return true;
  } catch (e) {
    console.error('Failed to backfill missing lastWrongAt for topic:', e);
    return false;
  }
}

async function backfillMistakeSrsDefaults(userId, rows = []) {
  const uid = String(userId || '');
  if (!uid) return false;

  const targets = (Array.isArray(rows) ? rows : []).filter((r) => {
    const hasBucket = Object.prototype.hasOwnProperty.call(r || {}, 'srsBucket');
    const hasHasSrs = Object.prototype.hasOwnProperty.call(r || {}, 'hasSrsCard');
    const hasActive = Object.prototype.hasOwnProperty.call(r || {}, 'srsIsActive');

    const hasTopic = Object.prototype.hasOwnProperty.call(r || {}, 'Topic');
    const hasSubtopic = Object.prototype.hasOwnProperty.call(r || {}, 'Subtopic');
    const hasLastWrongAt = Object.prototype.hasOwnProperty.call(r || {}, 'lastWrongAt');

    const needsSrsDefaults = !(hasBucket && hasHasSrs && hasActive);
    const needsTopicShape = !(hasTopic && hasSubtopic && hasLastWrongAt);
    return needsSrsDefaults || needsTopicShape;
  });

  if (targets.length === 0) return false;

  try {
    const batch = writeBatch(db);
    const nowIso = new Date().toISOString();
    targets.slice(0, 450).forEach((r) => {
      const qid = r?.questionId ?? r?.ID ?? r?.docId ?? r?.id;
      if (!qid) return;

      const topic = r?.Topic ?? r?.topic ?? null;
      const subtopic = r?.Subtopic ?? r?.subtopic ?? null;
      const lastWrongAt = r?.lastWrongAt ?? r?.lastAttempted ?? r?.updatedAt ?? nowIso;

      batch.set(
        doc(db, 'users', uid, 'mistakes', String(qid)),
        {
          hasSrsCard: r?.hasSrsCard === true,
          srsIsActive: r?.srsIsActive === true,
          srsStatus: r?.srsStatus ?? null,
          srsBucket: r?.srsBucket ?? (r?.hasSrsCard ? 'progressing' : 'not_in_srs'),
          srsCardId: r?.srsCardId ?? null,
          srsUpdatedAt: nowIso,
          Topic: topic,
          Subtopic: subtopic,
          lastWrongAt,
          updatedAt: r?.updatedAt ?? nowIso,
        },
        { merge: true }
      );
    });
    await batch.commit();
    return true;
  } catch (e) {
    console.error('Failed to backfill mistake SRS defaults:', e);
    return false;
  }
}

function buildMistakeIndexQueryConstraints({ userId, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, cursor, pageSize }) {
  const now = getNow();
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);
  const monthAgo = new Date(now);
  monthAgo.setMonth(monthAgo.getMonth() - 1);

  const base = [collection(db, 'users', userId, 'mistakes')];

  if (datePeriod === 'week') {
    base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
  } else if (datePeriod === 'month') {
    base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
  }

  const topics = (Array.isArray(selectedTopics) ? selectedTopics : []).filter(Boolean);
  const subs = (Array.isArray(selectedSubtopics) ? selectedSubtopics : []).filter(Boolean);
  const masteryLevels = (Array.isArray(selectedMasteryLevels) ? selectedMasteryLevels : []).filter(Boolean);

  const canUseTopicsIn = topics.length >= 2 && topics.length <= 10;
  const canUseSubtopicsIn = subs.length >= 2 && subs.length <= 10;
  const canUseMasteryIn = masteryLevels.length >= 2 && masteryLevels.length <= 10;

  // Firestore limitation: you can't combine two different "in" filters in one query.
  // We prioritize Topic server-side; Subtopic may fall back to client-side filtering.
  if (topics.length === 1) {
    base.push(where('Topic', '==', topics[0]));
  } else if (canUseTopicsIn) {
    base.push(where('Topic', 'in', topics));
  }

  const topicUsesIn = canUseTopicsIn;
  const topicUsesEq = topics.length === 1;

  if (subs.length === 1) {
    base.push(where('Subtopic', '==', subs[0]));
  } else if (canUseSubtopicsIn && !topicUsesIn) {
    base.push(where('Subtopic', 'in', subs));
  }

  // SRS Presence (client-side)
  // Avoid composite index requirements (e.g. where(srsIsActive==true) + orderBy(lastWrongAt)).
  // We'll filter fetched rows by srsPresence during the bounded overfetch loop.

  // Mastery filter (srsBucket) is applied client-side.
  // Avoid composite index requirements (e.g. where(srsBucket==X) + orderBy(lastWrongAt)).

  base.push(orderBy('lastWrongAt', 'desc'));
  if (cursor) base.push(startAfter(cursor));
  base.push(limit(pageSize));

  return {
    q: query(...base),
    // Anything not encoded in the query needs a client-side filter.
    needsClientTopicFilter: topics.length > 10,
    needsClientSubtopicFilter: (subs.length > 10) || (canUseSubtopicsIn && topicUsesIn) || (!topicUsesEq && subs.length > 0 && !canUseSubtopicsIn),
    needsClientMasteryFilter: masteryLevels.length > 0,
    needsClientSrsPresenceFilter: srsPresence !== 'all',
    topics,
    subs,
    masteryLevels,
  };
}

function matchesSrsPresence(row, srsPresence) {
  if (srsPresence === 'in_srs') return row?.srsIsActive === true;
  if (srsPresence === 'not_in_srs') return (row?.srsBucket || 'not_in_srs') === 'not_in_srs';
  return true;
}

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════
function calculateMasteryPriority(mistake, recentTopics = []) {
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));
  const U = Math.pow(2, daysSinceLastAttempt / 7);
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);
  let R = 0.5;
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5;
  }
  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

function getSrsBucket(card) {
  if (!card) return 'not_in_srs';
  if (card?.srsBucket) return card.srsBucket;
  if (card?.hasSrsCard === false) return 'not_in_srs';
  const looksLikeSrsCard =
    card?.hasSrsCard === true ||
    !!card?.status ||
    !!card?.nextReviewDate ||
    !!card?.questionId;
  if (!looksLikeSrsCard) return 'not_in_srs';
  if (card.isActive === false) return 'archived';
  if (card.status === 'new') return 'new';
  if (card.status === 'learning') return 'progressing';
  if (card.status === 'review') return 'near';
  if (card.status === 'graduated') return 'archived';
  return 'progressing';
}

function getSrsBucketState(bucket) {
  if (bucket === 'not_in_srs') return { state: 0, labelKey: 'notebook.masteryNotInSrs', color: 'slate' };
  if (bucket === 'new') return { state: 0, labelKey: 'notebook.masteryNew', color: 'red' };
  if (bucket === 'progressing') return { state: 1, labelKey: 'notebook.masteryDeveloping', color: 'amber' };
  if (bucket === 'near') return { state: 2, labelKey: 'notebook.masteryNear', color: 'yellow' };
  if (bucket === 'archived') return { state: 3, labelKey: 'notebook.mastered', color: 'green' };
  return { state: 3, labelKey: 'notebook.masteryMastered', color: 'green' };
}

function getSrsContributionWeight(card) {
  if (!card) return 1;
  if (card.isActive === false) return 0.1;
  if (card.status === 'graduated') return 0.1;
  const rep = Number(card.repetitionCount || 0);
  const byRep = 1 / (1 + rep);
  if (card.status === 'review') return Math.max(0.2, byRep);
  if (card.status === 'learning') return Math.max(0.35, byRep);
  return 1;
}

function calcPriority(mistake) {
  const last = mistake.lastAttempted || mistake.lastReviewedAt || mistake.createdAt;
  const days = last ? (Date.now() - new Date(last).getTime()) / (1000 * 60 * 60 * 24) : 0;
  const rep = mistake.repetitionCount ?? mistake.improvementCount ?? 0;
  return days * 1.2 - rep * 2;
}

function masteryStyle(improvementCount) {
  if (improvementCount >= 2)
    return {
      border: 'border-green-300',
      bg: 'bg-green-50/60',
      badge: 'bg-green-100 text-green-700',
      dot: 'bg-green-500',
    };
  if (improvementCount === 1)
    return {
      border: 'border-amber-300',
      bg: 'bg-amber-50/60',
      badge: 'bg-amber-100 text-amber-700',
      dot: 'bg-amber-400',
    };
  return {
    border: 'border-red-200',
    bg: 'bg-white',
    badge: 'bg-red-100 text-red-700',
    dot: 'bg-red-500',
  };
}

function applyRuleOfThree(improvements) {
  return improvements;
}

// ═══════════════════════════════════════════════════════════════════════════════
// SPACED REPETITION INTEGRATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Schedule spaced repetition events for new mistakes
 */
async function scheduleSpacedRepetitionForMistakes(mistakesList, currentUser) {
  if (!currentUser?.uid) return;

  return;

  try {
    // Only schedule for mistakes that are new or need review
    const mistakesToSchedule = mistakesList.filter(m => m.attemptCount >= 1);

    // Schedule in batches to avoid overwhelming Firebase
    for (const mistake of mistakesToSchedule) {
      try {
        await calendarService.scheduleSpacedRepetition(currentUser.uid, {
          questionId: mistake.ID,
          topic: mistake.Topic,
          subtopic: mistake.Subtopic,
          attemptCount: mistake.attemptCount
        });
      } catch (error) {
        console.error('Error scheduling repetition for', mistake.ID, error);
        // Continue with other mistakes even if one fails
      }
    }
  } catch (error) {
    console.error('Error scheduling spaced repetitions:', error);
  }
}

/**
 * Call this function when processing quiz results for real-time scheduling
 */
async function handleMistakeCommitted(currentUser, question, attemptCount) {
  if (!currentUser?.uid) return;

  return;
  
  try {
    await calendarService.scheduleSpacedRepetition(currentUser.uid, {
      questionId: question.ID,
      topic: question.Topic,
      subtopic: question.Subtopic,
      attemptCount
    });
  } catch (error) {
    console.error('Error scheduling spaced repetition:', error);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// UI COMPONENTS
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * FullQuestionModal: Pop-up to show complete question details
 */
function FullQuestionModal({ mistake, errorTag, onTag, onClose }) {
  const { t } = useLanguage();
  const [selectedTag, setSelectedTag] = useState(errorTag || '');

  const handleTagSelect = (tag) => {
    setSelectedTag(tag);
    onTag(mistake.ID, tag);
  };

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[100] p-4 overflow-y-auto">
      <motion.div 
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl my-6"
      >
        {/* Header */}
        <div className="bg-gradient-to-r from-slate-700 to-slate-900 p-4 sm:p-6 rounded-t-2xl flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-black text-white mb-1">{t('notebook.questionDetail')}</h2>
            <p className="text-slate-300 text-sm">{mistake.Topic} → {mistake.Subtopic}</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-white/20 rounded-lg transition-all text-white"
          >
            <X size={24} />
          </button>
        </div>

        <div className="p-4 sm:p-8 space-y-6 max-h-[70vh] overflow-y-auto">
          {/* Question */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.question')}
            </h3>
            <div
              className="prose prose-slate max-w-none text-base bg-slate-50 p-4 rounded-xl border-2 border-slate-200"
              dangerouslySetInnerHTML={{ __html: mistake.Question }}
            />
          </div>

          {/* Image if exists */}
          {mistake.Pictureurl && (
            <div className="flex justify-center">
              <img 
                src={mistake.Pictureurl} 
                alt={t('notebook.questionDiagramAlt')} 
                className="max-h-96 object-contain rounded-lg border-2 border-slate-200 shadow-md" 
              />
            </div>
          )}

          {/* Options Grid */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.options')}
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {['A', 'B', 'C', 'D'].map((opt) => {
                const isUserAnswer = mistake.userAnswer === opt;
                const isCorrect = mistake.CorrectOption === opt;
                
                return (
                  <div
                    key={opt}
                    className={`p-4 rounded-xl border-2 ${
                      isCorrect
                        ? 'border-green-500 bg-green-50'
                        : isUserAnswer
                        ? 'border-red-500 bg-red-50'
                        : 'border-slate-200 bg-white'
                    }`}
                  >
                    <div className="flex items-start gap-3">
                      <div className={`w-8 h-8 rounded-full flex items-center justify-center font-black text-sm flex-shrink-0 ${
                        isCorrect
                          ? 'bg-green-500 text-white'
                          : isUserAnswer
                          ? 'bg-red-500 text-white'
                          : 'bg-slate-200 text-slate-600'
                      }`}>
                        {opt}
                      </div>
                      <div className="flex-1">
                        {isCorrect && (
                          <div className="text-xs font-bold text-green-700 mb-1 flex items-center gap-1">
                            <CheckCircle size={12} /> {t('notebook.correctAnswer')}
                          </div>
                        )}
                        {isUserAnswer && !isCorrect && (
                          <div className="text-xs font-bold text-red-700 mb-1">
                            {t('notebook.yourAnswer')}
                          </div>
                        )}
                        <div className={`text-sm ${
                          isCorrect ? 'text-green-900 font-semibold' : isUserAnswer ? 'text-red-900' : 'text-slate-700'
                        }`}>
                          {mistake[`Option${opt}`] || opt}
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* Explanation */}
          {mistake.Explanation && (
            <div>
              <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3 flex items-center gap-2">
                <BookOpen size={16} className="text-blue-600" />
                {t('notebook.explanation')}
              </h3>
              <div
                className="prose prose-slate max-w-none text-sm bg-blue-50 p-4 rounded-xl border-2 border-blue-200"
                dangerouslySetInnerHTML={{ __html: mistake.Explanation }}
              />
            </div>
          )}

          {/* Error Type Tagging */}
          <div>
            <h3 className="text-sm font-black text-slate-500 uppercase tracking-widest mb-3">
              {t('notebook.tagErrorType')}
            </h3>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {ERROR_TYPES.map((type) => (
                <button
                  key={type.value}
                  onClick={() => handleTagSelect(type.value)}
                  className={`p-3 rounded-lg text-sm font-bold border-2 transition-all ${
                    selectedTag === type.value
                      ? `border-${type.color}-500 bg-${type.color}-50 text-${type.color}-700`
                      : 'border-slate-200 bg-white text-slate-600 hover:border-slate-300'
                  }`}
                >
                  <div className="flex items-center gap-2">
                    <div className={`w-3 h-3 rounded-full bg-${type.color}-500`} />
                    <span>{t(type.labelKey)}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>

          {/* Stats */}
          <div className="grid grid-cols-3 gap-4 pt-4 border-t border-slate-200">
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.attempts')}
              </div>
              <div className="text-2xl font-black text-slate-700">{mistake.attemptCount || 1}</div>
            </div>
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.masteryLevel')}
              </div>
              <div className="text-2xl font-black text-amber-600">{mistake.improvementCount || 0}/3</div>
            </div>
            <div className="text-center">
              <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                {t('notebook.lastAttempted')}
              </div>
              <div className="text-sm font-bold text-slate-700">
                {new Date(mistake.lastAttempted).toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: 'short'
                })}
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </div>
  );
}



function InfoIconButton({ title, body, onOpenModal, hoverCapable }) {
  const [open, setOpen] = useState(false);

  const showTooltip = hoverCapable && open;

  return (
    <span
      className="relative inline-flex"
      onMouseEnter={() => hoverCapable && setOpen(true)}
      onMouseLeave={() => hoverCapable && setOpen(false)}
    >
      <button
        type="button"
        onClick={() => onOpenModal?.()}
        className="w-5 h-5 rounded-full border border-amber-300 bg-amber-50 text-amber-700 font-black text-[11px] leading-none flex items-center justify-center hover:bg-amber-100 transition-all"
        aria-label={title}
        title={hoverCapable ? title : undefined}
      >
        !
      </button>

      {showTooltip && (
        <div className="absolute left-0 top-full mt-2 w-64 max-w-[calc(100vw-2rem)] bg-white border border-slate-200 shadow-lg rounded-xl p-3 text-xs text-slate-700 z-[90] break-words">
          <div className="font-bold text-slate-800 mb-1 normal-case">{title}</div>
          <div className="text-slate-600 leading-relaxed normal-case">{body}</div>
        </div>
      )}
    </span>
  );
}

function FilterInfoModal({ onClose }) {
  const { t } = useLanguage();
  return (
    <div className="fixed inset-0 bg-black/60 z-[100] p-4 flex items-center justify-center">
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-white w-11/12 max-w-md max-h-[85vh] overflow-y-auto rounded-2xl shadow-xl border border-slate-200"
      >
        <div className="p-6">
          <div className="flex items-start justify-between gap-4">
            <div className="flex-1">
              <div className="text-lg font-bold text-slate-800 normal-case">
                {t('notebook.filterInfoTitle')}
              </div>
              <div className="text-sm text-slate-600 mt-2 leading-relaxed normal-case">
                {t('notebook.filterInfoBody')}
              </div>
            </div>
            <button
              type="button"
              onClick={onClose}
              className="px-3 py-2 rounded-lg bg-slate-100 text-slate-700 font-black hover:bg-slate-200 transition-all flex-shrink-0"
            >
              {t('notebook.close')}
            </button>
          </div>
        </div>
      </motion.div>
    </div>
  );
}

/**
 * ProgressSegments: 3-segment progress bar
 */
function ProgressSegments({ current, target = 3, size = 'sm' }) {
  const sizeClasses = {
    sm: 'h-2',
    md: 'h-3',
    lg: 'h-4',
  };
  
  return (
    <div className={`flex gap-1 ${sizeClasses[size]}`}>
      {Array.from({ length: target }).map((_, i) => (
        <div
          key={i}
          className={`flex-1 rounded-full transition-all duration-300 ${
            i < current
              ? 'bg-green-500 shadow-lg'
              : i === current
              ? 'bg-amber-400'
              : 'bg-slate-200'
          }`}
        />
      ))}
    </div>
  );
}

/**
 * TooltipWithPortal: Floating tooltip
 */
function TooltipWithPortal({ trigger, content, placement = 'top' }) {
  const [open, setOpen] = useState(false);
  
  const { refs, floatingStyles } = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    middleware: [offset(10), flip(), shift({ padding: 8 })],
    whileElementsMounted: autoUpdate
  });
  
  return (
    <>
      <div
        ref={refs.setReference}
        onMouseEnter={() => setOpen(true)}
        onMouseLeave={() => setOpen(false)}
        className="cursor-help"
      >
        {trigger}
      </div>
      
      {open && createPortal(
        <div
          ref={refs.setFloating}
          style={floatingStyles}
          className="z-[9999] bg-slate-900 text-white text-xs rounded-xl p-3 shadow-2xl ring-1 ring-white/10 max-w-xs pointer-events-none"
        >
          {content}
        </div>,
        document.body
      )}
    </>
  );
}

/**
 * InteractiveTopicHeatmap: Clickable topic density chart with multi-select
 */
function InteractiveTopicHeatmap({ mistakes, selectedTopics, onTopicToggle }) {
  const { t, tf } = useLanguage();
  
  const errorDensity = useMemo(() => {
    const topicMap = {};
    mistakes.forEach(m => {
      if (!topicMap[m.Topic]) {
        topicMap[m.Topic] = { attempted: 0, wrong: 0 };
      }
      topicMap[m.Topic].wrong++;
      topicMap[m.Topic].attempted += Math.max(m.attemptCount, 1);
    });
    
    return Object.entries(topicMap).map(([topic, data]) => ({
      topic,
      errorDensity: Math.min(1.0, data.wrong / Math.max(data.attempted, 1)),
      wrongCount: data.wrong,
      attemptedCount: data.attempted
    })).sort((a, b) => b.errorDensity - a.errorDensity);
  }, [mistakes]);
  
  const getColor = (density, isSelected) => {
    const base = density < 0.2 ? 'yellow' 
      : density < 0.4 ? 'orange' 
      : density < 0.6 ? 'orange' 
      : density < 0.8 ? 'red'
      : 'red';
    
    if (isSelected) {
      return `from-${base}-600 to-${base}-700 text-white ring-2 ring-${base}-400 ring-offset-2`;
    }
    
    if (density < 0.2) return 'from-yellow-100 to-yellow-200 text-yellow-900 hover:from-yellow-200 hover:to-yellow-300';
    if (density < 0.4) return 'from-orange-200 to-orange-300 text-orange-900 hover:from-orange-300 hover:to-orange-400';
    if (density < 0.6) return 'from-orange-400 to-orange-500 text-white hover:from-orange-500 hover:to-orange-600';
    if (density < 0.8) return 'from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700';
    return 'from-red-700 to-red-800 text-white hover:from-red-800 hover:to-red-900';
  };
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-2 flex items-center gap-2">
        <BarChart2 size={20} className="text-orange-600" />
        {t('notebook.errorDensityByTopic')}
      </h3>
      <p className="text-xs text-slate-500 mb-4">
        {t('notebook.clickTopicsToFilter')} • {selectedTopics.length > 0 && tf('notebook.selectedCount', { count: selectedTopics.length })}
      </p>
      
      <div className="space-y-3">
        {errorDensity.map(({ topic, errorDensity: density, wrongCount, attemptedCount }) => {
          const isSelected = selectedTopics.includes(topic);
          return (
            <button
              key={topic}
              onClick={() => onTopicToggle(topic)}
              className={`w-full flex items-center gap-4 p-4 rounded-lg bg-gradient-to-r transition-all transform hover:scale-105 active:scale-95 cursor-pointer ${getColor(density, isSelected)}`}
            >
              <div className="w-24 sm:w-32 font-semibold text-sm text-left truncate flex items-center gap-2">
                {isSelected && <Check size={14} />}
                {topic}
              </div>
              <div className="flex-1 text-right font-bold text-sm">
                {(density * 100).toFixed(0)}% ({wrongCount}/{attemptedCount})
              </div>
              <ChevronRight size={16} />
            </button>
          );
        })}
      </div>
      
      {selectedTopics.length > 0 && (
        <button
          onClick={() => selectedTopics.forEach(onTopicToggle)}
          className="mt-4 w-full py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-bold transition-all"
        >
          {t('notebook.clearSelection')}
        </button>
      )}
    </div>
  );
}
/**
 * CalendarHeatmap: 30-day activity visualization
 */
function CalendarHeatmap({ attempts }) {
  const { t, tf } = useLanguage();
  
  const activityMap = useMemo(() => {
    const map = {};
    const now = new Date();
    
    for (let i = 0; i < 30; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split('T')[0];
      map[dateStr] = 0;
    }
    
    (attempts || []).forEach(a => {
      if (!a?.wasCorrect) return;
      const dateStr = a.attemptedAt ? new Date(a.attemptedAt).toISOString().split('T')[0] : null;
      if (dateStr && map[dateStr] !== undefined) map[dateStr]++;
    });
    
    return map;
  }, [attempts]);
  
  const days = Object.entries(activityMap).reverse();
  const maxActivity = Math.max(...Object.values(activityMap), 1);
  
  const getColor = (count) => {
    const intensity = count / maxActivity;
    if (intensity === 0) return 'bg-slate-100';
    if (intensity < 0.33) return 'bg-blue-200';
    if (intensity < 0.67) return 'bg-blue-400';
    return 'bg-blue-600';
  };
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <Calendar size={20} className="text-blue-600" />
        {t('notebook.mistakeClearingActivity')}
      </h3>
      
      <div className="grid grid-cols-7 gap-1">
        {[
          t('notebook.weekdaySunShort'),
          t('notebook.weekdayMonShort'),
          t('notebook.weekdayTueShort'),
          t('notebook.weekdayWedShort'),
          t('notebook.weekdayThuShort'),
          t('notebook.weekdayFriShort'),
          t('notebook.weekdaySatShort'),
        ].map((day, idx) => (
          <div key={`header-${idx}`} className="text-center text-xs font-bold text-slate-400 h-6">
            {day}
          </div>
        ))}
        
        {days.map(([dateStr, count]) => (
          <TooltipWithPortal
            key={dateStr}
            trigger={
              <div
                className={`w-8 h-8 rounded ${getColor(count)} flex items-center justify-center text-xs font-bold text-slate-700 hover:ring-2 ring-blue-400 transition-all cursor-pointer`}
              >
                {count > 0 && count}
              </div>
            }
            content={tf('notebook.activityTooltipCleared', { date: dateStr, count })}
          />
        ))}
      </div>
      
      <div className="flex items-center gap-2 mt-4 text-xs text-slate-500">
        <span>{t('notebook.less')}</span>
        <div className="flex gap-1">
          {[0, 0.33, 0.67, 1.0].map((i, idx) => (
            <div key={idx} className={`w-3 h-3 rounded ${getColor(i * maxActivity)}`} />
          ))}
        </div>
        <span>{t('notebook.more')}</span>
      </div>
    </div>
  );
}

/**
 * ImprovementTrendChart: 14-day mastery progression
 */
function ImprovementTrendChart({ cards, attempts }) {
  const { t } = useLanguage();
  
  const trendData = useMemo(() => {
    const now = new Date();
    const days = [];
    for (let i = 13; i >= 0; i--) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      days.push(d.toISOString().split('T')[0]);
    }

    const snapshotByDay = Object.fromEntries(days.map(d => [d, { New: 0, Developing: 0, 'Near-Mastery': 0, Mastered: 0 }]));

    // Baseline: today counts from current cards
    const today = days[days.length - 1];
    (cards || []).forEach(c => {
      const bucket = getSrsBucket(c);
      if (bucket === 'archived') snapshotByDay[today].Mastered++;
      else if (bucket === 'new') snapshotByDay[today].New++;
      else if (bucket === 'progressing') snapshotByDay[today].Developing++;
      else snapshotByDay[today]['Near-Mastery']++;
    });

    // For each attempt day, count stateAfter.status transitions as a lightweight trend signal
    (attempts || []).forEach(a => {
      const dateStr = a.attemptedAt ? new Date(a.attemptedAt).toISOString().split('T')[0] : null;
      if (!dateStr || !snapshotByDay[dateStr]) return;
      const s = a.stateAfter?.status;
      if (s === 'graduated') snapshotByDay[dateStr].Mastered++;
      else if (s === 'new') snapshotByDay[dateStr].New++;
      else if (s === 'learning') snapshotByDay[dateStr].Developing++;
      else if (s === 'review') snapshotByDay[dateStr]['Near-Mastery']++;
    });

    return days.map(d => ({ date: d, ...snapshotByDay[d] }));
  }, [cards, attempts]);
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <TrendingUp size={20} className="text-purple-600" />
        {t('notebook.improvementTrend')}
      </h3>
      
      <ResponsiveContainer width="100%" height={300}>
        <AreaChart data={trendData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Area type="monotone" dataKey="New" name={t('notebook.masteryNew')} stackId="1" stroke="#ef4444" fill="#fecaca" />
          <Area type="monotone" dataKey="Developing" name={t('notebook.masteryDeveloping')} stackId="1" stroke="#f59e0b" fill="#fed7aa" />
          <Area type="monotone" dataKey="Near-Mastery" name={t('notebook.masteryNear')} stackId="1" stroke="#eab308" fill="#fef08a" />
          <Area type="monotone" dataKey="Mastered" name={t('notebook.masteryMastered')} stackId="1" stroke="#22c55e" fill="#bbf7d0" />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}

/**
 * RetentionDashboard: Learning metrics overview
 */
function RetentionDashboard({ cards = [], attempts = [] }) {
  const { t, tf } = useLanguage();
  const [open, setOpen] = useState(true);
  
  const stats = useMemo(() => {
    const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const addedThisWeek = (cards || []).filter((c) => {
      const ts = c.createdAt ? new Date(c.createdAt).getTime() : 0;
      return ts >= weekAgo;
    }).length;

    const masteredThisWeek = (attempts || []).filter((a) => {
      const ts = a.attemptedAt ? new Date(a.attemptedAt).getTime() : 0;
      return ts >= weekAgo && a?.stateAfter?.status === 'graduated';
    }).length;
    
    const subtopicMap = {};
    (cards || []).filter(c => c.isActive !== false).forEach((c) => {
      const key = c.subtopic || 'Unknown';
      if (!subtopicMap[key]) subtopicMap[key] = { count: 0, repeats: 0 };
      subtopicMap[key].count++;
      if ((c.failedAttempts || 0) > 0) subtopicMap[key].repeats++;
    });
    
    const weakest = Object.entries(subtopicMap)
      .sort((a, b) => b[1].count + b[1].repeats * 2 - (a[1].count + a[1].repeats * 2))
      .slice(0, 6);
    
    return { addedThisWeek, masteredThisWeek, weakest };
  }, [cards, attempts]);
  
  const decayLabel =
    stats.addedThisWeek === 0 && stats.masteredThisWeek === 0
      ? '—'
      : stats.masteredThisWeek > stats.addedThisWeek
      ? t('notebook.decayImproving')
      : stats.masteredThisWeek === stats.addedThisWeek
      ? t('notebook.decayStable')
      : t('notebook.decayGrowing');
  
  return (
    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden">
      <button
        onClick={() => setOpen((o) => !o)}
        className="w-full flex items-center justify-between p-5 hover:bg-slate-50 transition-all"
      >
        <div className="flex items-center gap-2">
          <Activity className="text-purple-600" size={20} />
          <span className="font-bold text-slate-800 text-lg">{t('notebook.retentionDashboard')}</span>
        </div>
        <ChevronDown
          size={20}
          className={`text-slate-400 transition-transform ${open ? 'rotate-180' : ''}`}
        />
      </button>
      
      <AnimatePresence>
        {open && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="border-t border-slate-200 overflow-hidden"
          >
            <div className="p-6 space-y-6 bg-slate-50">
              <div className="grid grid-cols-3 gap-4">
                <div className="bg-white rounded-xl p-4 border-2 border-slate-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.addedThisWeek')}
                  </div>
                  <div className="text-3xl font-black text-red-500">{stats.addedThisWeek}</div>
                </div>
                <div className="bg-white rounded-xl p-4 border-2 border-slate-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.masteredThisWeek')}
                  </div>
                  <div className="text-3xl font-black text-green-600">{stats.masteredThisWeek}</div>
                </div>
                <div className="bg-white rounded-xl p-4 border-2 border-purple-200 text-center">
                  <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-1">
                    {t('notebook.decayRate')}
                  </div>
                  <div className="text-lg font-black text-purple-700 mt-1">{decayLabel}</div>
                </div>
              </div>
              
              <div>
                <h3 className="text-sm font-black text-slate-600 uppercase tracking-widest mb-3 flex items-center gap-2">
                  <Flame size={14} className="text-red-500" />
                  {t('notebook.weakestSubtopics')}
                </h3>
                <div className="space-y-2">
                  {stats.weakest.map(([subtopic, data]) => {
                    const max = stats.weakest[0][1].count + stats.weakest[0][1].repeats * 2;
                    const score = data.count + data.repeats * 2;
                    const pct = max > 0 ? (score / max) * 100 : 0;
                    return (
                      <div key={subtopic} className="flex items-center gap-3">
                        <div className="w-32 text-xs text-slate-600 font-semibold truncate shrink-0">
                          {subtopic}
                        </div>
                        <div className="flex-1 bg-slate-200 rounded-full h-2">
                          <div
                            className="bg-gradient-to-r from-red-400 to-orange-400 h-2 rounded-full transition-all"
                            style={{ width: `${pct}%` }}
                          />
                        </div>
                        <div className="text-xs text-slate-500 shrink-0 w-8 text-right">
                          {data.count}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

/**
 * LIST VIEW: Compact expandable rows
 */
function ListViewDeck({ mistakes, errorTags, onTag, selectedIds, onToggleSelect, onToggleSelectAll, allSelected, onViewFull, moreHint, totalCount }) {
  const { t } = useLanguage();
  const [expandedId, setExpandedId] = useState(null);
  const selectedVisibleCount = (mistakes || []).reduce(
    (acc, m) => (selectedIds.has(m.ID) ? acc + 1 : acc),
    0
  );

  const denom = Number.isFinite(Number(totalCount)) && Number(totalCount) > 0
    ? Number(totalCount)
    : (mistakes?.length || 0);
  
  return (
    <div className="space-y-2">
      {/* Select All */}
      <div className="flex items-center gap-2 p-3 bg-slate-50 rounded-lg border border-slate-200">
        <input
          type="checkbox"
          checked={allSelected}
          onChange={onToggleSelectAll}
          className="w-4 h-4 rounded cursor-pointer"
        />
        <span className="text-sm font-bold text-slate-700">
          {t('notebook.selectAll')} ({selectedVisibleCount}/{denom})
          {moreHint ? <span className="text-slate-500 font-semibold"> {moreHint}</span> : null}
        </span>
      </div>
      
      {/* Mistake Rows */}
      <AnimatePresence>
        {mistakes.map((mistake) => {
          const style = masteryStyle(mistake.improvementCount ?? 0);
          const priority = calcPriority(mistake);
          const isExpanded = expandedId === mistake.ID;
          const isSelected = selectedIds.has(mistake.ID);
          const isUrgent = priority > 15;
          const reactKey = mistake?.docId ?? mistake?.ID;
          
          return (
            <motion.div
              key={reactKey}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className={`rounded-lg border-2 transition-all ${style.border} ${style.bg} ${
                isUrgent ? 'ring-2 ring-red-400' : ''
              }`}
            >
              {/* Row Header */}
              <div className="flex items-center gap-3 p-4">
                <input
                  type="checkbox"
                  checked={isSelected}
                  onChange={() => onToggleSelect(mistake.ID)}
                  className="w-4 h-4 rounded cursor-pointer"
                />
                <button
                  onClick={() => setExpandedId(isExpanded ? null : mistake.ID)}
                  className="flex-1 flex items-center justify-between hover:bg-white/50 p-2 rounded-lg transition-all"
                >
                  <div className="flex items-center gap-3 flex-1">
                    <div className="w-10 h-10 rounded bg-slate-200 flex items-center justify-center text-xs font-bold text-slate-600">
                      {mistake.Topic.slice(0, 2)}
                    </div>
                    <div className="text-left min-w-0 flex-1">
                      <div className="text-xs font-bold text-slate-600">
                        {mistake.Topic} → {mistake.Subtopic}
                      </div>
                      <div className="text-sm text-slate-800 font-semibold truncate">
                        {mistake.Question?.replace(/<[^>]*>/g, '').substring(0, 60)}...
                      </div>
                    </div>
                  </div>
                  <div className="flex items-center gap-2 shrink-0">
                    <div className="w-24">
                      <ProgressSegments current={mistake.improvementCount ?? 0} target={3} size="sm" />
                    </div>
                    <span className={`text-xs font-black px-2 py-1 rounded-full ${
                      isUrgent ? 'bg-red-100 text-red-700' : 'bg-slate-100 text-slate-600'
                    }`}>
                      {priority.toFixed(1)}
                    </span>
                    <ChevronRight size={16} className={`transition-transform ${isExpanded ? 'rotate-90' : ''}`} />
                  </div>
                </button>
                <button
                  onClick={() => onViewFull(mistake)}
                  className="p-2 bg-indigo-100 text-indigo-700 rounded-lg hover:bg-indigo-200 transition-all"
                  title={t('notebook.viewFullQuestion')}
                >
                  <Maximize2 size={18} />
                </button>
              </div>
              
              {/* Expanded Content */}
              <AnimatePresence>
                {isExpanded && (
                  <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="overflow-hidden"
                  >
                    <div className="p-4 border-t border-slate-300 space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        <div className="p-3 rounded-lg bg-red-50 border border-red-200">
                          <div className="text-xs font-bold text-red-700 mb-1">{t('notebook.yourAnswer')}</div>
                          <div className="text-sm font-semibold text-red-900">{mistake.userAnswer}</div>
                        </div>
                        <div className="p-3 rounded-lg bg-green-50 border border-green-200">
                          <div className="text-xs font-bold text-green-700 mb-1">{t('notebook.correctAnswer')}</div>
                          <div className="text-sm font-semibold text-green-900">{mistake.CorrectOption}</div>
                        </div>
                      </div>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </motion.div>
          );
        })}
      </AnimatePresence>
    </div>
  );
}

/**
 * KANBAN VIEW: 3-column layout (New, Developing, Near-Mastery)
 */
function KanbanViewDeck({ columns, errorTags, onTag, onViewFull }) {
  const { t } = useLanguage();
  const [expandedId, setExpandedId] = useState(null);
  
  const columnConfig = {
    new: { label: t('notebook.masteryNew'), color: 'red', icon: AlertTriangle, gradient: 'from-red-50 to-red-100', border: 'border-red-300' },
    progressing: { label: t('notebook.masteryDeveloping'), color: 'amber', icon: Flame, gradient: 'from-amber-50 to-amber-100', border: 'border-amber-300' },
    near: { label: t('notebook.masteryNear'), color: 'green', icon: Star, gradient: 'from-green-50 to-green-100', border: 'border-green-300' },
  };
  
  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 h-full">
      {Object.entries(columns).map(([key, mistakes]) => {
        const config = columnConfig[key];
        
        return (
          <motion.div
            key={key}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.3 }}
            className={`rounded-2xl border-2 ${config.border} bg-gradient-to-b ${config.gradient} p-4 flex flex-col`}
          >
            {/* Column Header */}
            <div className="mb-4 pb-3 border-b-2 border-slate-300">
              <h3 className="font-black text-lg text-slate-800 flex items-center gap-2">
                <config.icon size={20} className={`text-${config.color}-600`} />
                {config.label} ({mistakes.length})
              </h3>
            </div>
            
            {/* Column Cards */}
            <div className="flex-1 overflow-y-auto space-y-3 pr-2">
              {mistakes.length === 0 ? (
                <div className="text-center py-8">
                  <CheckCircle size={32} className={`text-${config.color}-300 mx-auto mb-2`} />
                  <p className={`text-xs font-bold text-${config.color}-700`}>
                    {t('notebook.allCaughtUp')}
                  </p>
                </div>
              ) : (
                <AnimatePresence>
                  {mistakes.map((mistake) => {
                    const priority = calcPriority(mistake);
                    const isUrgent = priority > 15;
                    const reactKey = mistake?.docId ?? mistake?.ID;
                    
                    return (
                      <motion.div
                        key={reactKey}
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.9 }}
                        className={`bg-white rounded-xl p-4 shadow-md border-2 border-slate-200 hover:shadow-lg transition-all ${
                          isUrgent ? 'ring-2 ring-red-400' : ''
                        }`}
                      >
                        {/* Card Header */}
                        <div className="mb-3">
                          <div className="text-xs font-bold text-slate-500 uppercase tracking-widest mb-1">
                            {mistake.Topic}
                          </div>
                          <div className="text-sm font-bold text-slate-800 line-clamp-2">
                            {mistake.Question?.replace(/<[^>]*>/g, '').substring(0, 80)}...
                          </div>
                        </div>
                        
                        {/* Progress Bar */}
                        <div className="mb-3">
                          <ProgressSegments current={mistake.improvementCount ?? 0} target={3} size="md" />
                        </div>
                        
                        {/* Priority Badge */}
                        <div className={`inline-block text-xs font-black px-2 py-1 rounded-full mb-3 ${
                          isUrgent
                            ? 'bg-red-100 text-red-700'
                            : priority > 7
                            ? 'bg-amber-100 text-amber-700'
                            : 'bg-slate-100 text-slate-600'
                        }`}>
                          {t('notebook.priority')}: {priority.toFixed(1)}
                        </div>
                        
                        {/* View Full Button */}
                        <button
                          onClick={() => onViewFull(mistake)}
                          className="w-full py-2 bg-indigo-600 text-white rounded-lg font-bold text-sm hover:bg-indigo-700 transition-all flex items-center justify-center gap-2"
                        >
                          <Maximize2 size={14} />
                          {t('notebook.viewFull')}
                        </button>
                      </motion.div>
                    );
                  })}
                </AnimatePresence>
              )}
            </div>
          </motion.div>
        );
      })}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN COMPONENT
// ═══════════════════════════════════════════════════════════════════════════════
export default function MistakeNotebookPage({ questions = [] }) {
  const { currentUser } = useAuth();
  const { t, tf } = useLanguage();
  const navigate = useNavigate();
  
  // Core state
  const [mistakes, setMistakes] = useState([]);
  const [totalMistakesCount, setTotalMistakesCount] = useState(null);
  const [masteryCounts, setMasteryCounts] = useState({});
  const [srsBackfillTick, setSrsBackfillTick] = useState(0);
  const [facetMistakeRows, setFacetMistakeRows] = useState([]);
  const [topicStatsDoc, setTopicStatsDoc] = useState(null);
  const [topicCountOverrides, setTopicCountOverrides] = useState({});
  const [multiTopicOverrideCount, setMultiTopicOverrideCount] = useState(null);
  const [rebuildingTopicStats, setRebuildingTopicStats] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [srsCards, setSrsCards] = useState([]);
  const [reviewAttempts, setReviewAttempts] = useState([]);
  const [mistakeIndexRows, setMistakeIndexRows] = useState([]);
  const [mistakeIndexHasMore, setMistakeIndexHasMore] = useState(false);
  const [mistakeIndexCursor, setMistakeIndexCursor] = useState(null);
  const [loadingMoreMistakes, setLoadingMoreMistakes] = useState(false);
  const [errorTags, setErrorTags] = useState(() =>
    JSON.parse(localStorage.getItem('mistake_error_tags') || '{}')
  );
  const [recentQuizTopics, setRecentQuizTopics] = useState(() =>
    JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]')
  );
  const [archivedMistakes, setArchivedMistakes] = useState({});
  
  // Filter state
  const [questionCount, setQuestionCount] = useState('10');
  const [datePeriod, setDatePeriod] = useState('all');
  const [selectedTopics, setSelectedTopics] = useState([]);
  const [selectedSubtopics, setSelectedSubtopics] = useState([]);
  const [selectedMasteryLevels, setSelectedMasteryLevels] = useState([]);
  const [srsPresence, setSrsPresence] = useState('all');
  
  // Timer settings
  const [timerEnabled, setTimerEnabled] = useState(true);
  const [isTimedMode, setIsTimedMode] = useState(false);
  
  // UI state
  const [activeTab, setActiveTab] = useState('analytics');
  const [archiveSubTab, setArchiveSubTab] = useState('mastery');
  const [hoverCapable, setHoverCapable] = useState(true);
  const [viewMode, setViewMode] = useState('list');
  const [selectedMistakeIds, setSelectedMistakeIds] = useState(new Set());
  const [fullViewMistake, setFullViewMistake] = useState(null);
  const [showInfoModal, setShowInfoModal] = useState(false);
  const [showHelpPanel, setShowHelpPanel] = useState(false);
  const [filterInfoOpen, setFilterInfoOpen] = useState(false);
  const [archivedLoaded, setArchivedLoaded] = useState(false);

  // ─── SRS data cache ───────────────────────────────────────────────────────
  // getDueCards + getRecentReviewAttempts are expensive cross-collection reads.
  // They are independent of topic/subtopic/mastery/srsPresence filters, so we
  // cache them per-uid and only re-fetch when the user changes or the cache is
  // older than SRS_CACHE_TTL_MS (5 min). Filter-only changes reuse the cache.
  const SRS_CACHE_TTL_MS = 5 * 60 * 1000;
  const srsDataCachedForUidRef = useRef(null); // uid the current cache belongs to
  const cachedDueCardsRef       = useRef([]);
  const cachedReviewAttemptsRef = useRef([]);
  const srsLastFetchedAtRef     = useRef(0);   // Date.now() at last SRS fetch

  const refreshTopicStatsDoc = useCallback(async () => {
    if (!currentUser?.uid) return;
    try {
      const ref = doc(db, 'users', currentUser.uid, 'mistake_stats', 'topicBuckets');
      const snap = await getDoc(ref);
      setTopicStatsDoc(snap.exists() ? (snap.data() || {}) : null);
    } catch (e) {
      console.error('Error loading topic stats doc:', e);
      setTopicStatsDoc(null);
    }
  }, [currentUser?.uid]);

  const handleRebuildTopicStats = useCallback(async () => {
    if (!currentUser?.uid) return;
    if (rebuildingTopicStats) return;
    try {
      setRebuildingTopicStats(true);
      const { getFunctions, httpsCallable } = await import('firebase/functions');
      const functions = getFunctions(app, 'asia-east1');
      const callable = httpsCallable(functions, 'rebuildMistakeTopicStats');
      await callable({});
      await refreshTopicStatsDoc();
    } catch (e) {
      console.error('rebuildMistakeTopicStats failed:', e);
    } finally {
      setRebuildingTopicStats(false);
    }
  }, [currentUser?.uid, rebuildingTopicStats, refreshTopicStatsDoc]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setTopicStatsDoc(null);
      return;
    }
    refreshTopicStatsDoc();
  }, [currentUser?.uid]);

  useEffect(() => {
    if (!currentUser?.uid) return;
    if (datePeriod !== 'all') return;
    if (selectedTopics.length !== 1) return;
    if (selectedSubtopics.length > 0) return;
    if (selectedMasteryLevels.length > 0) return;
    if (srsPresence !== 'all') return;

    const topic = selectedTopics[0];
    const run = async () => {
      try {
        const snap = await getCountFromServer(
          query(
            collection(db, 'users', currentUser.uid, 'mistakes'),
            where('Topic', '==', topic)
          )
        );
        const count = Number(snap.data().count || 0);
        setTopicCountOverrides((prev) => ({
          ...prev,
          [String(topic)]: Number.isFinite(count) ? count : 0,
        }));
      } catch (e) {
        console.error('Error counting mistakes for topic override:', e);
      }
    };

    run();
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, srsBackfillTick]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (datePeriod !== 'all') {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (selectedSubtopics.length > 0) {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (selectedMasteryLevels.length > 0) {
      setMultiTopicOverrideCount(null);
      return;
    }
    if (srsPresence !== 'all') {
      setMultiTopicOverrideCount(null);
      return;
    }

    const topics = (Array.isArray(selectedTopics) ? selectedTopics : []).filter(Boolean);
    if (topics.length < 2 || topics.length > 10) {
      setMultiTopicOverrideCount(null);
      return;
    }

    const run = async () => {
      try {
        const snap = await getCountFromServer(
          query(
            collection(db, 'users', currentUser.uid, 'mistakes'),
            where('Topic', 'in', topics)
          )
        );
        const count = Number(snap.data().count || 0);
        setMultiTopicOverrideCount(Number.isFinite(count) ? count : null);
      } catch (e) {
        console.error('Error counting mistakes for multi-topic override:', e);
        setMultiTopicOverrideCount(null);
      }
    };

    run();
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, srsBackfillTick]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setTotalMistakesCount(null);
      return;
    }

    const run = async () => {
      try {
        const now = getNow();
        const weekAgo = new Date(now);
        weekAgo.setDate(weekAgo.getDate() - 7);
        const monthAgo = new Date(now);
        monthAgo.setMonth(monthAgo.getMonth() - 1);

        const base = [collection(db, 'users', currentUser.uid, 'mistakes')];
        if (datePeriod === 'week') {
          base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
        } else if (datePeriod === 'month') {
          base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
        }

        const snap = await getCountFromServer(query(...base));
        setTotalMistakesCount(Number(snap.data().count || 0));
      } catch (e) {
        console.error('Error counting total mistakes:', e);
        setTotalMistakesCount(null);
      }
    };

    run();
  }, [currentUser, datePeriod]);

  useEffect(() => {
    if (!currentUser?.uid) {
      setMasteryCounts({});
      return;
    }

    const run = async () => {
      try {
        const built = buildMistakeCountBaseConstraints({
          userId: currentUser.uid,
          datePeriod,
          selectedTopics,
          selectedSubtopics,
          srsPresence,
        });

        if (
          (built.needsClientTopicFilter && built.topics.length > 0) ||
          (built.needsClientSubtopicFilter && built.subs.length > 0) ||
          (srsPresence !== 'all') ||
          (built.topics.length > 0)
        ) {
          setMasteryCounts({});
          return;
        }

        const entries = await Promise.all(
          Object.keys(MASTERY_LEVELS).map(async (bucket) => {
            const parts = [...built.base, where('srsBucket', '==', bucket)];
            if (srsPresence === 'in_srs') {
              parts.push(where('srsIsActive', '==', true));
            }
            const snap = await getCountFromServer(query(...parts));
            return [bucket, Number(snap.data().count || 0)];
          })
        );

        const nextCounts = Object.fromEntries(entries);

        const sum = Object.values(nextCounts).reduce((a, b) => a + Number(b || 0), 0);
        // If user clearly has mistakes but none of the docs have srsBucket yet,
        // counts will be 0 across the board. In that case, keep fallback UI counts.
        if (sum === 0 && Number(totalMistakesCount || 0) > 0) {
          setMasteryCounts({});
        } else {
          setMasteryCounts(nextCounts);
        }
      } catch (e) {
        console.error('Error counting mastery buckets:', e);
        setMasteryCounts({});
      }
    };

    run();
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, srsBackfillTick, totalMistakesCount]);

  useEffect(() => {
    if (!currentUser) return;
    loadFacetMistakes();
  }, [currentUser, datePeriod]);

  // Single consolidated load effect — replaces 3 separate effects that each called
  // loadMistakes independently (causing 2–3 redundant full Firestore fetches on every
  // mount and filter change). Pagination state is reset here so loadMistakes always
  // starts from the first page. SRS data re-use is controlled inside loadMistakes.
  useEffect(() => {
    setMistakeIndexRows([]);
    setMistakeIndexHasMore(false);
    setMistakeIndexCursor(null);
    if (currentUser) loadMistakes();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentUser, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence]);

  // Lazy-load archived cards only when Archive tab is opened
  useEffect(() => {
    if (!currentUser) return;
    if (activeTab !== 'archive') return;
    if (archivedLoaded) return;

    const loadArchived = async () => {
      try {
        const questionMap = new Map((questions || []).map(q => [q.ID, q]));
        const archivedCards = await srsService.getArchivedCards(currentUser.uid);
        const archivedByQuestionId = {};

        (archivedCards || []).forEach((c) => {
          const questionData = questionMap.get(c.questionId) || {};
          archivedByQuestionId[c.questionId] = {
            ...c,
            ...questionData,
            ID: c.questionId,
            archivedAt: c.archivedAt,
            archiveReason: c.archiveReason || 'unknown'
          };
        });

        setArchivedMistakes(archivedByQuestionId);
        setArchivedLoaded(true);
      } catch (e) {
        console.error('Error loading archived cards:', e);
      }
    };

    loadArchived();
  }, [activeTab, archivedLoaded, currentUser, questions]);

  useEffect(() => {
    if (activeTab !== 'archive') return;
    setArchiveSubTab('mastery');
  }, [activeTab]);
  
  // Auto-archive overdue cards older than 14 days
  useEffect(() => {
    if (!currentUser) return;

    const runArchive = async () => {
      try {
        const archivedCount = await srsService.archiveOverdueCards(currentUser.uid);
        if (archivedCount > 0) {
          console.log(`🗄️ Auto-archived ${archivedCount} overdue cards`);
          // Reload data to refresh the archive
          loadMistakes();
        }
      } catch (error) {
        console.error('Error auto-archiving overdue cards:', error);
      }
    };

    runArchive();
  }, [currentUser]);
  
  async function loadMistakes() {
    if (!currentUser) { setLoading(false); return; }
    try {
      setLoading(true);
      setError(null);

      backfillMistakeSrsFromActiveCards(currentUser.uid)
        .then((didWrite) => {
          if (didWrite) setSrsBackfillTick((x) => x + 1);
        })
        .catch((e) => console.error('Active-card backfill failed:', e));

      // Re-fetch SRS data only when the user changes or the cache is stale (>5 min).
      // Topic / subtopic / mastery / srsPresence filter changes do NOT affect which SRS
      // cards exist, so those filter-triggered calls reuse the cached values and avoid
      // the expensive getDueCards + getRecentReviewAttempts round-trips.
      const srsNeedsFetch =
        srsDataCachedForUidRef.current !== currentUser.uid ||
        (Date.now() - srsLastFetchedAtRef.current) > SRS_CACHE_TTL_MS;

      let srsAttempts, dueCards;
      if (srsNeedsFetch) {
        [srsAttempts, dueCards] = await Promise.all([
          srsService.getRecentReviewAttempts(currentUser.uid, 30),
          srsService.getDueCards(currentUser.uid, getNow(), { limit: 200 })
        ]);
        cachedReviewAttemptsRef.current = srsAttempts;
        cachedDueCardsRef.current       = dueCards;
        srsDataCachedForUidRef.current  = currentUser.uid;
        srsLastFetchedAtRef.current     = Date.now();
      } else {
        srsAttempts = cachedReviewAttemptsRef.current;
        dueCards    = cachedDueCardsRef.current;
      }

      const now = getNow();
      const weekAgo = new Date(now);
      weekAgo.setDate(weekAgo.getDate() - 7);
      const monthAgo = new Date(now);
      monthAgo.setMonth(monthAgo.getMonth() - 1);

      const pageSize = 40;
      const firstBuilt = buildMistakeIndexQueryConstraints({
        userId: currentUser.uid,
        datePeriod,
        selectedTopics,
        selectedSubtopics,
        selectedMasteryLevels,
        srsPresence,
        cursor: null,
        pageSize,
      });

      let rows = [];
      let cursor = null;
      let hasMore = false;

      const needsClientFiltering =
        (firstBuilt.needsClientTopicFilter && firstBuilt.topics.length > 0) ||
        (firstBuilt.needsClientSubtopicFilter && firstBuilt.subs.length > 0) ||
        (firstBuilt.needsClientMasteryFilter && firstBuilt.masteryLevels.length > 0) ||
        firstBuilt.needsClientSrsPresenceFilter;

      if (!needsClientFiltering) {
        const snap = await getDocs(firstBuilt.q);
        rows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));
        cursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : null;
        hasMore = snap.docs.length === pageSize;
      } else {
        // If we must filter client-side, a single Firestore page can miss matches.
        // Over-fetch a bounded number of pages until we have enough matching rows.
        const maxPages = 6;
        let pagesFetched = 0;
        let fetchCursor = null;
        let lastSnapSize = 0;
        const topics = firstBuilt.topics;
        const subs = firstBuilt.subs;
        const masteryLevels = firstBuilt.masteryLevels;

        while (pagesFetched < maxPages && rows.length < pageSize) {
          const built = buildMistakeIndexQueryConstraints({
            userId: currentUser.uid,
            datePeriod,
            selectedTopics,
            selectedSubtopics,
            selectedMasteryLevels,
            srsPresence,
            cursor: fetchCursor,
            pageSize,
          });

          const snap = await getDocs(built.q);
          lastSnapSize = snap.docs.length;
          let pageRows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));

          if (built.needsClientTopicFilter && topics.length > 0) {
            pageRows = pageRows.filter((r) => topics.includes(r?.Topic ?? r?.topic));
          }
          if (built.needsClientSubtopicFilter && subs.length > 0) {
            pageRows = pageRows.filter((r) => subs.includes(r?.Subtopic ?? r?.subtopic));
          }
          if (built.needsClientMasteryFilter && masteryLevels.length > 0) {
            pageRows = pageRows.filter((r) => masteryLevels.includes(r.srsBucket || 'not_in_srs'));
          }
          if (built.needsClientSrsPresenceFilter) {
            pageRows = pageRows.filter((r) => matchesSrsPresence(r, srsPresence));
          }

          rows.push(...pageRows);

          fetchCursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : fetchCursor;
          pagesFetched += 1;

          if (lastSnapSize < pageSize) {
            break;
          }
        }

        cursor = fetchCursor;
        hasMore = lastSnapSize === pageSize;
        rows = rows.slice(0, pageSize);
      }

      if (await backfillMistakeSrsDefaults(currentUser.uid, rows)) {
        setSrsBackfillTick((x) => x + 1);
      }

      setMistakeIndexRows(rows);
      setMistakeIndexCursor(cursor);
      setMistakeIndexHasMore(hasMore);

      setReviewAttempts(srsAttempts);

      const questionMap = new Map((questions || []).map(q => [q.ID, q]));
      const dueByQuestionId = new Map((dueCards || []).map((c) => [String(c.questionId), c]));

      const deckAll = (rows || [])
        .map((row) => {
          const qid = row?.questionId ?? row?.ID ?? row?.docId ?? row?.id;
          const questionId = qid ? String(qid) : null;
          if (!questionId) return null;

          const q = questionMap.get(Number.isFinite(Number(questionId)) ? Number(questionId) : questionId) || questionMap.get(questionId);
          const dueCard = dueByQuestionId.get(questionId);

          return {
            ...(q || {}),
            ...row,
            ID: q?.ID ?? row?.ID ?? questionId,
            questionId,
            Topic: q?.Topic ?? row?.Topic ?? null,
            Subtopic: q?.Subtopic ?? row?.Subtopic ?? null,
            attemptCount: Number(row?.attemptCount || 0),
            lastAttempted: row?.lastAttempted || row?.lastWrongAt || row?.updatedAt || null,
            userAnswer: row?.lastUserAnswer ?? null,
            ...(dueCard || {}),
            // From mistake index denormalization
            hasSrsCard: row?.hasSrsCard === true,
            srsIsActive: row?.srsIsActive === true,
            srsStatus: row?.srsStatus ?? null,
            srsBucket: row?.srsBucket ?? (row?.hasSrsCard ? 'progressing' : 'not_in_srs'),
            srsCardId: row?.srsCardId ?? null,

            // Compatibility with existing UI/quiz mode checks
            id: row?.srsCardId ?? null,
            repetitionCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            improvementCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            status: dueCard?.status ?? row?.srsStatus ?? null,
            isActive: row?.srsIsActive ?? dueCard?.isActive ?? row?.isActive ?? true,
          };
        })
        .filter(Boolean)
        .filter((m) => {
          if (selectedTopics.length > 0 && !selectedTopics.includes(m.Topic)) return false;
          if (selectedSubtopics.length > 0 && !selectedSubtopics.includes(m.Subtopic)) return false;
          if (srsPresence !== 'all' && !matchesSrsPresence(m, srsPresence)) return false;
          if (selectedMasteryLevels.length > 0) {
            const bucket = getSrsBucket(m);
            if (!selectedMasteryLevels.includes(bucket)) return false;
          }
          return true;
        })
        .sort((a, b) => {
          const aDue = !!(a?.nextReviewDate && a?.nextReviewDate <= formatHKDateKey(getNow()) && a?.isActive !== false);
          const bDue = !!(b?.nextReviewDate && b?.nextReviewDate <= formatHKDateKey(getNow()) && b?.isActive !== false);
          if (aDue !== bDue) return aDue ? -1 : 1;
          return calcPriority(b) - calcPriority(a);
        });

      setMistakes(deckAll);
      setSrsCards(dueCards || []);

      // Reset archived cache; will lazy-load when opening Archive tab
      setArchivedMistakes({});
      setArchivedLoaded(false);
      
    } catch (err) {
      console.error(err);
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  async function loadFacetMistakes() {
    if (!currentUser?.uid) return;
    try {
      const now = getNow();
      const weekAgo = new Date(now);
      weekAgo.setDate(weekAgo.getDate() - 7);
      const monthAgo = new Date(now);
      monthAgo.setMonth(monthAgo.getMonth() - 1);

      const base = [collection(db, 'users', currentUser.uid, 'mistakes')];
      if (datePeriod === 'week') {
        base.push(where('lastWrongAt', '>=', weekAgo.toISOString()));
      } else if (datePeriod === 'month') {
        base.push(where('lastWrongAt', '>=', monthAgo.toISOString()));
      }
      base.push(orderBy('lastWrongAt', 'desc'));
      base.push(limit(200));

      const snap = await getDocs(query(...base));
      setFacetMistakeRows(snap.docs.map((d) => ({ docId: d.id, ...d.data() })));
    } catch (e) {
      console.error('Error loading facet mistakes:', e);
    }
  }

  async function loadMoreMistakes() {
    if (!currentUser?.uid) return;
    if (loadingMoreMistakes) return;
    if (!mistakeIndexHasMore) return;
    if (!mistakeIndexCursor) return;

    setLoadingMoreMistakes(true);
    try {
      const pageSize = 40;
      const firstBuilt = buildMistakeIndexQueryConstraints({
        userId: currentUser.uid,
        datePeriod,
        selectedTopics,
        selectedSubtopics,
        selectedMasteryLevels,
        srsPresence,
        cursor: mistakeIndexCursor,
        pageSize,
      });

      let fetchedRows = [];
      let nextCursor = mistakeIndexCursor;
      let hasMore = false;

      // FIX: include srsPresence in needsClientFiltering check (was missing)
      const needsClientFiltering =
        (firstBuilt.needsClientTopicFilter && firstBuilt.topics.length > 0) ||
        (firstBuilt.needsClientSubtopicFilter && firstBuilt.subs.length > 0) ||
        (firstBuilt.needsClientMasteryFilter && firstBuilt.masteryLevels.length > 0) ||
        firstBuilt.needsClientSrsPresenceFilter;

      if (!needsClientFiltering) {
        const snap = await getDocs(firstBuilt.q);
        fetchedRows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));
        nextCursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : mistakeIndexCursor;
        hasMore = snap.docs.length === pageSize;
      } else {
        const maxPages = 6;
        let pagesFetched = 0;
        let fetchCursor = mistakeIndexCursor;
        let lastSnapSize = 0;
        const topics = firstBuilt.topics;
        const subs = firstBuilt.subs;
        const masteryLevels = firstBuilt.masteryLevels;

        while (pagesFetched < maxPages && fetchedRows.length < pageSize) {
          const built = buildMistakeIndexQueryConstraints({
            userId: currentUser.uid,
            datePeriod,
            selectedTopics,
            selectedSubtopics,
            selectedMasteryLevels,
            srsPresence,
            cursor: fetchCursor,
            pageSize,
          });

          const snap = await getDocs(built.q);
          lastSnapSize = snap.docs.length;
          let pageRows = snap.docs.map((d) => ({ docId: d.id, ...d.data() }));

          if (built.needsClientTopicFilter && topics.length > 0) {
            pageRows = pageRows.filter((r) => topics.includes(r?.Topic ?? r?.topic));
          }
          if (built.needsClientSubtopicFilter && subs.length > 0) {
            pageRows = pageRows.filter((r) => subs.includes(r?.Subtopic ?? r?.subtopic));
          }
          if (built.needsClientMasteryFilter && masteryLevels.length > 0) {
            pageRows = pageRows.filter((r) => masteryLevels.includes(r.srsBucket || 'not_in_srs'));
          }
          // FIX: apply srsPresence filter inside the overfetch loop (was missing)
          if (built.needsClientSrsPresenceFilter) {
            pageRows = pageRows.filter((r) => matchesSrsPresence(r, srsPresence));
          }

          fetchedRows.push(...pageRows);

          fetchCursor = snap.docs.length > 0 ? snap.docs[snap.docs.length - 1] : fetchCursor;
          pagesFetched += 1;

          if (lastSnapSize < pageSize) {
            break;
          }
        }

        fetchedRows = fetchedRows.slice(0, pageSize);
        nextCursor = fetchCursor;
        hasMore = lastSnapSize === pageSize;
      }

      if (await backfillMistakeSrsDefaults(currentUser.uid, fetchedRows)) {
        setSrsBackfillTick((x) => x + 1);
      }

      const mergedRows = [...mistakeIndexRows, ...fetchedRows];
      setMistakeIndexRows(mergedRows);
      setMistakeIndexCursor(nextCursor);
      setMistakeIndexHasMore(hasMore);

      const questionMap = new Map((questions || []).map(q => [q.ID, q]));
      const dueByQuestionId = new Map((srsCards || []).map((c) => [String(c.questionId), c]));

      const deckDeduped = (() => {
        const byId = new Map();
        const order = [];

        (mergedRows || []).forEach((row) => {
          const qid = row?.questionId ?? row?.ID ?? row?.docId ?? row?.id;
          const questionId = qid ? String(qid) : null;
          if (!questionId) return;

          const q =
            questionMap.get(Number.isFinite(Number(questionId)) ? Number(questionId) : questionId) ||
            questionMap.get(questionId);
          const dueCard = dueByQuestionId.get(questionId);

          const m = {
            ...(q || {}),
            ...row,
            ID: q?.ID ?? row?.ID ?? questionId,
            questionId,
            Topic: q?.Topic ?? row?.Topic ?? null,
            Subtopic: q?.Subtopic ?? row?.Subtopic ?? null,
            attemptCount: Number(row?.attemptCount || 0),
            lastAttempted: row?.lastAttempted || row?.lastWrongAt || row?.updatedAt || null,
            userAnswer: row?.lastUserAnswer ?? null,
            ...(dueCard || {}),
            hasSrsCard: row?.hasSrsCard === true,
            srsIsActive: row?.srsIsActive === true,
            srsStatus: row?.srsStatus ?? null,
            srsBucket: row?.srsBucket ?? (row?.hasSrsCard ? 'progressing' : 'not_in_srs'),
            srsCardId: row?.srsCardId ?? null,
            id: row?.srsCardId ?? null,
            repetitionCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            improvementCount: (dueCard?.repetitionCount ?? row?.repetitionCount ?? 0),
            status: dueCard?.status ?? row?.srsStatus ?? null,
            isActive: row?.srsIsActive ?? dueCard?.isActive ?? row?.isActive ?? true,
          };

          if (!byId.has(questionId)) order.push(questionId);
          byId.set(questionId, m);
        });

        return order.map((k) => byId.get(k)).filter(Boolean);
      })();

      const deckFiltered = deckDeduped
        .filter((m) => {
          if (selectedTopics.length > 0 && !selectedTopics.includes(m.Topic)) return false;
          if (selectedSubtopics.length > 0 && !selectedSubtopics.includes(m.Subtopic)) return false;
          if (srsPresence !== 'all' && !matchesSrsPresence(m, srsPresence)) return false;
          if (selectedMasteryLevels.length > 0) {
            const bucket = getSrsBucket(m);
            if (!selectedMasteryLevels.includes(bucket)) return false;
          }
          return true;
        })
        .sort((a, b) => {
          const aDue = !!(a?.nextReviewDate && a?.nextReviewDate <= formatHKDateKey(getNow()) && a?.isActive !== false);
          const bDue = !!(b?.nextReviewDate && b?.nextReviewDate <= formatHKDateKey(getNow()) && b?.isActive !== false);
          if (aDue !== bDue) return aDue ? -1 : 1;
          return calcPriority(b) - calcPriority(a);
        });

      setMistakes(deckFiltered);
    } catch (e) {
      console.error('Error loading more mistakes:', e);
    }

    setLoadingMoreMistakes(false);
  }
  
  // Persistence effects
  useEffect(() => {
    localStorage.setItem('mistake_error_tags', JSON.stringify(errorTags));
  }, [errorTags]);
  
  useEffect(() => {
    applyRuleOfThree({});
  }, []);
  
  // Computed values
  const allTopics = useMemo(() => {
    if (datePeriod === 'all' && topicStatsDoc?.topics && typeof topicStatsDoc.topics === 'object') {
      return Object.keys(topicStatsDoc.topics)
        .map((k) => {
          try { return decodeURIComponent(k); } catch { return k; }
        })
        .filter(Boolean)
        .sort();
    }
    return [...new Set((facetMistakeRows || []).map((m) => m.Topic).filter(Boolean))].sort();
  }, [facetMistakeRows, topicStatsDoc, datePeriod]);

  const topicErrorDensity = useMemo(() => {
    const byTopic = {};
    const totalByTopic = {};

    (questions || []).forEach((q) => {
      if (!q?.Topic) return;
      totalByTopic[q.Topic] = (totalByTopic[q.Topic] || 0) + 1;
    });

    mistakes.forEach((m) => {
      const topic = m.Topic || m.topic;
      if (!topic) return;
      const wrongCount = Number(m.attemptCount || 0);
      const weight = getSrsContributionWeight(m);
      const score = wrongCount * weight;
      byTopic[topic] = (byTopic[topic] || 0) + score;
    });

    return Object.entries(byTopic)
      .map(([topic, score]) => {
        const total = totalByTopic[topic] || 0;
        const density = total > 0 ? score / total : score;
        return { topic, score, density, total };
      })
      .sort((a, b) => b.density - a.density);
  }, [mistakes, questions]);

  useEffect(() => {
    try {
      const top = (topicErrorDensity || []).slice(0, 4);
      localStorage.setItem('dashboard_topics_to_focus_cache_v1', JSON.stringify({
        updatedAt: new Date().toISOString(),
        top
      }));
    } catch {
      // ignore
    }
  }, [topicErrorDensity]);
  
  const availableSubtopics = useMemo(() => {
    const baseRows = facetMistakeRows || [];
    const base = selectedTopics.length > 0
      ? baseRows.filter((m) => selectedTopics.includes(m.Topic))
      : baseRows;
    return [...new Set(base.map((m) => m.Subtopic).filter(Boolean))].sort();
  }, [facetMistakeRows, selectedTopics]);
  
  useEffect(() => {
    setSelectedSubtopics((prev) => {
      const next = prev.filter((s) => availableSubtopics.includes(s));
      if (next.length === prev.length && next.every((v, i) => v === prev[i])) {
        return prev;
      }
      return next;
    });
  }, [availableSubtopics]);
  
  const filteredMistakes = useMemo(() => {
    let result = [...mistakes];
    // Topic/subtopic/date/mastery filters are applied in Firestore query when possible.
    // Any fallback client-side filtering happens during fetch.
    
    const noFilters =
      datePeriod === 'all' &&
      selectedTopics.length === 0 &&
      selectedSubtopics.length === 0 &&
      selectedMasteryLevels.length === 0 &&
      srsPresence === 'all';

    // Allow Load More to increase visible count beyond 40
    if (noFilters && !mistakeIndexHasMore && mistakeIndexRows.length <= 40) {
      return result.slice(0, 40);
    }

    return result;
  }, [mistakes, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence, mistakeIndexHasMore, mistakeIndexRows.length]);

  const selectedMasteryTotalCount = useMemo(() => {
    if (!selectedMasteryLevels || selectedMasteryLevels.length === 0) return null;
    if (!masteryCounts || typeof masteryCounts !== 'object') return null;
    const sum = selectedMasteryLevels.reduce((acc, lvl) => acc + Number(masteryCounts?.[lvl] || 0), 0);
    return Number.isFinite(sum) ? sum : null;
  }, [masteryCounts, selectedMasteryLevels]);

  const globalFilteredTotalCount = useMemo(() => {
    if (datePeriod !== 'all') return null;

    // Subtopic counts aren't tracked globally yet.
    if (selectedSubtopics.length > 0) return null;

    // Topic counts are global only when topicStatsDoc is available (All Time).
    if (selectedTopics.length > 0) {
      if (selectedTopics.length === 1) {
        const topic = selectedTopics[0];
        const override = topicCountOverrides?.[String(topic)];
        if (override != null) {
          const v = Number(override);
          return Number.isFinite(v) ? v : null;
        }
      }

      if (selectedTopics.length >= 2 && selectedTopics.length <= 10 && multiTopicOverrideCount != null) {
        const v = Number(multiTopicOverrideCount);
        return Number.isFinite(v) ? v : null;
      }

      if (!topicStatsDoc?.topics || typeof topicStatsDoc.topics !== 'object') return null;

      const bucketKeys = selectedMasteryLevels.length > 0
        ? selectedMasteryLevels
        : Object.keys(MASTERY_LEVELS);

      const sum = selectedTopics.reduce((acc, topic) => {
        const key = encodeURIComponent(String(topic || ''));
        const entry = topicStatsDoc.topics[key];
        const e = entry && typeof entry === 'object' ? entry : {};

        if (srsPresence === 'in_srs') {
          return acc + Number(e.active || 0);
        }
        if (srsPresence === 'not_in_srs') {
          return acc + Number(e.b_not_in_srs || 0);
        }

        const topicSum = bucketKeys.reduce((bAcc, b) => bAcc + Number(e[`b_${b}`] || 0), 0);
        return acc + topicSum;
      }, 0);

      return Number.isFinite(sum) ? sum : null;
    }

    // If mastery buckets are selected with no topic/subtopic, we have a reliable global total.
    if (selectedMasteryTotalCount != null) return selectedMasteryTotalCount;

    if (srsPresence === 'not_in_srs') {
      if (masteryCounts && typeof masteryCounts === 'object') {
        const v = Number(masteryCounts?.not_in_srs || 0);
        return Number.isFinite(v) ? v : null;
      }
      return null;
    }

    // Otherwise, if masteryCounts exist, they should sum to total mistakes (All Time).
    if (masteryCounts && typeof masteryCounts === 'object' && Object.keys(masteryCounts).length > 0) {
      const sum = Object.values(masteryCounts).reduce((acc, v) => acc + Number(v || 0), 0);
      return Number.isFinite(sum) ? sum : null;
    }

    return totalMistakesCount != null ? Number(totalMistakesCount) : null;
  }, [datePeriod, selectedSubtopics, selectedTopics, topicStatsDoc, selectedMasteryLevels, srsPresence, selectedMasteryTotalCount, masteryCounts, totalMistakesCount, topicCountOverrides, multiTopicOverrideCount]);

  useEffect(() => {
    if (!currentUser?.uid) return;
    if (datePeriod !== 'all') return;
    if (selectedTopics.length === 0) return;
    if (loading) return;
    if (error) return;
    if (loadingMoreMistakes) return;

    // Only auto-normalize when Firestore says there are more docs, but our index query says there's no more.
    // This is the classic symptom of legacy docs missing required fields for the minimal-read query.
    const total = globalFilteredTotalCount;
    const loaded = Number(filteredMistakes?.length || 0);
    if (total == null) return;
    if (!Number.isFinite(Number(total))) return;
    if (!(Number(total) > loaded)) return;

    const doneKey = `normalize_mistakes_done_${currentUser.uid}`;
    const runningKey = `normalize_mistakes_running_${currentUser.uid}`;
    if (localStorage.getItem(doneKey) === '1') return;
    if (localStorage.getItem(runningKey) === '1') return;

    const run = async () => {
      try {
        localStorage.setItem(runningKey, '1');
        const functions = getFunctions(app, 'asia-east1');
        const callable = httpsCallable(functions, 'normalizeMistakes');
        await callable({});
        localStorage.setItem(doneKey, '1');
        localStorage.removeItem(runningKey);
        await refreshTopicStatsDoc();
        await loadMistakes();
      } catch (e) {
        localStorage.removeItem(runningKey);
        console.error('normalizeMistakes failed:', e);
      }
    };

    run();
  }, [
    currentUser?.uid,
    datePeriod,
    selectedTopics,
    selectedSubtopics,
    selectedMasteryLevels,
    srsPresence,
    loading,
    error,
    loadingMoreMistakes,
    globalFilteredTotalCount,
    filteredMistakes,
    refreshTopicStatsDoc,
  ]);

  const facetFilteredCount = useMemo(() => {
    let result = [...(facetMistakeRows || [])];
    if (selectedTopics.length > 0) {
      result = result.filter((m) => selectedTopics.includes(m.Topic));
    }
    if (selectedSubtopics.length > 0) {
      result = result.filter((m) => selectedSubtopics.includes(m.Subtopic));
    }
    if (srsPresence !== 'all') {
      result = result.filter((m) => matchesSrsPresence(m, srsPresence));
    }
    if (selectedMasteryLevels.length > 0) {
      result = result.filter((m) => selectedMasteryLevels.some((lvl) => getSrsBucket(m) === lvl));
    }
    return result.length;
  }, [facetMistakeRows, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence]);

  const topicFacetCountMap = useMemo(() => {
    if (datePeriod === 'all' && topicStatsDoc?.topics && typeof topicStatsDoc.topics === 'object') {
      const map = new Map();

      const bucketKeys = selectedMasteryLevels.length > 0
        ? selectedMasteryLevels
        : Object.keys(MASTERY_LEVELS);

      const includeActiveOnly = srsPresence === 'in_srs';
      const includeNotInSrsOnly = srsPresence === 'not_in_srs';

      Object.entries(topicStatsDoc.topics).forEach(([topicEnc, entry]) => {
        const topic = (() => {
          try { return decodeURIComponent(topicEnc); } catch { return topicEnc; }
        })();
        if (!topic) return;

        const e = entry && typeof entry === 'object' ? entry : {};
        let count = 0;

        if (includeActiveOnly) {
          // active count is maintained by the CF trigger
          count = Number(e.active || 0);
        } else if (includeNotInSrsOnly) {
          count = Number(e.b_not_in_srs || 0);
        } else {
          bucketKeys.forEach((b) => {
            const k = `b_${b}`;
            count += Number(e[k] || 0);
          });
        }

        map.set(topic, count);
      });

      if (topicCountOverrides && typeof topicCountOverrides === 'object') {
        Object.entries(topicCountOverrides).forEach(([topic, v]) => {
          const n = Number(v);
          if (!Number.isFinite(n)) return;
          map.set(topic, n);
        });
      }

      return map;
    }

    const base = [...(facetMistakeRows || [])]
      .filter((m) => (srsPresence === 'all' ? true : matchesSrsPresence(m, srsPresence)))
      .filter((m) => (selectedMasteryLevels.length === 0 ? true : selectedMasteryLevels.some((lvl) => getSrsBucket(m) === lvl)));

    const map = new Map();
    base.forEach((m) => {
      const topic = m?.Topic;
      if (!topic) return;
      map.set(topic, (map.get(topic) || 0) + 1);
    });
    if (topicCountOverrides && typeof topicCountOverrides === 'object') {
      Object.entries(topicCountOverrides).forEach(([topic, v]) => {
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        map.set(topic, n);
      });
    }
    return map;
  }, [facetMistakeRows, srsPresence, selectedMasteryLevels, topicStatsDoc, datePeriod, topicCountOverrides]);

  // Compute whether current filters force client-side search across all matches
  const needsClientSearch = useMemo(() => {
    const built = buildMistakeIndexQueryConstraints({
      userId: currentUser?.uid,
      datePeriod,
      selectedTopics,
      selectedSubtopics,
      selectedMasteryLevels,
      srsPresence,
      cursor: null,
      pageSize: 40,
    });
    return (built.needsClientTopicFilter && built.topics.length > 0) ||
           (built.needsClientSubtopicFilter && built.subs.length > 0) ||
           (built.needsClientMasteryFilter && built.masteryLevels.length > 0) ||
           built.needsClientSrsPresenceFilter;
  }, [currentUser?.uid, datePeriod, selectedTopics, selectedSubtopics, selectedMasteryLevels, srsPresence]);

  useEffect(() => {
    if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') return;
    const mql = window.matchMedia('(hover: hover) and (pointer: fine)');
    const onChange = (e) => setHoverCapable(!!e.matches);
    setHoverCapable(!!mql.matches);
    if (typeof mql.addEventListener === 'function') {
      mql.addEventListener('change', onChange);
      return () => mql.removeEventListener('change', onChange);
    }
    mql.addListener(onChange);
    return () => mql.removeListener(onChange);
  }, []);

  const moreHint = useMemo(() => {
    // Avoid misleading +X when we don't have a reliable global count in filtered modes.
    if (needsClientSearch || srsPresence !== 'all') {
      if (mistakeIndexHasMore) return `(${t('notebook.moreQuestionsHidden')})`;
      return '';
    }

    if (globalFilteredTotalCount != null) {
      const loaded = Number(filteredMistakes?.length || 0);
      const remaining = Math.max(0, Number(globalFilteredTotalCount) - loaded);
      // FIX: when Firestore confirms no more pages, all matching docs are loaded;
      // any remaining count discrepancy is from stale stats or legacy docs — suppress the hint.
      if (!mistakeIndexHasMore) return '';
      if (remaining > 0) return `(${tf('notebook.questionsHidden', { count: remaining })})`;
      return '';
    }

    // If we loaded less than a full page and there's no more, don't show hidden
    const loaded = filteredMistakes?.length || 0;
    if (!mistakeIndexHasMore && loaded < 40) {
      return '';
    }

    const hiddenLowerBound = Math.max(0, facetFilteredCount - loaded);
    if (hiddenLowerBound > 0) return `(${tf('notebook.questionsHidden', { count: hiddenLowerBound })})`;
    if (mistakeIndexHasMore) return `(${t('notebook.moreQuestionsHidden')})`;
    return '';
  }, [facetFilteredCount, filteredMistakes, mistakeIndexHasMore, needsClientSearch, srsPresence, globalFilteredTotalCount, t, tf]);

  useEffect(() => {
    setSelectedMistakeIds((prev) => {
      if (!prev || prev.size === 0) return prev;
      const allowed = new Set((filteredMistakes || []).map((m) => m.ID));
      const next = new Set([...prev].filter((id) => allowed.has(id)));
      if (next.size === prev.size) return prev;
      return next;
    });
  }, [filteredMistakes]);
  
  const practiceCount =
    questionCount === 'All'
      ? filteredMistakes.length
      : Math.min(parseInt(questionCount), filteredMistakes.length);
  
  // Kanban columns
  const kanbanColumns = useMemo(() => ({
    new: filteredMistakes.filter(m => getSrsBucket(m) === 'new'),
    progressing: filteredMistakes.filter(m => getSrsBucket(m) === 'progressing'),
    near: filteredMistakes.filter(m => getSrsBucket(m) === 'near'),
  }), [filteredMistakes]);
  
  // Handlers
  const handleTag = useCallback((questionId, tag) => {
    setErrorTags((prev) => {
      const next = { ...prev };
      if (tag === null) delete next[questionId];
      else next[questionId] = tag;
      return next;
    });
  }, []);
  
  const handleRestoreCard = async (questionId) => {
    if (!currentUser) return;
    
    try {
      // Find the archived card for this question
      const archivedCard = Object.values(archivedMistakes).find(card => card.questionId === questionId || card.ID === questionId);
      if (!archivedCard?.id) {
        console.error('Could not find archived card for question:', questionId);
        return;
      }
      
      await srsService.restoreArchivedCard(archivedCard.id);
      console.log('♻️ Restored card:', questionId);
      
      // Reload data to refresh the lists
      loadMistakes();
    } catch (error) {
      console.error('Error restoring card:', error);
    }
  };
  
  const toggleTopic = useCallback((topic) => {
    setSelectedTopics((prev) =>
      prev.includes(topic) ? prev.filter((t) => t !== topic) : [...prev, topic]
    );
  }, []);
  
  const toggleSubtopic = useCallback((sub) => {
    setSelectedSubtopics((prev) =>
      prev.includes(sub) ? prev.filter((s) => s !== sub) : [...prev, sub]
    );
  }, []);
  
  const toggleMasteryLevel = useCallback((lvl) => {
    setSelectedMasteryLevels((prev) =>
      prev.includes(lvl) ? prev.filter((l) => l !== lvl) : [...prev, lvl]
    );
  }, []);
  
  const handlePracticeMistakes = () => {
    if (filteredMistakes.length === 0) return;
    
    const selected = selectedMistakeIds.size > 0
      ? filteredMistakes.filter(m => selectedMistakeIds.has(m.ID))
      : [...filteredMistakes]
          .sort((a, b) => calcPriority(b) - calcPriority(a))
          .slice(0, practiceCount);
    
    quizStorage.clearQuizData();
    quizStorage.saveSelectedQuestions(selected);

    const selectedSrsCards = selected.filter((card) => !!card?.id);
    if (selectedSrsCards.length === selected.length) {
      localStorage.setItem('quiz_mode', 'spaced-repetition');
      localStorage.setItem(
        'quiz_srs_cards',
        JSON.stringify(
          selectedSrsCards.map((card) => ({
            id: card.id,
            questionId: card.questionId,
            topic: card.topic || card.Topic,
            subtopic: card.subtopic || card.Subtopic || null,
            nextReviewDate: card.nextReviewDate,
            status: card.status,
          }))
        )
      );
    } else {
      localStorage.setItem('quiz_mode', 'mistakes');
      localStorage.removeItem('quiz_srs_cards');
    }

    localStorage.setItem('quiz_timer_enabled', timerEnabled.toString());
    localStorage.setItem('quiz_is_timed_mode', isTimedMode.toString());
    navigate('/quiz');
  };
  
  const toggleMistakeSelection = (questionId) => {
    setSelectedMistakeIds(prev => {
      const next = new Set(prev);
      if (next.has(questionId)) next.delete(questionId);
      else next.add(questionId);
      return next;
    });
  };
  
  const toggleSelectAll = () => {
    if (selectedMistakeIds.size === filteredMistakes.length) {
      setSelectedMistakeIds(new Set());
    } else {
      setSelectedMistakeIds(new Set(filteredMistakes.map(m => m.ID)));
    }
  };
  
  const formatDate = (iso) =>
    new Date(iso).toLocaleDateString('en-GB', {
      day: '2-digit', month: 'short', year: 'numeric',
    });
  
  // Loading state
  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-50">
        <ChemistryLoading />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-screen bg-slate-50">
        <div className="text-center bg-white p-8 rounded-2xl shadow-sm border border-red-200 max-w-lg">
          <p className="text-red-600 font-black mb-2">{t('notebook.loadingMistakes')}</p>
          <p className="text-slate-600 text-sm">{String(error?.message || error)}</p>
        </div>
      </div>
    );
  }
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // RENDER
  // ═══════════════════════════════════════════════════════════════════════════════
  
  return (
    <div className="flex flex-col md:flex-row min-h-0 bg-slate-50">
      {/* Full Question Modal */}
      <AnimatePresence>
        {fullViewMistake && (
          <FullQuestionModal
            mistake={fullViewMistake}
            errorTag={errorTags[fullViewMistake.ID]}
            onTag={handleTag}
            onClose={() => setFullViewMistake(null)}
          />
        )}
      </AnimatePresence>

      {/* Filter Info Modal */}
      <AnimatePresence>
        {filterInfoOpen && (
          <FilterInfoModal onClose={() => setFilterInfoOpen(false)} />
        )}
      </AnimatePresence>

      
      		{/* ══════════════════════════════════════════════════════════════════════════════
			SIDEBAR: Practice Configurator
			══════════════════════════════════════════════════════════════════════════════ */}
		
		<div className="w-full md:w-80 bg-white border-b md:border-b-0 md:border-r border-slate-200 flex flex-col min-h-0 md:sticky md:top-20 md:max-h-[calc(100vh-5rem)] overflow-hidden">
			{/* Header */}
			<div className="p-3 border-b border-slate-200 flex items-center gap-2">
				<button
					onClick={() => navigate('/dashboard')}
					className="p-2 hover:bg-slate-100 rounded-lg transition-all"
            title="Back to Dashboard"
          >
            <ArrowLeft size={20} className="text-slate-700" />
          </button>
          <h1 className="font-black text-lg text-slate-800 flex items-center gap-2">
            <Command size={20} className="text-indigo-600"/>
            {t('notebook.commandCenter')}
          </h1>
        </div>
        
        {/* Configurator */}
        <div className="flex-1 p-3 space-y-4 overflow-y-auto min-h-0">
          {/* Question Count */}
          <div>
            <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2 flex items-center gap-1">
              <Hash size={12} />
              {t('notebook.numberOfQuestions')}
            </label>
            <div className="flex flex-wrap items-center gap-2">
              {['5', '10', '15', '20', 'All'].map((num) => (
                <button
                  key={num}
                  onClick={() => setQuestionCount(num)}
                  disabled={num !== 'All' && parseInt(num) > filteredMistakes.length}
                  className={`px-3 py-1.5 rounded-lg border text-xs font-bold transition-all ${
                    questionCount === num
                      ? 'border-indigo-500 bg-indigo-50 text-indigo-600'
                      : 'border-slate-200 text-slate-500 hover:border-slate-300 disabled:opacity-30'
                  }`}
                >
                  {num}
                </button>
              ))}
              <div className="flex items-center gap-1">
                <span className="text-xs text-slate-500">Custom:</span>
                <input
                  type="number"
                  min="1"
                  max={filteredMistakes.length || 1}
                  value={questionCount === 'All' || ['5','10','15','20'].includes(questionCount) ? '' : questionCount}
                  onChange={(e) => {
                    const val = parseInt(e.target.value);
                    if (val && val > 0) {
                      setQuestionCount(String(Math.min(val, filteredMistakes.length)));
                    }
                  }}
                  placeholder="___"
                  className="w-14 px-2 py-1.5 rounded-lg border border-slate-200 text-xs font-bold text-center focus:border-indigo-500 focus:outline-none"
                />
              </div>
            </div>
          </div>
          
          {/* Time Range & Mastery Level - Horizontal */}
          <div className="grid grid-cols-2 gap-3">
            {/* Date Range */}
            <div>
              <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2 flex items-center gap-1">
                <Calendar size={12} />
                {t('notebook.timeRange')}
              </label>
              <div className="space-y-1">
                {[
                  { value: 'all',   label: t('notebook.allTime') },
                  { value: 'month', label: t('notebook.lastMonth') },
                  { value: 'week',  label: t('notebook.lastWeek') },
                ].map((o) => (
                  <button
                    key={o.value}
                    onClick={() => setDatePeriod(o.value)}
                    className={`w-full px-2 py-1.5 rounded-lg border text-[11px] font-bold text-left transition-all ${
                      datePeriod === o.value
                        ? 'border-indigo-500 bg-indigo-50 text-indigo-700'
                        : 'border-slate-200 text-slate-600 hover:border-slate-300'
                    }`}
                  >
                    {o.label}
                  </button>
                ))}
              </div>
            </div>
            
            {/* Mastery Level */}
            <div>
              <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2">
                {t('notebook.masteryLevel')}
              </label>
              <div className="space-y-1">
                {Object.entries(MASTERY_LEVELS).map(([key, lvl]) => {
                  const count = Number(masteryCounts?.[key] ?? mistakes.filter((m) => getSrsBucket(m) === key).length);
                  
                  return (
                    <button
                      key={key}
                      onClick={() => toggleMasteryLevel(key)}
                      className={`w-full text-left px-2 py-1.5 rounded-lg border-2 font-bold text-[11px] transition-all flex items-center justify-between ${
                        selectedMasteryLevels.includes(key)
                          ? `bg-${lvl.color}-50 border-${lvl.color}-400 text-${lvl.color}-800`
                          : `bg-white border-${lvl.color}-200 text-${lvl.color}-700`
                      }`}
                    >
                      {t(lvl.labelKey)}
                      <span className="ml-1 opacity-70">({count})</span>
                    </button>
                  );
                })}
              </div>
            </div>
          </div>

          {/* SRS Presence */}
          <div>
            <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2">
              {t('notebook.srsPresence')}
            </label>
            <div className="grid grid-cols-3 gap-2">
              {[{
                value: 'all',
                label: t('notebook.srsPresenceAll')
              }, {
                value: 'in_srs',
                label: t('notebook.srsPresenceInSrs')
              }, {
                value: 'not_in_srs',
                label: t('notebook.srsPresenceNotInSrs')
              }].map((o) => (
                <button
                  key={o.value}
                  onClick={() => setSrsPresence(o.value)}
                  className={`px-2 py-1.5 rounded-lg border text-[11px] font-bold transition-all ${
                    srsPresence === o.value
                      ? 'border-indigo-500 bg-indigo-50 text-indigo-700'
                      : 'border-slate-200 text-slate-600 hover:border-slate-300'
                  }`}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>
          
          {/* Topics */}
          {allTopics.length > 1 && (
            <div>
              <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2 flex items-center gap-1">
                {t('notebook.topics')}
                <InfoIconButton
                  title={t('notebook.filterInfoTitle')}
                  body={t('notebook.filterInfoBody')}
                  onOpenModal={() => setFilterInfoOpen(true)}
                  hoverCapable={hoverCapable}
                />
              </label>
              <div className="space-y-1 max-h-80 overflow-y-auto">
                {allTopics.map((topic) => (
                  <button
                    key={topic}
                    onClick={() => toggleTopic(topic)}
                    className={`w-full px-3 py-2 rounded-lg text-xs font-bold text-left border transition-all ${
                      selectedTopics.includes(topic)
                        ? 'bg-indigo-500 border-indigo-500 text-white'
                        : 'bg-white border-slate-200 text-slate-600 hover:border-indigo-300'
                    }`}
                  >
                    {topic}
                    <span className="ml-1 opacity-70">
                      ({topicFacetCountMap.get(topic) || 0})
                    </span>
                  </button>
                ))}
              </div>
            </div>
          )}
          
          {/* Subtopics */}
          {availableSubtopics.length > 1 && (
            <div>
              <label className="text-xs font-black text-slate-600 uppercase tracking-widest mb-2 flex items-center gap-1">
                {t('notebook.subtopics')}
                <InfoIconButton
                  title={t('notebook.filterInfoTitle')}
                  body={t('notebook.filterInfoBody')}
                  onOpenModal={() => setFilterInfoOpen(true)}
                  hoverCapable={hoverCapable}
                />
              </label>
              <div className="space-y-1 max-h-80 overflow-y-auto">
                {availableSubtopics.slice(0, 12).map((sub) => (
                  <button
                    key={sub}
                    onClick={() => toggleSubtopic(sub)}
                    className={`w-full px-3 py-2 rounded-lg text-xs font-bold text-left border transition-all ${
                      selectedSubtopics.includes(sub)
                        ? 'bg-indigo-400 border-indigo-400 text-white'
                        : 'bg-white border-slate-200 text-slate-600 hover:border-indigo-200'
                    }`}
                  >
                    {sub}
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Fixed Timer Settings */}
        <div className="p-3 border-t border-slate-200 bg-white flex-shrink-0 space-y-2">
          <button
            onClick={() => setTimerEnabled(!timerEnabled)}
            className={`w-full px-3 py-2 rounded-lg text-xs font-bold border transition-all text-left flex items-center justify-between ${
              timerEnabled
                ? 'bg-green-600 border-green-600 text-white'
                : 'bg-white border-slate-200 text-slate-600'
            }`}
          >
            <span className="flex items-center gap-1">
              <Clock size={12} />
              {t('notebook.timerEnabled')}
            </span>
            {timerEnabled && <Check size={14} />}
          </button>
          {timerEnabled && (
            <button
              onClick={() => setIsTimedMode(!isTimedMode)}
              className={`w-full px-3 py-2 rounded-lg text-xs font-bold border transition-all text-left flex items-center justify-between ${
                isTimedMode
                  ? 'bg-amber-600 border-amber-600 text-white'
                  : 'bg-white border-slate-200 text-slate-600'
              }`}
            >
              <span className="flex items-center gap-1">
                <Zap size={12} />
                {t('notebook.timedMode')}
              </span>
              {isTimedMode && <Check size={14} />}
            </button>
          )}
        </div>
        
        {/* Practice Button */}
        <div className="p-3 border-t border-slate-200 bg-white flex-shrink-0">
          <button
            onClick={handlePracticeMistakes}
            disabled={filteredMistakes.length === 0}
            className="w-full py-2.5 bg-orange-600 text-white rounded-xl font-black text-sm shadow-lg hover:bg-orange-700 disabled:bg-slate-300 transition-all flex items-center justify-center gap-2 active:scale-95"
          >
            <Play fill="currentColor" size={16} />
            {selectedMistakeIds.size > 0 
              ? tf('notebook.practiceSelected', { count: selectedMistakeIds.size })
              : tf('notebook.practiceMistakesCount', { 
                  count: practiceCount,
                  plural: practiceCount !== 1 ? 's' : ''
                })}
          </button>
          <p className="text-xs text-slate-500 mt-2 text-center">
            {filteredMistakes.length} {t('notebook.questionsAvailable')}
          </p>
        </div>
      </div>
      
      {/* ═══════════════════════════════════════════════════════════════════════════════
          MAIN WORKSPACE: Tabbed Interface
          ═══════════════════════════════════════════════════════════════════════════════ */}
      
      <div className="flex-1 flex flex-col min-h-0">
        {/* Tab Navigation */}
        <div className="bg-white border-b border-slate-200 p-3 sm:p-4">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-4">
            <div className="flex flex-wrap items-center gap-2">
              <button
                onClick={() => setActiveTab('analytics')}
                className={`px-3 sm:px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  activeTab === 'analytics'
                    ? 'bg-indigo-100 text-indigo-700 border-2 border-indigo-500'
                    : 'bg-slate-100 text-slate-600 border-2 border-slate-200 hover:border-slate-300'
                }`}
              >
                <Brain size={16} className="inline mr-2" />
                {t('notebook.learningInsights')}
              </button>
              <button
                onClick={() => setActiveTab('deck')}
                className={`px-3 sm:px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  activeTab === 'deck'
                    ? 'bg-indigo-100 text-indigo-700 border-2 border-indigo-500'
                    : 'bg-slate-100 text-slate-600 border-2 border-slate-200 hover:border-slate-300'
                }`}
              >
                <Grid3x3 size={16} className="inline mr-2" />
                {t('notebook.mistakeDeck')} ({filteredMistakes.length})
              </button>
              <button
                onClick={() => setActiveTab('archive')}
                className={`px-3 sm:px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  activeTab === 'archive'
                    ? 'bg-indigo-100 text-indigo-700 border-2 border-indigo-500'
                    : 'bg-slate-100 text-slate-600 border-2 border-slate-200 hover:border-slate-300'
                }`}
              >
                <Archive size={16} className="inline mr-2" />
                {t('notebook.archive')} ({Object.keys(archivedMistakes).length})
              </button>
            </div>
            
            {activeTab === 'deck' && (
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setViewMode('list')}
                  className={`p-2 rounded-lg transition-all ${
                    viewMode === 'list'
                      ? 'bg-indigo-500 text-white'
                      : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                  }`}
                  title={t('notebook.listView')}
                >
                  <ListIcon size={18} />
                </button>
                <button
                  onClick={() => setViewMode('kanban')}
                  className={`p-2 rounded-lg transition-all ${
                    viewMode === 'kanban'
                      ? 'bg-indigo-500 text-white'
                      : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                  }`}
                  title={t('notebook.kanbanView')}
                >
                  <Grid3x3 size={18} />
                </button>
              </div>
            )}
          </div>
          
          {/* Filter Summary */}
          {(selectedTopics.length > 0 || selectedMasteryLevels.length > 0 || datePeriod !== 'all') && (
            <div className="flex flex-wrap gap-2 text-xs">
              {selectedTopics.map(t => (
                <span key={t} className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full font-semibold">
                  {tf('notebook.topicFilter', { topic: t })}
                  <button onClick={() => toggleTopic(t)} className="ml-1">✕</button>
                </span>
              ))}
              {selectedMasteryLevels.map(l => (
                <span key={l} className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full font-semibold">
                  {t(MASTERY_LEVELS[l].labelKey)}
                  <button onClick={() => toggleMasteryLevel(l)} className="ml-1">✕</button>
                </span>
              ))}
              {datePeriod !== 'all' && (
                <span className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full font-semibold">
                  {datePeriod === 'week' ? t('notebook.lastWeek') : t('notebook.lastMonth')}
                  <button onClick={() => setDatePeriod('all')} className="ml-1">✕</button>
                </span>
              )}
            </div>
          )}
        </div>
        
        {/* Tab Content */}
        <div className="flex-1 p-3 sm:p-6 overflow-y-auto min-h-0">
          <AnimatePresence mode="wait">
            {/* Tab 1: Learning Insights */}
            {activeTab === 'analytics' && mistakes.length > 0 && (
              <motion.div
                key="analytics"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                className="space-y-6"
              >
                {/* Quick Stats */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div className="bg-white rounded-xl p-4 border border-slate-200 shadow-sm">
                    <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-2">
                      {t('notebook.totalMistakes')}
                    </div>
                    <div className="text-3xl font-black text-red-600">{totalMistakesCount ?? mistakes.length}</div>
                  </div>
                  <div className="bg-white rounded-xl p-4 border border-slate-200 shadow-sm">
                    <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-2">
                      {t('notebook.topicsToFocus')}
                    </div>
                    <div className="text-3xl font-black text-amber-600">
                      {new Set(mistakes.map((m) => m.Topic)).size}
                    </div>
                  </div>
                  <div className="bg-white rounded-xl p-4 border border-slate-200 shadow-sm">
                    <div className="text-xs font-black text-slate-500 uppercase tracking-widest mb-2">
                      {t('notebook.repeatedMistakes')}
                    </div>
                    <div className="text-3xl font-black text-green-600">
                      {mistakes.filter((m) => m.attemptCount > 1).length}
                    </div>
                  </div>
                </div>
                
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                  {/* LEFT: Error density + topic order */}
                  <div className="lg:col-span-1 space-y-6">
                    <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
                      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
                        <Target size={20} className="text-rose-600" />
                        {t('notebook.topicsToFocus')}
                      </h3>

                      <div className="space-y-2">
                        {topicErrorDensity.slice(0, 10).map((row, idx) => (
                          <button
                            key={row.topic}
                            onClick={() => toggleTopic(row.topic)}
                            className={`w-full text-left p-3 rounded-xl border transition-all hover:shadow-sm ${
                              selectedTopics.includes(row.topic)
                                ? 'border-rose-300 bg-rose-50'
                                : 'border-slate-200 bg-white hover:bg-slate-50'
                            }`}
                          >
                            <div className="flex items-center justify-between gap-3">
                              <div className="min-w-0">
                                <div className="text-sm font-black text-slate-800 truncate">
                                  #{idx + 1} {row.topic}
                                </div>
                                <div className="text-xs text-slate-500 mt-0.5">
                                  {tf('notebook.topicFilter', { topic: row.topic })}
                                </div>
                              </div>

                              <div className="shrink-0 text-right">
                                <div className="text-xs font-black text-rose-600">
                                  {row.density.toFixed(2)}
                                </div>
                                <div className="text-[11px] text-slate-500">
                                  {Math.round(row.score)} / {row.total || '—'}
                                </div>
                              </div>
                            </div>
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Optional: keep the interactive heatmap (mistake-based) */}
                    <InteractiveTopicHeatmap 
                      mistakes={mistakes} 
                      selectedTopics={selectedTopics}
                      onTopicToggle={toggleTopic}
                    />
                  </div>

                  {/* RIGHT: SRS charts */}
                  <div className="lg:col-span-2 space-y-6">
                    <RetentionDashboard cards={srsCards} attempts={reviewAttempts} />
                    <div className="grid grid-cols-1 gap-6">
                      <CalendarHeatmap attempts={reviewAttempts} />
                      <ImprovementTrendChart cards={srsCards} attempts={reviewAttempts} />
                    </div>
                  </div>
                </div>
              </motion.div>
            )}
            
            {/* Tab 2: Mistake Deck */}
            {activeTab === 'deck' && (
              <motion.div
                key="deck"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
              >
                {mistakes.length === 0 ? (
                  <div className="text-center py-12">
                    <CheckCircle className="w-16 h-16 text-green-300 mx-auto mb-4" />
                    <p className="text-slate-400 text-lg mb-2 font-semibold">
                      {t('notebook.noMistakesYet')}
                    </p>
                    <p className="text-slate-500 text-sm mb-4">
                      {t('notebook.keepPracticing')}
                    </p>
                    <button
                      onClick={() => navigate('/practice')}
                      className="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all"
                    >
                      {t('notebook.startPracticing')}
                    </button>
                  </div>
                ) : filteredMistakes.length === 0 ? (
                  <div className="text-center py-12">
                    <AlertCircle className="w-16 h-16 text-amber-300 mx-auto mb-4" />
                    <p className="text-slate-400 text-lg mb-2 font-semibold">
                      {t('notebook.noQuestionsFound')}
                    </p>
                    <p className="text-slate-500 text-sm">
                      {t('notebook.tryAdjustFilters')}
                    </p>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {viewMode === 'list' ? (
                      <ListViewDeck
                        mistakes={filteredMistakes}
                        errorTags={errorTags}
                        onTag={handleTag}
                        selectedIds={selectedMistakeIds}
                        onToggleSelect={toggleMistakeSelection}
                        onToggleSelectAll={toggleSelectAll}
                        allSelected={selectedMistakeIds.size === filteredMistakes.length}
                        moreHint={moreHint}
                        totalCount={
                          globalFilteredTotalCount != null
                            ? Math.max(
                                Number(globalFilteredTotalCount) || 0,
                                Number(filteredMistakes?.length || 0)
                              )
                            : null
                        }
                        onViewFull={setFullViewMistake}
                      />
                    ) : (
                      // FIX: was incorrectly named <KanbanDeck> — component is KanbanViewDeck
                      <KanbanViewDeck
                        columns={kanbanColumns}
                        errorTags={errorTags}
                        onTag={handleTag}
                        selectedIds={selectedMistakeIds}
                        onToggleSelect={toggleMistakeSelection}
                        onToggleSelectAll={toggleSelectAll}
                        allSelected={selectedMistakeIds.size === filteredMistakes.length}
                        onViewFull={setFullViewMistake}
                      />
                    )}

                    {mistakeIndexHasMore && (
                      <div className="flex justify-center">
                        <button
                          type="button"
                          onClick={loadMoreMistakes}
                          disabled={loadingMoreMistakes}
                          className="px-5 py-2.5 rounded-xl border-2 border-slate-200 bg-white font-black text-slate-700 hover:bg-slate-50 transition-all disabled:opacity-50"
                        >
                          {loadingMoreMistakes ? 'Loading…' : 'Load more'}
                        </button>
                      </div>
                    )}
                  </div>
                )}
              </motion.div>
            )}
            
            {/* Tab 3: Mastery Archive */}
            {activeTab === 'archive' && (
              <motion.div
                key="archive"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
              >
                {Object.keys(archivedMistakes).length === 0 ? (
                  <div className="text-center py-12">
                    <Archive className="w-16 h-16 text-slate-300 mx-auto mb-4" />
                    <p className="text-slate-400 text-lg mb-2 font-semibold">
                      {t('notebook.noArchivedYet')}
                    </p>
                    <div className="max-w-2xl mx-auto space-y-3">
                      <p className="text-slate-500 text-sm">
                        {t('notebook.archiveInstructions')}
                      </p>

                      <div className="p-4 rounded-xl border-2 bg-emerald-50 border-emerald-200 text-left">
                        <div className="text-sm font-black text-slate-800 mb-1">
                          {t('notebook.archiveMasteryHowTitle')}
                        </div>
                        <div className="text-xs text-slate-600 leading-relaxed">
                          {t('notebook.archiveMasteryHowBody')}
                        </div>
                      </div>

                      <div className="p-4 rounded-xl border-2 bg-amber-50 border-amber-200 text-left">
                        <div className="text-sm font-black text-slate-800 mb-1">
                          {t('notebook.archiveOverdueHowTitle')}
                        </div>
                        <div className="text-xs text-slate-600 leading-relaxed">
                          {t('notebook.archiveOverdueHowBody')}
                        </div>
                      </div>
                    </div>
                  </div>
                ) : (
                  (() => {
                    const allArchived = Object.values(archivedMistakes);
                    const overdueArchived = allArchived.filter((q) => q.archiveReason === 'overdue_7_days' || q.archiveReason === 'overdue_14_days');
                    const masteryArchived = allArchived.filter((q) => q.archiveReason !== 'overdue_7_days' && q.archiveReason !== 'overdue_14_days');

                    const activeList = archiveSubTab === 'overdue' ? overdueArchived : masteryArchived;
                    const activeCount = activeList.length;

                    const renderCard = (question) => (
                      <motion.div
                        key={question?.docId ?? question?.ID}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        className="p-4 rounded-lg bg-gradient-to-r from-green-50 to-emerald-50 border-2 border-green-300"
                      >
                        <div className="flex items-start justify-between mb-2">
                          <div>
                            <div className="text-xs font-bold text-green-700 uppercase">
                              {question.Topic}
                            </div>
                            <div className="text-xs text-green-600">{question.Subtopic}</div>
                            {question.archiveReason && (
                              <div className="text-xs text-amber-600 font-semibold mt-1">
                                {question.archiveReason === 'overdue_7_days' || question.archiveReason === 'overdue_14_days' 
                                  ? 'Auto-archived (14+ days overdue)' 
                                  : 'Archived'}
                              </div>
                            )}
                          </div>
                          <div className="text-right">
                            <div className="text-xs text-green-600 font-bold flex items-center gap-1">
                              <CheckCircle size={14} />
                              {tf('notebook.masteredOn', { date: formatDate(question.archivedAt) })}
                            </div>
                            <button
                              onClick={() => handleRestoreCard(question.ID)}
                              className="mt-1 text-xs text-indigo-600 hover:text-indigo-800 font-semibold flex items-center gap-1"
                            >
                              <PlusCircle size={12} />
                              Restore
                            </button>
                          </div>
                        </div>
                        <div className="text-sm text-green-900 font-medium mb-2">
                          {question.Question?.replace(/<[^>]*>/g, '').substring(0, 100)}...
                        </div>
                        <div className="flex items-center gap-4 text-xs text-slate-600">
                          <span>Original attempts: {question.attemptCount || 1}</span>
                          <span>SRS reviews: {question.repetitionCount || 0}</span>
                          {question.interval && <span>Interval: {question.interval} days</span>}
                        </div>
                      </motion.div>
                    );

                    return (
                      <div className="space-y-6">
                        <div className="flex items-center justify-between gap-2 flex-wrap">
                          <div className="flex items-center gap-2">
                            <button
                              type="button"
                              onClick={() => setArchiveSubTab('mastery')}
                              className={`px-3 py-1.5 rounded-lg text-sm font-black border-2 transition-all ${
                                archiveSubTab === 'mastery'
                                  ? 'bg-emerald-600 text-white border-emerald-600'
                                  : 'bg-white text-slate-700 border-slate-200 hover:bg-slate-50'
                              }`}
                            >
                              {t('notebook.archiveSubtabMastery')} ({masteryArchived.length})
                            </button>
                            <button
                              type="button"
                              onClick={() => setArchiveSubTab('overdue')}
                              className={`px-3 py-1.5 rounded-lg text-sm font-black border-2 transition-all ${
                                archiveSubTab === 'overdue'
                                  ? 'bg-amber-500 text-white border-amber-500'
                                  : 'bg-white text-slate-700 border-slate-200 hover:bg-slate-50'
                              }`}
                            >
                              {t('notebook.archiveSubtabOverdue')} ({overdueArchived.length})
                            </button>
                          </div>

                          <div className="text-xs text-slate-500 font-semibold">
                            {tf('notebook.archiveSubtabCount', { count: activeCount })}
                          </div>
                        </div>

                        <div className={`p-4 rounded-xl border-2 ${archiveSubTab === 'overdue' ? 'bg-amber-50 border-amber-200' : 'bg-emerald-50 border-emerald-200'}`}>
                          <div className="text-sm font-black text-slate-800 mb-1">
                            {archiveSubTab === 'overdue'
                              ? t('notebook.archiveOverdueHowTitle')
                              : t('notebook.archiveMasteryHowTitle')}
                          </div>
                          <div className="text-xs text-slate-600 leading-relaxed">
                            {archiveSubTab === 'overdue'
                              ? t('notebook.archiveOverdueHowBody')
                              : t('notebook.archiveMasteryHowBody')}
                          </div>
                        </div>

                        {activeList.length === 0 ? (
                          <div className="text-center py-10">
                            <div className="text-sm font-black text-slate-700 mb-1">
                              {archiveSubTab === 'overdue'
                                ? t('notebook.noOverdueArchives')
                                : t('notebook.noMasteryArchives')}
                            </div>
                            <div className="text-xs text-slate-500">
                              {archiveSubTab === 'overdue'
                                ? t('notebook.noOverdueArchivesHint')
                                : t('notebook.noMasteryArchivesHint')}
                            </div>
                          </div>
                        ) : (
                          <div className="space-y-3">
                            {activeList.map(renderCard)}
                          </div>
                        )}
                      </div>
                    );
                  })()
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
}

========================================================================================================================
FILE: src/services/quizCompletionService.js
------------------------------------------------------------------------------------------------------------------------
/**
 * Quiz Completion Service - REFACTORED FOR JIT SRS
 * 
 * KEY CHANGES:
 * 1. ✅ Uses new SRS service for spaced repetition
 * 2. ✅ Creates completion events in calendar
 * 3. ✅ Records performance for AI recommendations
 * 4. ✅ No more pre-scheduling multiple reviews
 */

import { db } from '../firebase/config';
import { 
  collection, 
  doc, 
  setDoc,
  writeBatch,
  increment,
  Timestamp 
} from 'firebase/firestore';
import { performanceService } from './performanceService';
import { srsService } from './srsService';

async function upsertMistakeIndex(userId, wrongAnswers, userAnswers, attemptId) {
  if (!userId) return;
  if (!Array.isArray(wrongAnswers) || wrongAnswers.length === 0) return;

  const nowIso = new Date().toISOString();
  const batch = writeBatch(db);

  wrongAnswers.forEach((q) => {
    const questionId = q?.ID;
    if (!questionId) return;
    const ref = doc(db, 'users', userId, 'mistakes', String(questionId));
    batch.set(
      ref,
      {
        ID: questionId,
        questionId,
        Topic: q?.Topic || q?.topic || null,
        Subtopic: q?.Subtopic || q?.subtopic || null,
        lastAttempted: nowIso,
        lastWrongAt: nowIso,
        lastAttemptId: attemptId || null,
        lastUserAnswer: userAnswers?.[questionId] ?? null,
        attemptCount: increment(1),
        // SRS meta (denormalized). Defaults mean "not yet in SRS".
        hasSrsCard: false,
        srsIsActive: false,
        srsStatus: null,
        srsBucket: 'not_in_srs',
        srsUpdatedAt: nowIso,
        updatedAt: nowIso,
        createdAt: nowIso,
      },
      { merge: true }
    );
  });

  await batch.commit();
}

/**
 * 🎯 MAIN FUNCTION: Process quiz completion
 * 
 * This function:
 * 1. Records performance data for AI recommendations
 * 2. Creates SRS cards for wrong answers using JIT scheduling
 * 3. Logs completion to calendar with full metadata
 */
export async function processQuizCompletion(userId, questions, userAnswers, attemptId = null) {
  const options = arguments.length >= 5 && arguments[4] ? arguments[4] : {};
  const createSrsCards = options?.createSrsCards !== false;
  const results = {
    performanceRecorded: false,
    srsCardsCreated: 0,
    completionLogged: false,
    errors: []
  };

  try {
    // Generate session ID for this quiz
    const sessionId = attemptId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    console.log('📊 Processing quiz completion:', {
      userId,
      sessionId,
      totalQuestions: questions.length
    });

    // STEP 1: Record performance data (for AI recommendations)
    console.log('📊 Recording performance data...');
    try {
      await performanceService.recordQuizResults(userId, questions, userAnswers);
      results.performanceRecorded = true;
      console.log('✅ Performance data recorded');
    } catch (error) {
      console.error('⚠️ Performance recording error:', error);
      results.errors.push('Performance recording failed: ' + error.message);
    }

    // STEP 2: Create SRS cards for wrong answers (JIT scheduling)
    console.log('🧠 Creating SRS cards for wrong answers...');
    
    const wrongAnswers = questions.filter(q => userAnswers[q.ID] !== q.CorrectOption);

    try {
      await upsertMistakeIndex(userId, wrongAnswers, userAnswers, attemptId);
    } catch (error) {
      console.error('⚠️ Mistake index update error:', error);
      results.errors.push('Mistake index update failed: ' + error.message);
    }
    
    if (wrongAnswers.length > 0 && createSrsCards) {
      console.log(`📝 Found ${wrongAnswers.length} wrong answers`);
      
      try {
        const cards = await srsService.createCardsFromMistakes(
          userId,
          wrongAnswers,
          sessionId,
          attemptId
        );
        
        results.srsCardsCreated = cards.length;
        console.log(`✅ Created ${cards.length} SRS card(s)`);
      } catch (error) {
        console.error('⚠️ SRS card creation error:', error);
        results.errors.push('SRS creation failed: ' + error.message);
      }
    } else {
      console.log('🎉 Perfect score! No SRS cards needed.');
    }

    results.completionLogged = true;

  } catch (error) {
    console.error('❌ Error in quiz completion processing:', error);
    results.errors.push(error.message);
  }

  return results;
}

/**
 * 🔧 Log detailed completion to calendar
 * 
 * This creates a completion event in the calendar with:
 * - Score and percentage
 * - Topics/subtopics covered
 * - Question count
 * - Link back to results page
 * 
 * @param {string} userId - User ID
 * @param {string} attemptId - Attempt ID (for linking back to results)
 * @param {Object} completionData - Quiz completion details
 */
export async function logDetailedCompletion(userId, attemptId, completionData) {
  const {
    totalQuestions,
    correctAnswers,
    percentage,
    topics,
    subtopics,
    timeSpent,
    mode,
    eventId,
    date,
    completedAt,
    title
  } = completionData;

  // Use provided date or today
  const completionDate = date || new Date().toISOString().split('T')[0];
  
  const completionEvent = {
    id: `completion_${attemptId}`,
    userId,
    type: 'completion',
    date: completionDate,
    
    // Display info
    title: title || `Completed: ${percentage}%`,
    description: `${correctAnswers}/${totalQuestions} correct`,
    
    // Performance data
    totalQuestions,
    correctAnswers,
    percentage,
    accuracy: percentage / 100,
    
    // Content covered
    topics: topics || [],
    subtopics: subtopics || [],
    
    // Timing
    timeSpent: timeSpent || null,
    
    // Link back to results
    attemptId,  // CRITICAL: Links to the original attempt for viewing results
    
    // Quiz context
    mode: mode || 'practice',
    linkedEventId: eventId || null,
    
    // Timestamps
    completedAt: completedAt || new Date().toISOString(),
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  console.log('📝 Logging detailed completion to calendar:', completionEvent);

  try {
    await setDoc(
      doc(db, 'calendar_events', completionEvent.id),
      completionEvent
    );
    console.log('✅ Completion logged to calendar');
  } catch (error) {
    console.error('❌ Error logging completion:', error);
    throw error;
  }

  return completionEvent;
}

/**
 * 🔧 Handle spaced repetition review completion
 * 
 * When user completes an SRS review, this:
 * 1. Submits the review to SRS service
 * 2. SRS service automatically calculates next review date
 * 3. Returns updated card state
 * 
 * @param {string} cardId - SRS card ID
 * @param {boolean} wasCorrect - Did user answer correctly?
 * @param {Object} attemptData - Additional attempt data
 */
export async function handleReviewCompletion(cardId, wasCorrect, attemptData = {}) {
  try {
    console.log(`📝 Handling review completion: ${cardId}, correct: ${wasCorrect}`);

    // Submit review to SRS service
    // This will:
    // 1. Record the attempt
    // 2. Update card state
    // 3. Calculate ONLY the next single review date
    const result = await srsService.submitReview(cardId, wasCorrect, attemptData);

    console.log(`✅ Review processed:`, {
      cardId,
      wasCorrect,
      nextReview: result.card.nextReviewDate,
      newInterval: result.card.interval,
      newStatus: result.card.status
    });

    return result;

  } catch (error) {
    console.error('❌ Error handling review completion:', error);
    throw error;
  }
}

/**
 * 🔧 Handle multiple review completions (batch)
 * 
 * Used when user completes a review session with multiple cards
 * 
 * @param {string} userId - User ID
 * @param {Array} reviews - Array of {cardId, wasCorrect, userAnswer}
 */
export async function handleReviewSessionCompletion(userId, reviews) {
  try {
    console.log(`🎯 Handling review session: ${reviews.length} cards`);

    const result = await srsService.submitReviewSession(userId, reviews);

    console.log(`✅ Review session completed:`, {
      sessionId: result.session.id,
      cardsReviewed: result.session.cardsReviewed,
      cardsCorrect: result.session.cardsCorrect,
      cardsFailed: result.session.cardsFailed
    });

    return result;

  } catch (error) {
    console.error('❌ Error handling review session:', error);
    throw error;
  }
}

/**
 * 🔧 Get SRS cards due for review
 * 
 * @param {string} userId - User ID
 */
export async function getDueReviews(userId) {
  try {
    const dueCards = await srsService.getDueCards(userId);
    
    console.log(`📊 Found ${dueCards.length} cards due for review`);
    
    return dueCards;
  } catch (error) {
    console.error('❌ Error getting due reviews:', error);
    throw error;
  }
}

/**
 * 🔧 Get SRS statistics for user
 * 
 * @param {string} userId - User ID
 */
export async function getReviewStats(userId) {
  try {
    const stats = await srsService.getReviewStats(userId);
    
    console.log(`📊 Review stats for ${userId}:`, stats);
    
    return stats;
  } catch (error) {
    console.error('❌ Error getting review stats:', error);
    throw error;
  }
}

export const quizCompletionService = {
  processQuizCompletion,
  logDetailedCompletion,
  handleReviewCompletion,
  handleReviewSessionCompletion,
  getDueReviews,
  getReviewStats
};

export default quizCompletionService;

========================================================================================================================
FILE: src/services/srsService.js
------------------------------------------------------------------------------------------------------------------------
/**
 * SRS Service - Firestore Integration
 * 
 * Manages spaced repetition cards using Just-in-Time scheduling
 * 
 * CRITICAL: This service NEVER pre-schedules multiple reviews.
 * Reviews are created ONE AT A TIME as users complete them.
 */

import { db } from '../firebase/config';
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc,
  getDocs,
  getCountFromServer,
  updateDoc,
  deleteDoc,
  query, 
  where,
  orderBy,
  limit,
  Timestamp,
  writeBatch
} from 'firebase/firestore';
import { getNow } from '../utils/timeTravel';
import { formatHKDateKey } from '../utils/hkTime';
import {
  createNewCard,
  updateCardAfterReview,
  isCardDue,
  shouldArchiveCard,
  SRS_CONFIG
} from './srsAlgorithm';

// Collection names
const COLLECTIONS = {
  CARDS: 'spaced_repetition_cards',
  ATTEMPTS: 'review_attempts',
  SESSIONS: 'review_sessions'
};

function deriveSrsBucketFromCard(card) {
  if (!card || typeof card !== 'object') return 'not_in_srs';
  if (card.isActive === false) return 'archived';
  if (card.status === 'new') return 'new';
  if (card.status === 'learning') return 'progressing';
  if (card.status === 'review') return 'near';
  if (card.status === 'graduated') return 'archived';
  return 'progressing';
}

async function upsertMistakeSrsMeta(userId, questionId, cardOrNull) {
  if (!userId || !questionId) return;

  const ref = doc(db, 'users', userId, 'mistakes', String(questionId));

  if (!cardOrNull) {
    await setDoc(ref, {
      hasSrsCard: false,
      srsIsActive: false,
      srsStatus: null,
      srsBucket: 'not_in_srs',
      srsUpdatedAt: new Date().toISOString(),
    }, { merge: true });
    return;
  }

  await setDoc(ref, {
    hasSrsCard: true,
    srsIsActive: cardOrNull.isActive !== false,
    srsStatus: cardOrNull.status || null,
    srsBucket: deriveSrsBucketFromCard(cardOrNull),
    srsCardId: cardOrNull.id || null,
    srsUpdatedAt: new Date().toISOString(),
  }, { merge: true });
}

async function findAnyCardForQuestion(userId, questionId) {
  if (!userId || !questionId) return null;

  // Prefer deterministic ID (new behavior)
  const deterministicId = `card_${userId}_${questionId}`;
  const deterministicRef = doc(db, COLLECTIONS.CARDS, deterministicId);
  const deterministicSnap = await getDoc(deterministicRef);
  if (deterministicSnap.exists()) {
    return { id: deterministicSnap.id, ...deterministicSnap.data() };
  }

  // Backward-compatibility: legacy cards were session-scoped IDs.
  // We pick any existing card for this question.
  const q = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('questionId', '==', questionId),
    limit(1)
  );

  const snap = await getDocs(q);
  if (snap.empty) return null;
  const d = snap.docs[0];
  return { id: d.id, ...d.data() };
}

function resetCardForReactivation(card, { topic, subtopic, attemptId }) {
  const now = getNow();
  const nextReviewDate = formatHKDateKey(new Date(now.getTime() + 86400000));
  return {
    ...card,
    topic: topic ?? card.topic ?? null,
    subtopic: subtopic ?? card.subtopic ?? null,

    interval: 1,
    easeFactor: 2.5,
    repetitionCount: 0,
    status: 'new',
    currentAttemptNumber: 0,

    nextReviewDate,
    lastReviewedAt: null,
    isDue: false,

    totalAttempts: 0,
    successfulAttempts: 0,
    failedAttempts: 0,

    isActive: true,
    archivedAt: null,
    archiveReason: null,
    createdFromAttemptId: attemptId ?? card.createdFromAttemptId ?? null,
    updatedAt: now.toISOString(),
  };
}

/**
 * Create SRS cards for wrong answers from a quiz
 * 
 * @param {string} userId - User ID
 * @param {Array} wrongQuestions - Questions answered incorrectly
 * @param {string} sessionId - Original quiz session ID
 * @param {string} attemptId - Original quiz attempt ID
 * @returns {Promise<Array>} Created cards
 */
export async function createCardsFromMistakes(userId, wrongQuestions, sessionId, attemptId) {
  const batch = writeBatch(db);
  const createdCards = [];
  
  console.log(`📝 Creating ${wrongQuestions.length} SRS cards for user ${userId}`);
  
  for (const question of wrongQuestions) {
    const questionId = question?.ID;
    if (!questionId) continue;

    const existing = await findAnyCardForQuestion(userId, questionId);
    if (existing) {
      // If a card exists (active or archived), reuse it.
      // Archived/graduated cards are reactivated + reset.
      const next = existing.isActive === false
        ? resetCardForReactivation(existing, {
          topic: question.Topic,
          subtopic: question.Subtopic || null,
          attemptId,
        })
        : {
          ...existing,
          topic: question.Topic ?? existing.topic ?? null,
          subtopic: (question.Subtopic || null) ?? existing.subtopic ?? null,
          updatedAt: getNow().toISOString(),
        };

      batch.set(doc(db, COLLECTIONS.CARDS, existing.id), next);
      createdCards.push(next);

      console.log(`♻️ Reused SRS card: ${existing.id} (review on ${next.nextReviewDate})`);
      continue;
    }

    // No prior card -> create deterministic ID (one card per user+question)
    const card = createNewCard({
      questionId,
      userId,
      topic: question.Topic,
      subtopic: question.Subtopic || null,
      sessionId,
      attemptId
    });
    const deterministicId = `card_${userId}_${questionId}`;
    card.id = deterministicId;
    
    batch.set(doc(db, COLLECTIONS.CARDS, card.id), card);
    createdCards.push(card);
    
    console.log(`✅ Created SRS card: ${card.id} (review on ${card.nextReviewDate})`);
  }
  
  if (createdCards.length > 0) {
    await batch.commit();
    console.log(`🎉 Successfully created ${createdCards.length} SRS cards`);

    // Denormalize onto mistake index (writes only)
    await Promise.all(
      createdCards.map((c) => upsertMistakeSrsMeta(userId, c.questionId, c))
    );
  }
  
  return createdCards;
}

/**
 * Get all cards due for review (JIT query)
 * 
 * @param {string} userId - User ID
 * @param {Date} asOf - Check for cards due as of this date (defaults to today)
 * @param {Object} options - Query options
 * @param {number} options.limit - Max number of due cards to return
 * @returns {Promise<Array>} Due cards
 */
export async function getDueCards(userId, asOf = getNow(), options = {}) {
  const today = formatHKDateKey(asOf);
  const max = Number(options?.limit);
  
  console.log(`🔍 Fetching due cards for ${userId} as of ${today}`);
  
  const queryParts = [
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '<=', today),
    orderBy('nextReviewDate', 'asc')
  ];

  if (Number.isFinite(max) && max > 0) {
    queryParts.push(limit(max));
  }

  const cardsQuery = query(...queryParts);
  
  const snapshot = await getDocs(cardsQuery);
  const dueCards = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  
  console.log(`📊 Found ${dueCards.length} cards due for review`);
  
  return dueCards;
}

/**
 * Get cards due on an exact date (no overdue accumulation)
 *
 * This is useful for calendar scheduling when you only want to create
 * events for "today" (or a specific day) and avoid reading a large backlog.
 *
 * @param {string} userId - User ID
 * @param {string} dateStr - YYYY-MM-DD
 * @param {Object} options - Query options
 * @param {number} options.limit - Max number of cards to return
 * @returns {Promise<Array>} Cards due exactly on dateStr
 */
export async function getCardsDueOnDate(userId, dateStr, options = {}) {
  const max = Number(options?.limit);

  if (!dateStr) {
    throw new Error('getCardsDueOnDate requires dateStr (YYYY-MM-DD)');
  }

  console.log(`🔍 Fetching cards due on ${dateStr} for ${userId}`);

  const queryParts = [
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '==', dateStr),
    orderBy('nextReviewDate', 'asc')
  ];

  if (Number.isFinite(max) && max > 0) {
    queryParts.push(limit(max));
  }

  const cardsQuery = query(...queryParts);
  const snapshot = await getDocs(cardsQuery);
  const cards = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));

  console.log(`📊 Found ${cards.length} cards due on ${dateStr}`);
  return cards;
}

export async function getOverdueCount(userId, asOf = getNow()) {
  const todayStr = formatHKDateKey(asOf);
  const fourteenDaysAgo = new Date(asOf);
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
  const fourteenDaysAgoStr = formatHKDateKey(fourteenDaysAgo);

  const q = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '<', todayStr),
    where('nextReviewDate', '>=', fourteenDaysAgoStr)
  );

  const snap = await getCountFromServer(q);
  return Number(snap.data().count || 0);
}

/**
 * Archive overdue cards older than 14 days (recoverable)
 * 
 * @param {string} userId - User ID
 * @returns {Promise<number>} Number of archived cards
 */
export async function archiveOverdueCards(userId) {
  const today = new Date();
  const fourteenDaysAgo = new Date(today);
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
  const fourteenDaysAgoStr = formatHKDateKey(fourteenDaysAgo);
  
  console.log(`🗄️ Archiving overdue cards older than 14 days for user ${userId}`);
  
  // Find cards overdue by more than 14 days
  const overdueQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true),
    where('nextReviewDate', '<', fourteenDaysAgoStr)
  );
  
  const snapshot = await getDocs(overdueQuery);
  const cardsToArchive = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  
  if (cardsToArchive.length === 0) {
    console.log('✅ No cards to archive');
    return 0;
  }
  
  // Archive cards in batches
  const batchSize = 500;
  let archivedCount = 0;
  
  for (let i = 0; i < cardsToArchive.length; i += batchSize) {
    const batch = writeBatch(db);
    const batchCards = cardsToArchive.slice(i, i + batchSize);
    
    batchCards.forEach(card => {
      const cardRef = doc(db, COLLECTIONS.CARDS, card.id);
      batch.update(cardRef, {
        isActive: false,
        archivedAt: new Date().toISOString(),
        archiveReason: 'overdue_14_days',
        updatedAt: new Date().toISOString()
      });
    });
    
    await batch.commit();
    archivedCount += batchCards.length;
    console.log(`📦 Archived batch of ${batchCards.length} cards`);

    // Best-effort denormalization
    await Promise.all(
      batchCards.map((c) => upsertMistakeSrsMeta(userId, c.questionId, { ...c, isActive: false }))
    );
  }
  
  console.log(`🎉 Successfully archived ${archivedCount} overdue cards`);
  return archivedCount;
}

/**
 * Get archived cards for a user
 * 
 * @param {string} userId - User ID
 * @param {Object} options - Query options
 * @param {string} options.reason - Filter by archive reason
 * @param {number} options.limit - Max number of cards to return
 * @returns {Promise<Array>} Archived cards
 */
export async function getArchivedCards(userId, options = {}) {
  const { reason, limit } = options;
  
  const queryParts = [
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', false)
  ];
  
  if (reason) {
    queryParts.push(where('archiveReason', '==', reason));
  }
  
  queryParts.push(orderBy('archivedAt', 'desc'));
  
  if (Number.isFinite(limit) && limit > 0) {
    queryParts.push(limit(limit));
  }
  
  const cardsQuery = query(...queryParts);
  const snapshot = await getDocs(cardsQuery);
  
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * Restore an archived card
 * 
 * @param {string} cardId - Card ID
 * @returns {Promise<Object>} Restored card
 */
export async function restoreArchivedCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  
  await updateDoc(cardRef, {
    isActive: true,
    archivedAt: null,
    archiveReason: null,
    updatedAt: new Date().toISOString()
  });
  
  const updatedCard = await getCard(cardId);
  console.log(`♻️ Restored archived card: ${cardId}`);

  try {
    if (updatedCard) {
      await upsertMistakeSrsMeta(updatedCard.userId, updatedCard.questionId, updatedCard);
    }
  } catch (e) {
    console.error('⚠️ Failed to update mistake SRS meta on restore:', e);
  }
  
  return updatedCard;
}
/**
 * Save a single card (for debugging)
 * 
 * @param {Object} card - Card data
 * @returns {Promise<Object>} Saved card
 */
export async function saveCard(card) {
  const cardRef = doc(db, COLLECTIONS.CARDS, card.id);
  await setDoc(cardRef, card);
  return { id: card.id, ...card };
}

/**
 * Delete a card (for debugging)
 * 
 * @param {string} cardId - Card ID
 * @returns {Promise<void>}
 */
export async function deleteCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  await deleteDoc(cardRef);
}

/**
 * Get all SRS cards for a user
 */
export async function getAllCards(userId) {
  const cardsQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId)
  );

  const snapshot = await getDocs(cardsQuery);
  return snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
}

export async function getActiveCards(userId, options = {}) {
  const max = Number(options?.limit);

  if (!userId) return [];

  // Index-safe: avoid requiring a composite index on (userId, isActive).
  // We'll query by userId only and filter isActive client-side.
  const queryParts = [collection(db, COLLECTIONS.CARDS), where('userId', '==', userId)];
  if (Number.isFinite(max) && max > 0) queryParts.push(limit(max));

  const q = query(...queryParts);
  const snap = await getDocs(q);
  return snap.docs
    .map((d) => ({ id: d.id, ...d.data() }))
    .filter((c) => c?.isActive === true);
}

export async function getCardsByQuestionIds(userId, questionIds = []) {
  const ids = (Array.isArray(questionIds) ? questionIds : [])
    .map((x) => String(x))
    .filter(Boolean);

  if (!userId || ids.length === 0) return [];

  const chunkSize = 10;
  const results = [];

  for (let i = 0; i < ids.length; i += chunkSize) {
    const chunk = ids.slice(i, i + chunkSize);
    const q = query(
      collection(db, COLLECTIONS.CARDS),
      where('userId', '==', userId),
      where('questionId', 'in', chunk)
    );

    const snap = await getDocs(q);
    snap.docs.forEach((d) => results.push({ id: d.id, ...d.data() }));
  }

  return results;
}

/**
 * Get recent review attempts for analytics
 */
export async function getRecentReviewAttempts(userId, days = 30) {
  const since = new Date();
  since.setDate(since.getDate() - days);

  const attemptsQuery = query(
    collection(db, COLLECTIONS.ATTEMPTS),
    where('userId', '==', userId)
  );

  const snapshot = await getDocs(attemptsQuery);

  const sinceIso = since.toISOString();
  return snapshot.docs
    .map(docSnap => ({ id: docSnap.id, ...docSnap.data() }))
    .filter((a) => {
      const attemptedAt = a?.attemptedAt;
      if (!attemptedAt || typeof attemptedAt !== 'string') return false;
      return attemptedAt >= sinceIso;
    })
    .sort((a, b) => String(a?.attemptedAt || '').localeCompare(String(b?.attemptedAt || '')));
}

/**
 * Get specific card by ID
 * 
 * @param {string} cardId - Card ID
 * @returns {Promise<Object|null>} Card or null
 */
export async function getCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  const cardSnap = await getDoc(cardRef);
  
  if (!cardSnap.exists()) {
    return null;
  }
  
  return { id: cardSnap.id, ...cardSnap.data() };
}

/**
 * Submit a review attempt (CORE SRS FUNCTION)
 * 
 * This is where the magic happens:
 * 1. Records the attempt
 * 2. Updates card state based on result
 * 3. Calculates ONLY the next single review date
 * 
 * @param {string} cardId - Card ID
 * @param {boolean} wasCorrect - Did user answer correctly?
 * @param {Object} attemptData - Additional attempt data
 * @returns {Promise<Object>} Updated card and attempt record
 */
export async function submitReview(cardId, wasCorrect, attemptData = {}) {
  console.log(`📝 Processing review: ${cardId}, correct: ${wasCorrect}`);
  
  // 1. Get current card state
  const card = await getCard(cardId);
  if (!card) {
    throw new Error(`Card not found: ${cardId}`);
  }
  
  // 2. Create attempt record (for audit trail)
  const attemptId = `attempt_${cardId}_${Date.now()}`;
  const attempt = {
    id: attemptId,
    cardId,
    userId: card.userId,
    questionId: card.questionId,
    
    // Attempt details
    attemptNumber: (card.currentAttemptNumber || 0) + 1,
    wasCorrect,
    userAnswer: attemptData.userAnswer || null,
    correctAnswer: attemptData.correctAnswer || null,
    
    // Timing
    timeSpent: attemptData.timeSpent || null,
    attemptedAt: new Date().toISOString(),
    
    // State before attempt (audit)
    stateBefore: {
      interval: card.interval,
      easeFactor: card.easeFactor,
      repetitionCount: card.repetitionCount,
      status: card.status
    },
    
    // Review session
    reviewSessionId: attemptData.reviewSessionId || null,
    
    // Audit
    createdAt: new Date().toISOString()
  };
  
  // 3. Calculate new card state
  const updatedCard = updateCardAfterReview(card, wasCorrect);
  
  // Add state after to attempt record
  attempt.stateAfter = {
    interval: updatedCard.interval,
    easeFactor: updatedCard.easeFactor,
    repetitionCount: updatedCard.repetitionCount,
    status: updatedCard.status
  };
  
  // 4. Save both records in a batch
  const batch = writeBatch(db);
  
  // Save attempt
  batch.set(doc(db, COLLECTIONS.ATTEMPTS, attemptId), attempt);
  
  // Update card
  batch.set(doc(db, COLLECTIONS.CARDS, cardId), updatedCard);
  
  await batch.commit();
  
  console.log(`✅ Review processed successfully:`, {
    cardId,
    wasCorrect,
    nextReview: updatedCard.nextReviewDate,
    newInterval: updatedCard.interval,
    newStatus: updatedCard.status
  });
  
  // 5. Archive if graduated
  if (shouldArchiveCard(updatedCard)) {
    console.log(`🎓 Card graduated! Archiving: ${cardId}`);
    await archiveCard(cardId);
  }

  // Denormalize onto mistake index
  try {
    const fresh = shouldArchiveCard(updatedCard)
      ? { ...updatedCard, isActive: false }
      : updatedCard;
    await upsertMistakeSrsMeta(fresh.userId, fresh.questionId, fresh);
  } catch (e) {
    console.error('⚠️ Failed to update mistake SRS meta:', e);
  }
  
  return {
    card: updatedCard,
    attempt
  };
}

/**
 * Submit multiple reviews in one session
 * 
 * @param {string} userId - User ID
 * @param {Array} reviews - Array of {cardId, wasCorrect, userAnswer}
 * @param {string} sessionType - Session type identifier
 * @returns {Promise<Object>} Session summary
 */
export async function submitReviewSession(userId, reviews, sessionType = 'spaced_repetition') {
  const sessionId = `review_session_${Date.now()}`;
  const startTime = new Date();
  
  console.log(`🎯 Starting review session: ${sessionId} with ${reviews.length} cards`);
  
  let cardsCorrect = 0;
  let cardsFailed = 0;
  const results = [];
  
  // Process each review
  for (const review of reviews) {
    try {
      const result = await submitReview(review.cardId, review.wasCorrect, {
        userAnswer: review.userAnswer,
        correctAnswer: review.correctAnswer,
        timeSpent: review.timeSpent,
        reviewSessionId: sessionId
      });
      
      results.push(result);
      
      if (review.wasCorrect) {
        cardsCorrect++;
      } else {
        cardsFailed++;
      }
    } catch (error) {
      console.error(`❌ Error processing review for card ${review.cardId}:`, error);
      cardsFailed++;
    }
  }
  
  const endTime = new Date();
  const totalTimeSpent = Math.floor((endTime - startTime) / 1000);
  
  // Create session record
  const session = {
    id: sessionId,
    userId,
    
    // Stats
    cardsReviewed: reviews.length,
    cardsCorrect,
    cardsFailed,
    totalTimeSpent,
    
    // Metadata
    sessionType,
    startedAt: startTime.toISOString(),
    completedAt: endTime.toISOString(),
    
    // Audit
    createdAt: new Date().toISOString()
  };
  
  // Save session
  await setDoc(doc(db, COLLECTIONS.SESSIONS, sessionId), session);
  
  console.log(`✅ Review session completed:`, session);
  
  return {
    session,
    results
  };
}

/**
 * Archive a graduated card
 * 
 * @param {string} cardId - Card ID
 */
async function archiveCard(cardId) {
  const cardRef = doc(db, COLLECTIONS.CARDS, cardId);
  await updateDoc(cardRef, {
    isActive: false,
    archivedAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  });
}

/**
 * Get review statistics for a user
 * 
 * @param {string} userId - User ID
 * @returns {Promise<Object>} Statistics
 */
export async function getReviewStats(userId) {
  // Get all cards
  const cardsQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId)
  );
  
  const cardsSnapshot = await getDocs(cardsQuery);
  const cards = cardsSnapshot.docs.map(doc => doc.data());
  
  const stats = {
    total: cards.length,
    active: cards.filter(c => c.isActive).length,
    archived: cards.filter(c => !c.isActive).length,
    
    // By status
    new: cards.filter(c => c.status === SRS_CONFIG.STATUS.NEW).length,
    learning: cards.filter(c => c.status === SRS_CONFIG.STATUS.LEARNING).length,
    review: cards.filter(c => c.status === SRS_CONFIG.STATUS.REVIEW).length,
    graduated: cards.filter(c => c.status === SRS_CONFIG.STATUS.GRADUATED).length,
    
    // Due today
    dueToday: cards.filter(c => c.isActive && c.isDue).length,
    
    // Performance
    totalAttempts: cards.reduce((sum, c) => sum + (c.totalAttempts || 0), 0),
    successRate: calculateSuccessRate(cards)
  };
  
  return stats;
}

function calculateSuccessRate(cards) {
  const totalAttempts = cards.reduce((sum, c) => sum + (c.totalAttempts || 0), 0);
  const successfulAttempts = cards.reduce((sum, c) => sum + (c.successfulAttempts || 0), 0);
  
  if (totalAttempts === 0) return 0;
  return Math.round((successfulAttempts / totalAttempts) * 100);
}

/**
 * Update isDue flags for all cards (run daily)
 * 
 * @param {string} userId - User ID
 */
export async function updateDueFlags(userId) {
  const today = new Date().toISOString().split('T')[0];
  
  const cardsQuery = query(
    collection(db, COLLECTIONS.CARDS),
    where('userId', '==', userId),
    where('isActive', '==', true)
  );
  
  const snapshot = await getDocs(cardsQuery);
  const batch = writeBatch(db);
  
  snapshot.docs.forEach(docSnap => {
    const card = docSnap.data();
    const isDue = isCardDue(card.nextReviewDate, new Date(today));
    
    if (card.isDue !== isDue) {
      batch.update(docSnap.ref, { isDue });
    }
  });
  
  await batch.commit();
}

export const srsService = {
  createCardsFromMistakes,
  getAllCards,
  getActiveCards,
  getCardsByQuestionIds,
  getRecentReviewAttempts,
  getDueCards,
  getCardsDueOnDate,
  getOverdueCount,
  getCard,
  submitReview,
  submitReviewSession,
  getReviewStats,
  updateDueFlags,
  archiveOverdueCards,
  getArchivedCards,
  restoreArchivedCard,
  saveCard,
  deleteCard
};

export default srsService;

========================================================================================================================
FILE: src/services/calendarServiceSRS.js
------------------------------------------------------------------------------------------------------------------------
/**
 * Calendar Service - SRS Integration
 * 
 * This module provides the missing link between SRS system and calendar
 * Creates calendar events based on SRS due cards and algorithm scheduling
 */

import { db } from '../firebase/config';
import { 
  collection,
  doc,
  setDoc,
  getDocs,
  query,
  where,
  writeBatch
} from 'firebase/firestore';
import { srsService } from './srsService';
import { getNow } from '../utils/timeTravel';
import { calendarServiceOptimized } from './calendarServiceOptimized';

export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  SPACED_REPETITION: 'spaced_repetition',
  AI_RECOMMENDATION: 'ai_recommendation',
  COMPLETION: 'completion'
};

/**
 * Create spaced repetition calendar event based on SRS card
 * 
 * @param {string} userId - User ID
 * @param {Object} cardData - SRS card data
 * @returns {Promise<Object>} Created calendar event
 */
export async function createSpacedRepetitionEvent(userId, cardData) {
  try {
    const eventId = `srs_${cardData.id}_${Date.now()}`;
    
    const calendarEvent = {
      id: eventId,
      userId,
      type: EVENT_TYPES.SPACED_REPETITION,
      date: cardData.nextReviewDate,
      title: `SRS Review: ${cardData.subtopic || cardData.topic}`,
      description: `Spaced repetition review for ${cardData.topic}`,
      topic: cardData.topic,
      subtopic: cardData.subtopic,
      questionId: cardData.questionId,
      srsCardId: cardData.id,
      difficulty: cardData.difficulty,
      interval: cardData.interval,
      easeFactor: cardData.easeFactor,
      reviewCount: cardData.reviewCount,
      priority: getPriorityFromDifficulty(cardData.difficulty),
      completed: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    console.log('🧠 Creating SRS calendar event:', calendarEvent);

    // Save to user's calendar subcollection
    await setDoc(
      doc(db, 'users', userId, 'calendar_events', eventId),
      calendarEvent
    );

    return calendarEvent;
  } catch (error) {
    console.error('❌ Error creating SRS calendar event:', error);
    throw error;
  }
}

/**
 * Schedule spaced repetition events for due cards
 * This creates calendar events for all SRS cards that are due
 * 
 * @param {string} userId - User ID
 * @param {Object} options - Scheduling options
 * @returns {Promise<Object>} Scheduling results
 */
export async function scheduleSpacedRepetition(userId, options = {}) {
  try {
    console.log('🧠 Scheduling SRS events for user:', userId);
    
    // Schedule only cards due exactly today (avoid scheduling a large overdue backlog)
    const todayStr = getNow().toISOString().split('T')[0];
    const dueCards = await srsService.getCardsDueOnDate(userId, todayStr);
    
    if (dueCards.length === 0) {
      console.log('✅ No due SRS cards found');
      return { scheduled: 0, events: [], message: 'No due cards found' };
    }

    console.log(`📊 Found ${dueCards.length} SRS cards due today (${todayStr})`);

    // Create calendar events for due cards
    const batch = writeBatch(db);
    const events = [];
    
    for (const card of dueCards) {
      // Deterministic ID to prevent duplicates for the same card+date
      const eventId = `srs_${card.id}_${card.nextReviewDate}`;
      
      const calendarEvent = {
        id: eventId,
        userId,
        type: EVENT_TYPES.SPACED_REPETITION,
        date: card.nextReviewDate,
        title: `SRS Review: ${card.subtopic || card.topic}`,
        description: `Spaced repetition review (Interval: ${card.interval} days)`,
        topic: card.topic,
        subtopic: card.subtopic,
        questionId: card.questionId,
        srsCardId: card.id,
        difficulty: card.difficulty ?? null,
        interval: card.interval,
        easeFactor: card.easeFactor,
        reviewCount: card.repetitionCount ?? 0,
        priority: getPriorityFromDifficulty(card.difficulty),
        completed: false,
        createdAt: getNow().toISOString(),
        updatedAt: getNow().toISOString()
      };

      // Add to batch
      const eventRef = doc(db, 'users', userId, 'calendar_events', eventId);
      batch.set(eventRef, calendarEvent, { merge: true });
      events.push(calendarEvent);
    }

    // Commit all events at once
    await batch.commit();
    
    console.log(`✅ Created ${events.length} SRS calendar events`);
    
    return {
      scheduled: events.length,
      events,
      message: `Scheduled ${events.length} SRS reviews`
    };
    
  } catch (error) {
    console.error('❌ Error scheduling SRS events:', error);
    throw error;
  }
}

/**
 * Schedule SRS events for specific questions (from mistakes)
 * 
 * @param {string} userId - User ID
 * @param {Object} params - Question parameters
 * @returns {Promise<Object>} Scheduling results
 */
export async function scheduleSpacedRepetitionForQuestions(userId, params) {
  try {
    const { questionId, topic, subtopic, attemptCount } = params;
    
    console.log('🧠 Creating SRS schedule for question:', { questionId, topic, subtopic });
    
    // First, create SRS cards if they don't exist
    const wrongQuestions = [{
      ID: questionId,
      Topic: topic,
      Subtopic: subtopic,
      attemptCount: attemptCount || 1
    }];
    
    // Create SRS cards from mistakes
    const cards = await srsService.createCardsFromMistakes(
      userId, 
      wrongQuestions, 
      `manual_${Date.now()}`, 
      `manual_attempt_${Date.now()}`
    );
    
    console.log(`📝 Created ${cards.length} SRS cards`);
    
    // Schedule the first review for these cards
    const scheduleResult = await scheduleSpacedRepetition(userId);
    
    return {
      cardsCreated: cards.length,
      ...scheduleResult
    };
    
  } catch (error) {
    console.error('❌ Error scheduling SRS for questions:', error);
    throw error;
  }
}

/**
 * Mark SRS calendar event as completed and update the SRS card
 * 
 * @param {string} userId - User ID
 * @param {string} eventId - Calendar event ID
 * @param {boolean} wasCorrect - Was the review completed correctly?
 * @param {Object} completionData - Additional completion data
 * @returns {Promise<Object>} Updated card and event
 */
export async function completeSpacedRepetitionEvent(userId, eventId, wasCorrect, completionData = {}) {
  try {
    console.log('🧠 Completing SRS event:', eventId, 'correct:', wasCorrect);
    
    // Get the calendar event
    const eventRef = doc(db, 'users', userId, 'calendar_events', eventId);
    const eventSnap = await getDoc(eventRef);
    
    if (!eventSnap.exists()) {
      throw new Error('SRS calendar event not found');
    }
    
    const eventData = eventSnap.data();
    
    // Update the SRS card
    if (eventData.srsCardId) {
      await srsService.submitReview(eventData.srsCardId, wasCorrect, {
        completedAt: new Date().toISOString(),
        calendarEventId: eventId,
        ...completionData
      });
    }
    
    // Mark calendar event as completed
    await calendarServiceOptimized.markEventCompleted(userId, eventId, {
      wasCorrect,
      completedAt: new Date().toISOString(),
      ...completionData
    });
    
    // Schedule next review if this was a correct review
    if (wasCorrect && eventData.srsCardId) {
      const updatedCard = await srsService.getCard(eventData.srsCardId);
      if (updatedCard && updatedCard.isActive) {
        await createSpacedRepetitionEvent(userId, updatedCard);
        console.log('📅 Scheduled next SRS review');
      }
    }
    
    return {
      eventCompleted: true,
      cardUpdated: !!eventData.srsCardId,
      nextScheduled: wasCorrect
    };
    
  } catch (error) {
    console.error('❌ Error completing SRS event:', error);
    throw error;
  }
}

/**
 * Get SRS events for a specific date range
 * 
 * @param {string} userId - User ID
 * @param {string} startDate - Start date (YYYY-MM-DD)
 * @param {string} endDate - End date (YYYY-MM-DD)
 * @returns {Promise<Array>} SRS calendar events
 */
export async function getSRSEvents(userId, startDate, endDate) {
  try {
    const eventsQuery = query(
      collection(db, 'users', userId, 'calendar_events'),
      where('date', '>=', startDate),
      where('date', '<=', endDate)
    );
    
    const snapshot = await getDocs(eventsQuery);
    return snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() }))
      .filter((e) => e?.type === EVENT_TYPES.SPACED_REPETITION);
    
  } catch (error) {
    console.error('❌ Error getting SRS events:', error);
    return [];
  }
}

/**
 * Clean up old SRS events that are no longer relevant
 * This removes SRS events for cards that are archived or have newer events
 * 
 * @param {string} userId - User ID
 * @returns {Promise<Object>} Cleanup results
 */
export async function cleanupOldSRSEvents(userId) {
  try {
    console.log('🧹 Cleaning up old SRS events for user:', userId);
    
    // Get all SRS events
    const allEventsQuery = query(
      collection(db, 'users', userId, 'calendar_events')
    );
    
    const snapshot = await getDocs(allEventsQuery);
    const events = snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() }))
      .filter((e) => e?.type === EVENT_TYPES.SPACED_REPETITION);
    
    // Group events by SRS card ID
    const eventsByCard = {};
    events.forEach(event => {
      if (event.srsCardId) {
        if (!eventsByCard[event.srsCardId]) {
          eventsByCard[event.srsCardId] = [];
        }
        eventsByCard[event.srsCardId].push(event);
      }
    });
    
    // Find outdated events to delete
    const toDelete = [];
    const toKeep = [];
    
    for (const [cardId, cardEvents] of Object.entries(eventsByCard)) {
      // Sort by date (newest first)
      cardEvents.sort((a, b) => new Date(b.date) - new Date(a.date));
      
      // Keep the newest event, mark others for deletion
      const newest = cardEvents.shift();
      toKeep.push(newest);
      toDelete.push(...cardEvents);
    }
    
    // Delete old events
    if (toDelete.length > 0) {
      const batch = writeBatch(db);
      toDelete.forEach(event => {
        const eventRef = doc(db, 'users', userId, 'calendar_events', event.id);
        batch.delete(eventRef);
      });
      await batch.commit();
    }
    
    console.log(`🧹 Cleaned up ${toDelete.length} old SRS events, kept ${toKeep.length}`);
    
    return {
      deleted: toDelete.length,
      kept: toKeep.length,
      total: events.length
    };
    
  } catch (error) {
    console.error('❌ Error cleaning up SRS events:', error);
    return { deleted: 0, kept: 0, total: 0, error: error.message };
  }
}

/**
 * Get priority level based on SRS difficulty
 */
function getPriorityFromDifficulty(difficulty) {
  switch (difficulty?.toLowerCase()) {
    case 'hard': return 'high';
    case 'medium': return 'medium';
    case 'easy': return 'low';
    default: return 'medium';
  }
}

/**
 * Update the main calendar service to include SRS functions
 */
export const calendarServiceSRS = {
  ...calendarServiceOptimized,
  scheduleSpacedRepetition,
  createSpacedRepetitionEvent,
  completeSpacedRepetitionEvent,
  getSRSEvents,
  cleanupOldSRSEvents,
  scheduleSpacedRepetitionForQuestions
};

export default calendarServiceSRS;

========================================================================================================================
FILE: src/utils/masteryHelper.js
------------------------------------------------------------------------------------------------------------------------
/**
 * Mastery Helper Utilities
 * Includes ISRS priority algorithm and Rule of 3 mastery calculations
 */

/**
 * Calculate multi-weighted ISRS (Integrated Spaced Repetition System) priority score
 * Score = (U × 0.4) + (D × 0.4) + (R × 0.2)
 * where U = Urgency (Ebbinghaus curve), D = Difficulty, R = Recency/Context boost
 */
export function calculateMasteryPriority(mistake, recentTopics = []) {
  // 1. URGENCY: Ebbinghaus Forgetting Curve
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));

  // U = 2^(days/7) exponential curve
  const U = Math.pow(2, daysSinceLastAttempt / 7);

  // 2. DIFFICULTY: Based on attempt count (max 1.0 at 3+ attempts)
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);

  // 3. RECENCY/CONTEXT: Boost if matches recent quiz topics
  let R = 0.5; // Baseline
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5; // 1.5x boost for contextual relevance
  }

  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

/**
 * Get mastery state based on Rule of 3 (3 correct answers)
 */
export function getMasteryState(correctCount = 0) {
  if (correctCount >= 3) {
    return { state: 3, label: 'Mastered', color: 'green', bgClass: 'bg-green-50/60', borderClass: 'border-green-300', badgeClass: 'bg-green-100 text-green-700', dotClass: 'bg-green-500' };
  }
  if (correctCount === 2) {
    return { state: 2, label: 'Consolidating', color: 'amber', bgClass: 'bg-amber-50/60', borderClass: 'border-amber-300', badgeClass: 'bg-amber-100 text-amber-700', dotClass: 'bg-amber-400' };
  }
  if (correctCount === 1) {
    return { state: 1, label: 'Improving', color: 'amber', bgClass: 'bg-amber-50/60', borderClass: 'border-amber-300', badgeClass: 'bg-amber-100 text-amber-700', dotClass: 'bg-amber-400' };
  }
  return { state: 0, label: 'New', color: 'red', bgClass: 'bg-white', borderClass: 'border-red-200', badgeClass: 'bg-red-100 text-red-700', dotClass: 'bg-red-500' };
}

/**
 * Load mistakes from localStorage (from MistakeNotebookPage format)
 */
export function loadMistakesFromStorage() {
  try {
    const improvements = JSON.parse(localStorage.getItem('mistake_improvements') || '{}');
    const mistakes = [];

    Object.entries(improvements).forEach(([questionId, data]) => {
      mistakes.push({
        questionId,
        Topic: data.Topic || 'Unknown',
        Question: data.Question || '',
        lastAttempted: data.lastAttempted || new Date().toISOString(),
        attemptCount: data.attemptCount || 0,
        correctCount: data.correctCount || 0,
        lastCorrect: data.lastCorrect || null,
        errorType: data.errorType || 'conceptual', ...data
      });
    });

    return mistakes;
  } catch (error) {
    console.error('Error loading mistakes:', error);
    return [];
  }
}

/**
 * Calculate mastery statistics across all topics
 */
export function calculateMasteryStats(userProfile, mistakes = []) {
  const stats = {
    unseenCount: 0,
    inProgressCount: 0,
    masteredCount: 0,
    totalTopicsMastered: 0,
    topicStats: {},
  };

  // Collect all mistakes by topic
  mistakes.forEach((mistake) => {
    const topic = mistake.Topic || 'Unknown';
    if (!stats.topicStats[topic]) {
      stats.topicStats[topic] = { unseen: 0, inProgress: 0, mastered: 0 };
    }

    const state = getMasteryState(mistake.correctCount);
    if (state.state === 3) {
      stats.masteredCount++;
      stats.topicStats[topic].mastered++;
    } else if (state.state > 0) {
      stats.inProgressCount++;
      stats.topicStats[topic].inProgress++;
    } else {
      stats.unseenCount++;
      stats.topicStats[topic].unseen++;
    }
  });

  // Count topics with mastery
  stats.totalTopicsMastered = Object.values(stats.topicStats).filter(
    (topic) => topic.mastered > 0 && topic.inProgress === 0 && topic.unseen === 0
  ).length;

  return stats;
}

/**
 * Get top N mistakes by ISRS priority score
 */
export function getTopMistakesByPriority(mistakes, recentTopics = [], limit = 3) {
  return mistakes
    .map((m) => ({
      ...m,
      masteryPriority: calculateMasteryPriority(m, recentTopics),
    }))
    .sort((a, b) => b.masteryPriority - a.masteryPriority)
    .slice(0, limit);
}

/**
 * Find the closest topic to mastery
 */
export function findClosestToMastery(mistakes) {
  const topicProgress = {};

  mistakes.forEach((m) => {
    const topic = m.Topic || 'Unknown';
    if (!topicProgress[topic]) {
      topicProgress[topic] = { mastered: 0, total: 0 };
    }
    topicProgress[topic].total++;
    if (getMasteryState(m.correctCount).state === 3) {
      topicProgress[topic].mastered++;
    }
  });

  let closest = null;
  let maxProgress = -1;

  Object.entries(topicProgress).forEach(([topic, data]) => {
    if (data.total > 0) {
      const progress = data.mastered / data.total;
      const questionsUntilMastery = Math.max(0, Math.ceil((data.total - data.mastered) * 3));
      if (progress > maxProgress && progress < 1.0) {
        maxProgress = progress;
        closest = { topic, ...data, questionsUntilMastery };
      }
    }
  });

  return closest;
}

========================================================================================================================
FILE: src/utils/calendarEventManager.js
------------------------------------------------------------------------------------------------------------------------
/**
 * Calendar Event Manager (Merged)
 * Combines user-specific storage with spaced repetition and event management
 */

import { auth } from '../firebase/config';
import { formatHKDateKey } from './hkTime';

// Event Types
export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  MISTAKE_REVIEW: 'mistake_review',
  COMPLETED_ACTIVITY: 'completed_activity',
};

// Event Icons
export const EVENT_ICONS = {
  [EVENT_TYPES.MAJOR_EXAM]: '🚩',
  [EVENT_TYPES.SMALL_QUIZ]: '✏️',
  [EVENT_TYPES.STUDY_SUGGESTION]: '💡',
  [EVENT_TYPES.MISTAKE_REVIEW]: '🧠',
  [EVENT_TYPES.COMPLETED_ACTIVITY]: '✅',
};

/**
 * Get user-specific storage key (Firebase auth aware)
 */
function getUserStorageKey(suffix) {
  const user = auth.currentUser;
  if (!user) return `studyCalendar_guest_${suffix}`;
  return `studyCalendar_${user.uid}_${suffix}`;
}

/**
 * Load calendar data from localStorage (user-specific)
 */
export function loadCalendarData() {
  try {
    const data = localStorage.getItem(getUserStorageKey('data'));
    return data ? JSON.parse(data) : { events: [], completedSessions: {} };
  } catch (error) {
    console.error('Error loading calendar data:', error);
    return { events: [], completedSessions: {} };
  }
}

/**
 * Save calendar data to localStorage (user-specific)
 */
export function saveCalendarData(data) {
  try {
    localStorage.setItem(getUserStorageKey('data'), JSON.stringify(data));
    // Trigger storage event for cross-component updates
    window.dispatchEvent(new Event('calendar-update'));
  } catch (error) {
    console.error('Error saving calendar data:', error);
  }
}

/**
 * Get all calendar events
 */
export function getCalendarEvents() {
  const data = loadCalendarData();
  return data.events || [];
}

/**
 * Save calendar events
 */
export function saveCalendarEvents(events) {
  const data = loadCalendarData();
  data.events = events;
  saveCalendarData(data);
}

/**
 * Calculate spaced repetition interval based on mistake improvement count
 * Uses SM-2 inspired algorithm with mistake-specific adjustments
 */
export function calculateSpacedRepetitionDate(mistake) {
  const now = new Date();
  const improvementCount = mistake.improvementCount || 0;
  
  // Spaced repetition intervals (in days)
  const intervals = {
    0: 1,   // First review: next day
    1: 3,   // Second review: 3 days later
    2: 7,   // Third review: 1 week later
    3: 14,  // Mastered but reinforce: 2 weeks
  };
  
  const daysToAdd = intervals[improvementCount] || 14;
  const reviewDate = new Date(now);
  reviewDate.setDate(reviewDate.getDate() + daysToAdd);
  
  return formatHKDateKey(reviewDate);
}

/**
 * Generate study suggestions based on exam date and topic
 * Returns array of suggestion events with scaled MCQ counts
 */
export function generateExamPrepSuggestions(examDate, topic, subtopic = null) {
  const exam = new Date(examDate);
  const suggestions = [];
  
  // Major Exam Scaling Algorithm
  const prepSchedule = [
    { daysBeforeStart: 10, daysBeforeEnd: 7, mcqCount: 10, phase: 'Warm-up' },
    { daysBeforeStart: 6, daysBeforeEnd: 4, mcqCount: 20, phase: 'Consolidation' },
    { daysBeforeStart: 3, daysBeforeEnd: 1, mcqCount: 40, phase: 'Sprint' },
  ];
  
  prepSchedule.forEach(({ daysBeforeStart, daysBeforeEnd, mcqCount, phase }) => {
    for (let day = daysBeforeStart; day >= daysBeforeEnd; day--) {
      const suggestionDate = new Date(exam);
      suggestionDate.setDate(suggestionDate.getDate() - day);
      
      suggestions.push({
        id: `prep_${topic}_${day}`,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: formatHKDateKey(suggestionDate),
        title: `${phase} - ${mcqCount} MCQs`,
        description: `Practice ${mcqCount} questions on ${topic}`,
        topic,
        subtopic,
        mcqCount,
        phase,
        linkedExamId: examDate,
      });
    }
  });
  
  return suggestions;
}

/**
 * Generate quiz prep suggestions (smaller scale)
 */
export function generateQuizPrepSuggestions(quizDate, topic, subtopic) {
  const quiz = new Date(quizDate);
  const suggestions = [];
  
  // Small Quiz: 3-1 days before with 5-15 MCQs on subtopic
  for (let day = 3; day >= 1; day--) {
    const suggestionDate = new Date(quiz);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    const mcqCount = day === 1 ? 15 : (day === 2 ? 10 : 5);
    
    suggestions.push({
      id: `quiz_prep_${subtopic}_${day}`,
      type: EVENT_TYPES.STUDY_SUGGESTION,
      date: formatHKDateKey(suggestionDate),
      title: `Quiz Prep - ${mcqCount} MCQs`,
      description: `Review ${mcqCount} questions on ${subtopic}`,
      topic,
      subtopic,
      mcqCount,
      linkedQuizId: quizDate,
    });
  }
  
  return suggestions;
}

/**
 * Add a new event (exam or quiz)
 */
export function addCalendarEvent(event) {
  const events = getCalendarEvents();
  
  // Add the main event
  events.push({
    ...event,
    id: event.id || `${event.type}_${Date.now()}`,
    createdAt: new Date().toISOString(),
  });
  
  // Generate prep suggestions if it's an exam or quiz
  if (event.type === EVENT_TYPES.MAJOR_EXAM) {
    const suggestions = generateExamPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
    const suggestions = generateQuizPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Delete an event and its associated suggestions
 */
export function deleteCalendarEvent(eventId) {
  const events = getCalendarEvents();
  const filtered = events.filter(e => 
    e.id !== eventId && 
    e.linkedExamId !== eventId && 
    e.linkedQuizId !== eventId
  );
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Mark event as completed
 */
export function completeCalendarEvent(eventId, completedData = {}) {
  const events = getCalendarEvents();
  const event = events.find(e => e.id === eventId);
  
  if (event) {
    // Mark original as completed
    event.completed = true;
    event.completedAt = new Date().toISOString();
    event.completedData = completedData;
    
    // Add completion badge
    events.push({
      id: `completed_${eventId}`,
      type: EVENT_TYPES.COMPLETED_ACTIVITY,
      date: event.date,
      title: `✅ ${event.title}`,
      description: `Completed: ${event.description}`,
      parentEventId: eventId,
    });
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Schedule mistake review based on spaced repetition
 */
export function scheduleMistakeReview(mistake) {
  const events = getCalendarEvents();
  const reviewDate = calculateSpacedRepetitionDate(mistake);
  
  // Remove old review for this mistake
  const filtered = events.filter(e => 
    !(e.type === EVENT_TYPES.MISTAKE_REVIEW && e.mistakeId === mistake.ID)
  );
  
  // Add new review
  filtered.push({
    id: `review_${mistake.ID}_${Date.now()}`,
    type: EVENT_TYPES.MISTAKE_REVIEW,
    date: reviewDate,
    title: `Review Mistake`,
    description: `${mistake.Topic} → ${mistake.Subtopic}`,
    topic: mistake.Topic,
    subtopic: mistake.Subtopic,
    mistakeId: mistake.ID,
    improvementCount: mistake.improvementCount || 0,
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Batch schedule mistake reviews for all active mistakes
 */
export function batchScheduleMistakeReviews(mistakes) {
  const events = getCalendarEvents();
  
  // Remove all existing mistake reviews
  const filtered = events.filter(e => e.type !== EVENT_TYPES.MISTAKE_REVIEW);
  
  // Add new reviews for all mistakes
  mistakes.forEach(mistake => {
    const reviewDate = calculateSpacedRepetitionDate(mistake);
    
    filtered.push({
      id: `review_${mistake.ID}_${Date.now()}`,
      type: EVENT_TYPES.MISTAKE_REVIEW,
      date: reviewDate,
      title: `Review Mistake`,
      description: `${mistake.Topic}${mistake.Subtopic ? ` → ${mistake.Subtopic}` : ''}`,
      topic: mistake.Topic,
      subtopic: mistake.Subtopic,
      mistakeId: mistake.ID,
      improvementCount: mistake.improvementCount || 0,
    });
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Get events for a specific date
 */
export function getEventsForDate(dateStr) {
  const events = getCalendarEvents();
  return events.filter(e => e.date === dateStr && !e.completed);
}

/**
 * Get events for a date range
 */
export function getEventsForDateRange(startDate, endDate) {
  const events = getCalendarEvents();
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  return events.filter(e => {
    const eventDate = new Date(e.date);
    return eventDate >= start && eventDate <= end && !e.completed;
  });
}

/**
 * Get events in range (alias for compatibility)
 */
export function getEventsInRange(startDate, endDate) {
  return getEventsForDateRange(startDate, endDate);
}

/**
 * Get upcoming events (next 7 days)
 */
export function getUpcomingEvents(days = 7) {
  const today = new Date();
  const future = new Date();
  future.setDate(future.getDate() + days);
  
  return getEventsForDateRange(
    formatHKDateKey(today),
    formatHKDateKey(future)
  ).sort((a, b) => new Date(a.date) - new Date(b.date));
}

/**
 * Add completed session to calendar
 */
export function addCompletedSession(date, sessionType, details = {}) {
  const calendarData = loadCalendarData();
  const dateStr = formatHKDateKey(date);
  
  if (!calendarData.completedSessions[dateStr]) {
    calendarData.completedSessions[dateStr] = [];
  }
  
  calendarData.completedSessions[dateStr].push({
    type: sessionType,
    timestamp: new Date().toISOString(),
    ...details
  });
  
  saveCalendarData(calendarData);
}

/**
 * Get completed sessions for a specific date
 */
export function getCompletedSessions(date) {
  const calendarData = loadCalendarData();
  const dateStr = formatHKDateKey(date);
  return calendarData.completedSessions[dateStr] || [];
}

/**
 * Remove event from calendar (alias for compatibility)
 */
export function removeCalendarEvent(eventId) {
  return deleteCalendarEvent(eventId);
}

/**
 * Clear old data (older than 6 months)
 */
export function clearOldCalendarData() {
  const calendarData = loadCalendarData();
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  
  // Filter old events
  calendarData.events = calendarData.events.filter(event => 
    new Date(event.date) >= sixMonthsAgo
  );
  
  // Filter old completed sessions
  Object.keys(calendarData.completedSessions).forEach(dateStr => {
    if (new Date(dateStr) < sixMonthsAgo) {
      delete calendarData.completedSessions[dateStr];
    }
  });
  
  saveCalendarData(calendarData);
}

========================================================================================================================
FILE: src/utils/quizCompletionHandler.js
------------------------------------------------------------------------------------------------------------------------
/**
 * Quiz Completion Handler: Handles logging completed quiz sessions to calendar
 */

import { addCompletedSession } from './calendarHelper';

// Session types
export const SESSION_TYPES = {
  TOPICAL: 'Topical',
  MISTAKE_BOOK: 'Mistake Book',
  AI_DAILY_MISSION: 'AI Daily Mission',
  PRACTICE_MODE: 'Practice Mode',
  REVIEW_SESSION: 'Review Session'
};

// Log completed quiz session to calendar
export function logQuizCompletion(quizData) {
  const {
    sessionType = SESSION_TYPES.PRACTICE_MODE,
    questionCount = 0,
    correctAnswers = 0,
    timeSpent = 0,
    topics = [],
    date = new Date(),
    includeMistakeReview = false
  } = quizData;

  // Add main session
  addCompletedSession(date, sessionType, {
    questionCount,
    correctAnswers,
    accuracy: questionCount > 0 ? Math.round((correctAnswers / questionCount) * 100) : 0,
    timeSpent,
    topics
  });

  // Add mistake review session if included
  if (includeMistakeReview) {
    addCompletedSession(date, SESSION_TYPES.MISTAKE_BOOK, {
      reviewed: true,
      timeSpent: Math.floor(timeSpent * 0.3) // Assume 30% of time was mistake review
    });
  }

  // Add AI Daily Mission session if it was an AI mission
  if (sessionType === SESSION_TYPES.AI_DAILY_MISSION) {
    addCompletedSession(date, SESSION_TYPES.AI_DAILY_MISSION, {
      questionCount: 10, // AI missions are always 10 questions
      completed: true,
      timeSpent
    });
  }

  return true;
}

// Get session type from quiz parameters
export function getSessionTypeFromParams(params) {
  if (params.get('includeMistakeReview') === 'true') {
    return SESSION_TYPES.MISTAKE_BOOK;
  }
  
  if (params.get('type') === 'ai-mission') {
    return SESSION_TYPES.AI_DAILY_MISSION;
  }
  
  if (params.get('topicId')) {
    return SESSION_TYPES.TOPICAL;
  }
  
  return SESSION_TYPES.PRACTICE_MODE;
}

// Auto-log quiz completion (call this when quiz is finished)
export function autoLogQuizCompletion(quizResults, queryParams = {}) {
  const sessionType = getSessionTypeFromParams(new URLSearchParams(queryParams));
  
  return logQuizCompletion({
    sessionType,
    questionCount: quizResults.totalQuestions || 0,
    correctAnswers: quizResults.correctAnswers || 0,
    timeSpent: quizResults.timeSpent || 0,
    topics: quizResults.topics || [],
    date: new Date(),
    includeMistakeReview: queryParams.get('includeMistakeReview') === 'true'
  });
}

========================================================================================================================
FILE: src/pages/ResultsPage_Updated_Fixed.jsx
------------------------------------------------------------------------------------------------------------------------
import React, { useEffect, useState, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import ResultsSummary from '../components/ResultsSummary';
import { quizStorage } from '../utils/quizStorage';
import { quizService } from '../services/quizService';
import { quizCompletionService } from '../services/quizCompletionService';
import { calendarService } from '../services/calendarService';
import { rewardMCQCompletion, rewardQuizQuestionTokens } from '../services/rewardLogic';
import ChemistryLoading from '../components/ChemistryLoading';
import { formatHKDateKey } from '../utils/hkTime';
import { srsService } from '../services/srsService';
import { HelpCircle } from 'lucide-react';

/**
 * ResultsPage - OPTIMIZED VERSION with SRS Review Support
 * 
 * FIXES:
 * 1. ✅ No translation keys - plain English text
 * 2. ✅ Faster save - parallel operations
 * 3. ✅ Always logs to calendar with date
 * 4. ✅ Shortened loading time
 * 5. ✅ Spaced repetition reviews submitted in batch
 */
export default function ResultsPage() {
  const navigate = useNavigate();
  const { currentUser } = useAuth();
  const { t } = useLanguage();
  
  const [saving, setSaving] = useState(false);
  const [saved, setSaved] = useState(false);
  const [saveError, setSaveError] = useState(null);
  const hasSavedRef = useRef(false);
  const [savedAttemptId, setSavedAttemptId] = useState(null);
  const [showAddToSrsPrompt, setShowAddToSrsPrompt] = useState(false);
  const [showSrsInfo, setShowSrsInfo] = useState(false);
  const [addingToSrs, setAddingToSrs] = useState(false);
  const [addToSrsDone, setAddToSrsDone] = useState(false);
  const hasShownSrsPromptRef = useRef(false);

  const questions = quizStorage.getSelectedQuestions();
  const userAnswers = quizStorage.getUserAnswers();
  const questionTimes = quizStorage.getQuestionTimes();
  
  // Generate attempt key AFTER userAnswers is defined
  const attemptKey = userAnswers && Object.keys(userAnswers).length > 0 
    ? `quiz_saved_${Object.keys(userAnswers).sort().join('_')}` 
    : null;

  const mistakesToSrsMode = localStorage.getItem('practice_mistakes_to_srs_mode') || 'ask';

  useEffect(() => {
    if (!questions || questions.length === 0 || Object.keys(userAnswers).length === 0) {
      navigate('/practice');
    }
  }, [navigate, questions, userAnswers]);

  // Block navigation until save completes
  useEffect(() => {
    const handleBeforeUnload = (e) => {
      if (saving || !saved) {
        e.preventDefault();
        e.returnValue = t('results.resultsSavingLeaveConfirm');
        return e.returnValue;
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [saving, saved]);

  // OPTIMIZED: Save function with parallel operations
  useEffect(() => {
    async function saveAttemptToFirebase() {
      if (hasSavedRef.current) return;
      if (!currentUser || !questions || questions.length === 0) return;
      if (Object.keys(userAnswers).length === 0) return;
      
      // CRITICAL: Check sessionStorage to prevent double-submit on refresh
      if (attemptKey && sessionStorage.getItem(attemptKey)) {
        console.log('⚠️ Attempt already saved (sessionStorage), skipping duplicate save');
        setSaved(true);

        const existingAttemptId = attemptKey
          ? sessionStorage.getItem(`${attemptKey}_attemptId`)
          : null;

        if (existingAttemptId) setSavedAttemptId(existingAttemptId);

        if (!hasShownSrsPromptRef.current) {
          const alreadyResponded = attemptKey && sessionStorage.getItem(`${attemptKey}_srsPromptResponded`);
          const alreadyAutoAdded = attemptKey && sessionStorage.getItem(`${attemptKey}_srsAutoAdded`);
          if (!alreadyResponded) {
            hasShownSrsPromptRef.current = true;
            const wrongAnswers = questions.filter(q => userAnswers[q.ID] !== q.CorrectOption);
            const mode = localStorage.getItem('quiz_mode') || 'practice';

            if (mode !== 'spaced-repetition' && wrongAnswers.length > 0) {
              if (mistakesToSrsMode === 'never') {
                sessionStorage.setItem(`${attemptKey}_srsPromptResponded`, 'true');
              } else if (mistakesToSrsMode === 'always') {
                if (!alreadyAutoAdded && currentUser?.uid && existingAttemptId) {
                  (async () => {
                    try {
                      await srsService.createCardsFromMistakes(currentUser.uid, wrongAnswers, existingAttemptId, existingAttemptId);
                      sessionStorage.setItem(`${attemptKey}_srsAutoAdded`, 'true');
                      sessionStorage.setItem(`${attemptKey}_srsPromptResponded`, 'true');
                      setAddToSrsDone(true);
                      setTimeout(() => setAddToSrsDone(false), 2500);
                    } catch (e) {
                      console.error('Failed to auto-add mistakes to SRS:', e);
                    }
                  })();
                }
              } else {
                setShowAddToSrsPrompt(true);
              }
            }
          }
        }
        return;
      }

      hasSavedRef.current = true;
      setSaving(true);
      setSaveError(null);

      try {
        console.log('💾 Starting optimized save...');
        
        // Calculate results
        const totalQuestions = questions.length;
        const correctAnswers = questions.reduce((acc, q) => {
          return acc + (userAnswers[q.ID] === q.CorrectOption ? 1 : 0);
        }, 0);
        const percentage = Math.round((correctAnswers / totalQuestions) * 100);
        const topics = [...new Set(questions.map(q => q.Topic))].filter(Boolean);
        const subtopics = [...new Set(questions.map(q => q.Subtopic).filter(Boolean))];
        const timeSpent = questionTimes
          ? Object.values(questionTimes).reduce((sum, time) => sum + time, 0)
          : null;

        const attemptData = {
          score: percentage,
          totalQuestions,
          correctAnswers,
          percentage,
          topics,
          subtopics,
          timeSpent,
          questionTimes,
          answers: userAnswers,
          questions,
        };

        // STEP 1: Save attempt to Firestore
        const savedAttemptId = await quizService.saveAttempt(currentUser.uid, attemptData);
        const attemptId = savedAttemptId || `attempt_${Date.now()}`;
        console.log('✅ Attempt saved:', attemptId);
        setSavedAttemptId(attemptId);

        // Get quiz metadata
        const quizMode = localStorage.getItem('quiz_mode') || 'practice';
        const eventId = localStorage.getItem('quiz_event_id');
        const today = formatHKDateKey(new Date());

        // Prepare completion data for calendar
        const completionData = {
          totalQuestions,
          correctAnswers,
          percentage,
          topics,
          subtopics,
          timeSpent,
          mode: quizMode,
          eventId,
          date: today,  // Critical: Always include date
          completedAt: new Date().toISOString(),
          title: `${quizMode.charAt(0).toUpperCase() + quizMode.slice(1)} Quiz`
        };

        // STEP 2: Run ALL operations in parallel (MUCH FASTER!)
        const parallelOperations = [];

        // Operation 0: Token rewards (per-question + quiz bonus)
        parallelOperations.push(
          (async () => {
            try {
              await rewardQuizQuestionTokens(currentUser.uid, questions, userAnswers, quizMode);
              await rewardMCQCompletion(currentUser.uid, {
                percentage,
                totalQuestions,
                correctAnswers,
                topics,
                attemptId
              });
            } catch (err) {
              console.error('⚠️ Token reward error:', err);
            }
          })()
        );

        // Operation 1: Process quiz completion (performance + spaced repetition)
        parallelOperations.push(
          quizCompletionService.processQuizCompletion(
            currentUser.uid,
            questions,
            userAnswers,
            attemptId,
            { createSrsCards: false }
          ).catch(err => {
            console.error('⚠️ Processing error:', err);
            return { error: err };
          })
        );

        // Operation 2: Log to calendar (ALWAYS, for ALL quiz types)
        parallelOperations.push(
          quizCompletionService.logDetailedCompletion(
            currentUser.uid,
            attemptId,
            completionData
          ).catch(err => {
            console.error('⚠️ Calendar logging error:', err);
            return { error: err };
          })
        );

        // Operation 3: Mark specific event as complete (if applicable)
        if (quizMode === 'study-plan' && eventId) {
          parallelOperations.push(
            calendarService.markEventCompleted(eventId, {
              completedAt: new Date().toISOString(),
              questionCount: totalQuestions,
              correctCount: correctAnswers,
              accuracy: correctAnswers / totalQuestions,
              attemptId
            }).catch(err => {
              console.error('⚠️ Event marking error:', err);
              return { error: err };
            })
          );
        }

        // Operation 4: Handle spaced repetition reviews (NEW - BATCH SUBMISSION)
        if (quizMode === 'spaced-repetition') {
          // Get SRS cards from localStorage
          const srsCards = JSON.parse(localStorage.getItem('quiz_srs_cards') || '[]');
          
          // Build reviews array for ALL questions in this session
          const reviews = questions.map((question) => {
            const card = srsCards.find(c => c.questionId === question.ID);
            const wasCorrect = userAnswers[question.ID] === question.CorrectOption;
            
            return {
              cardId: card?.id,
              wasCorrect,
              userAnswer: userAnswers[question.ID],
              correctAnswer: question.CorrectOption,
              timeSpent: questionTimes?.[question.ID] || 0
            };
          }).filter(review => review.cardId); // Only include valid cards with cardId

          if (reviews.length > 0) {
            console.log(`📚 Submitting ${reviews.length} SRS reviews in batch...`);
            
            // Submit all reviews in one batch session
            parallelOperations.push(
              quizCompletionService.handleReviewSessionCompletion(
                currentUser.uid,
                reviews
              ).then(() => {
                // Clear SRS data after successful submission
                localStorage.removeItem('quiz_srs_cards');
                localStorage.removeItem('quiz_srs_session_id');
                console.log('✅ SRS reviews submitted and cleared');
              }).catch(err => {
                console.error('⚠️ SRS review submission error:', err);
                return { error: err };
              })
            );
          }

          // Also handle individual event markings (backward compatibility)
          const eventIdsJson = localStorage.getItem('quiz_event_ids');
          if (eventIdsJson) {
            const eventIds = JSON.parse(eventIdsJson);
            eventIds.forEach(id => {
              parallelOperations.push(
                (async () => {
                  const isCorrect = correctAnswers === totalQuestions;
                  await calendarService.markEventCompleted(id, {
                    completedAt: new Date().toISOString(),
                    wasCorrect: isCorrect,
                    attemptId
                  });
                })().catch(err => {
                  console.error('⚠️ Review marking error:', err);
                  return { error: err };
                })
              );
            });
          } else if (eventId) {
            parallelOperations.push(
              (async () => {
                const isCorrect = correctAnswers === totalQuestions;
                await calendarService.markEventCompleted(eventId, {
                  completedAt: new Date().toISOString(),
                  wasCorrect: isCorrect,
                  attemptId
                });
              })().catch(err => {
                console.error('⚠️ Review marking error:', err);
                return { error: err };
              })
            );
          }
        }

        // Operation 5: Handle AI recommendations
        if (quizMode === 'ai-recommendation' && eventId) {
          parallelOperations.push(
            calendarService.markEventCompleted(eventId, {
              completedAt: new Date().toISOString(),
              questionCount: totalQuestions,
              correctCount: correctAnswers,
              accuracy: correctAnswers / totalQuestions,
              attemptId
            }).catch(err => {
              console.error('⚠️ AI rec marking error:', err);
              return { error: err };
            })
          );
        }

        // Execute ALL operations at once (parallel = faster!)
        console.log(`🚀 Running ${parallelOperations.length} operations in parallel...`);
        const results = await Promise.all(parallelOperations);
        console.log('✅ All operations complete!');

        // Check for any errors (non-blocking)
        const errors = results.filter(r => r?.error);
        if (errors.length > 0) {
          console.warn('⚠️ Some operations had errors (non-critical):', errors);
          
          // If SRS submission failed, keep the data for retry
          const srsError = errors.find(e => e.error && e.error.message?.includes('SRS'));
          if (srsError) {
            console.log('📝 SRS data preserved for retry');
          }
        }

        setSaved(true);

        if (!hasShownSrsPromptRef.current) {
          const alreadyResponded = attemptKey && sessionStorage.getItem(`${attemptKey}_srsPromptResponded`);
          if (!alreadyResponded) {
            hasShownSrsPromptRef.current = true;
            const wrongAnswers = questions.filter(q => userAnswers[q.ID] !== q.CorrectOption);
            const mode = localStorage.getItem('quiz_mode') || 'practice';

            if (mode !== 'spaced-repetition' && wrongAnswers.length > 0) {
              if (mistakesToSrsMode === 'never') {
                sessionStorage.setItem(`${attemptKey}_srsPromptResponded`, 'true');
              } else if (mistakesToSrsMode === 'always') {
                try {
                  await srsService.createCardsFromMistakes(currentUser.uid, wrongAnswers, attemptId, attemptId);
                  sessionStorage.setItem(`${attemptKey}_srsAutoAdded`, 'true');
                  sessionStorage.setItem(`${attemptKey}_srsPromptResponded`, 'true');
                  setAddToSrsDone(true);
                  setTimeout(() => setAddToSrsDone(false), 2500);
                } catch (e) {
                  console.error('Failed to auto-add mistakes to SRS:', e);
                }
              } else {
                setShowAddToSrsPrompt(true);
              }
            }
          }
        }
        
        // Mark as saved in sessionStorage to prevent double-submit on refresh
        if (attemptKey) {
          sessionStorage.setItem(attemptKey, 'true');
          sessionStorage.setItem(`${attemptKey}_attemptId`, attemptId);
        }
        
        console.log('🎉 Save complete!');

      } catch (error) {
        console.error('❌ Critical save error:', error);
        setSaveError(error.message || 'Failed to save quiz results');
        hasSavedRef.current = false;
      } finally {
        setSaving(false);
      }
    }

    saveAttemptToFirebase();
  }, [currentUser, questions, userAnswers, questionTimes]);

  const handleRetry = () => {
    hasSavedRef.current = false;
    setSaveError(null);
    window.location.reload();
  };

  if (!questions || questions.length === 0) return null;

  const handleRestart = () => {
    if (!saved && !window.confirm(t('results.resultsMayNotBeSavedLeaveConfirm'))) {
      return;
    }

    // Clear ALL quiz-related localStorage items
    quizStorage.clearQuizData();
    localStorage.removeItem('quiz_mode');
    localStorage.removeItem('quiz_event_id');
    localStorage.removeItem('quiz_event_ids');
    localStorage.removeItem('quiz_event_phase');
    localStorage.removeItem('quiz_timer_enabled');
    localStorage.removeItem('quiz_review_mode');
    localStorage.removeItem('quiz_srs_cards');
    localStorage.removeItem('quiz_srs_session_id');
    
    navigate('/practice');
  };

  return (
    <div className="relative">
      {/* Blocking Save Modal - Simplified & Faster */}
      {saving && (
        <div className="fixed inset-0 bg-black/60 z-[100] flex items-center justify-center p-4 backdrop-blur-sm">
          <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 text-center">
            <ChemistryLoading />
          </div>
        </div>
      )}

      {addToSrsDone && (
        <div className="fixed top-32 right-4 bg-slate-900 text-white px-4 py-2 rounded-lg shadow-lg z-50 flex items-center gap-2 animate-in fade-in">
          <span className="font-semibold">
            {t('results.addedToSrs')}
          </span>
        </div>
      )}

      {showAddToSrsPrompt && !saving && (
        <div className="fixed inset-0 bg-black/60 z-[110] flex items-center justify-center p-4 backdrop-blur-sm" onClick={() => setShowAddToSrsPrompt(false)}>
          <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6" onClick={(e) => e.stopPropagation()}>
            <div className="flex items-start justify-between gap-3">
              <div className="min-w-0">
                <h3 className="text-xl font-black text-slate-900">
                  {t('results.addMistakesToSrsTitle')}
                </h3>
                <p className="text-sm text-slate-600 mt-1">
                  {t('results.addMistakesToSrsBody')}
                </p>
              </div>
              <button
                type="button"
                onClick={() => setShowAddToSrsPrompt(false)}
                className="w-10 h-10 rounded-xl bg-slate-100 hover:bg-slate-200 transition-all flex items-center justify-center flex-none"
                aria-label={t('common.close')}
              >
                ×
              </button>
            </div>

            <div className="flex items-center justify-between mt-5 gap-3">
              <button
                type="button"
                onClick={() => setShowSrsInfo(true)}
                className="w-10 h-10 rounded-xl border border-slate-200 bg-white hover:bg-slate-50 transition-all flex items-center justify-center text-slate-800 font-bold"
                aria-label={t('common.details')}
              >
                <HelpCircle size={16} />
              </button>

              <div className="flex gap-3">
                <button
                  type="button"
                  disabled={addingToSrs}
                  onClick={() => {
                    if (attemptKey) sessionStorage.setItem(`${attemptKey}_srsPromptResponded`, 'true');
                    setShowAddToSrsPrompt(false);
                  }}
                  className="px-4 py-2 rounded-xl bg-slate-200 text-slate-800 font-black hover:bg-slate-300 transition-all disabled:opacity-60"
                >
                  {t('common.noThanks')}
                </button>
                <button
                  type="button"
                  disabled={addingToSrs}
                  onClick={async () => {
                    try {
                      setAddingToSrs(true);
                      const uid = currentUser?.uid;
                      if (!uid) return;
                      const wrongAnswers = questions.filter(q => userAnswers[q.ID] !== q.CorrectOption);
                      if (wrongAnswers.length === 0) {
                        setShowAddToSrsPrompt(false);
                        return;
                      }

                      const attemptId = savedAttemptId || null;
                      const sessionId = attemptId || `attempt_${Date.now()}`;

                      await srsService.createCardsFromMistakes(uid, wrongAnswers, sessionId, attemptId);

                      if (attemptKey) sessionStorage.setItem(`${attemptKey}_srsPromptResponded`, 'true');

                      setShowAddToSrsPrompt(false);
                      setAddToSrsDone(true);
                      setTimeout(() => setAddToSrsDone(false), 2500);
                    } catch (e) {
                      console.error('Failed to add mistakes to SRS:', e);
                      alert(t('results.failedAddToSrs'));
                    } finally {
                      setAddingToSrs(false);
                    }
                  }}
                  className="px-4 py-2 rounded-xl bg-slate-900 text-white font-black hover:bg-black transition-all disabled:opacity-60"
                >
                  {addingToSrs ? t('results.addingToSrs') : t('results.addToSrs')}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {showSrsInfo && (
        <div className="fixed inset-0 bg-black/60 z-[120] flex items-center justify-center p-4 backdrop-blur-sm" onClick={() => setShowSrsInfo(false)}>
          <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6" onClick={(e) => e.stopPropagation()}>
            <div className="flex items-start justify-between gap-3">
              <div className="min-w-0">
                <h3 className="text-xl font-black text-slate-900">
                  {t('calendar.srsReviewMechanismTitle')}
                </h3>
                <p className="text-sm text-slate-700 mt-2 whitespace-pre-wrap">
                  {t('calendar.srsReviewMechanismDesc')}
                </p>
              </div>
              <button
                type="button"
                onClick={() => setShowSrsInfo(false)}
                className="w-10 h-10 rounded-xl bg-slate-100 hover:bg-slate-200 transition-all flex items-center justify-center flex-none"
                aria-label={t('common.close')}
              >
                ×
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Error Modal */}
      {saveError && !saving && (
        <div className="fixed inset-0 bg-black/60 z-[100] flex items-center justify-center p-4 backdrop-blur-sm">
          <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 text-center">
            <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg className="w-8 h-8 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
            </div>
            <h3 className="text-2xl font-black text-slate-800 mb-2">
              {t('results.saveFailed')}
            </h3>
            <p className="text-slate-600 mb-6">
              {saveError}
            </p>
            <div className="flex gap-3">
              <button
                onClick={handleRetry}
                className="flex-1 px-4 py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700 transition-all"
              >
                {t('common.retry')}
              </button>
              <button
                onClick={() => {
                  if (window.confirm(t('results.resultsNotSavedContinueAnywayConfirm'))) {
                    setSaveError(null);
                    setSaved(true);
                    
                    // Clear quiz data even if save failed
                    quizStorage.clearQuizData();
                    localStorage.removeItem('quiz_mode');
                    localStorage.removeItem('quiz_event_id');
                    localStorage.removeItem('quiz_event_ids');
                    localStorage.removeItem('quiz_srs_cards');
                    localStorage.removeItem('quiz_srs_session_id');
                  }
                }}
                className="flex-1 px-4 py-3 bg-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-300 transition-all"
              >
                {t('results.continueAnyway')}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Success Indicator */}
      {saved && !saving && (
        <div className="fixed top-20 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 flex items-center gap-2 animate-in fade-in">
          <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
          </svg>
          <span className="font-semibold">
            {localStorage.getItem('quiz_mode') === 'spaced-repetition' 
              ? t('results.reviewsSaved') 
              : t('results.savedToProfile')}
          </span>
        </div>
      )}

      <ResultsSummary
        questions={questions}
        userAnswers={userAnswers}
        questionTimes={questionTimes}
        onRestart={handleRestart}
      />
    </div>
  );
}

========================================================================================================================
FILE: src/pages/PracticeModeSelection.jsx
------------------------------------------------------------------------------------------------------------------------
import React, { useState, useMemo, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { Clock, Settings, Play, Zap, BookOpen, Lock, Check, AlertCircle, Info, Infinity, Sparkles, Layers, Heart, Gem } from 'lucide-react';
import FisheyeCarousel from '../components/FisheyeCarousel';
import { quizStorage } from '../utils/quizStorage';
import { useLanguage } from '../contexts/LanguageContext';
import { doc, updateDoc } from 'firebase/firestore';
import { db } from '../firebase/config';
import { quizService } from '../services/quizService';
import * as srsService from '../services/srsService';

// Helper function for AI Daily Mission selection
function calculateMasteryPriority(mistake, recentTopics = []) {
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = Math.max(0, (now - lastAttemptTime) / (1000 * 60 * 60 * 24));
  const U = Math.pow(2, daysSinceLastAttempt / 7);
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);
  let R = 0.5;
  if (recentTopics.length > 0 && recentTopics.includes(mistake.Topic)) {
    R = 1.5;
  }
  return (U * 0.4) + (D * 0.4) + (R * 0.2);
}

function selectAIDailyMission(mistakes, recentTopics = []) {
  const prioritized = mistakes
    .map(m => ({
      ...m,
      masteryPriority: calculateMasteryPriority(m, recentTopics)
    }))
    .sort((a, b) => b.masteryPriority - a.masteryPriority);
  
  const byTopic = {};
  prioritized.forEach(m => {
    if (!byTopic[m.Topic]) byTopic[m.Topic] = [];
    byTopic[m.Topic].push(m);
  });
  
  const selected = [];
  const topicList = Object.keys(byTopic);
  const indices = Object.fromEntries(topicList.map(t => [t, 0]));
  
  while (selected.length < 10 && topicList.some(t => indices[t] < byTopic[t].length)) {
    for (const topic of topicList) {
      if (selected.length >= 10) break;
      if (indices[topic] < byTopic[topic].length) {
        selected.push(byTopic[topic][indices[topic]++]);
      }
    }
  }
  
  return selected.slice(0, 10);
}

export default function PracticeModeSelection({ questions }) {
  const navigate = useNavigate();
  const { currentUser, userProfile, loadUserProfile } = useAuth();
  const { t, tf } = useLanguage();
  const [selectedMode, setSelectedMode] = useState(null);
  const [questionCount, setQuestionCount] = useState(10);
  const [showCustom, setShowCustom] = useState(false);
  const [showUpdateTopics, setShowUpdateTopics] = useState(false);
  const [loadingMistakes, setLoadingMistakes] = useState(false);
  const [activeCarouselModeId, setActiveCarouselModeId] = useState('timed');
  const [showAvailableTopicsInfo, setShowAvailableTopicsInfo] = useState(false);
  const [showPracticeSettings, setShowPracticeSettings] = useState(false);

  const [showTopic, setShowTopic] = useState(() => {
    const saved = localStorage.getItem('practice_show_topic');
    return saved === null ? true : saved === 'true';
  });
  const [showSubtopic, setShowSubtopic] = useState(() => {
    const saved = localStorage.getItem('practice_show_subtopic');
    return saved === null ? true : saved === 'true';
  });
  const [showDseCode, setShowDseCode] = useState(() => {
    const saved = localStorage.getItem('practice_show_dsecode');
    return saved === null ? true : saved === 'true';
  });

  const [showTimer, setShowTimer] = useState(() => {
    const saved = localStorage.getItem('practice_show_timer');
    return saved === null ? true : saved === 'true';
  });

  const [mistakesToSrsMode, setMistakesToSrsMode] = useState(() => {
    const saved = localStorage.getItem('practice_mistakes_to_srs_mode');
    return saved || 'ask';
  });

  useEffect(() => {
    localStorage.setItem('practice_show_topic', String(showTopic));
  }, [showTopic]);

  useEffect(() => {
    localStorage.setItem('practice_show_subtopic', String(showSubtopic));
  }, [showSubtopic]);

  useEffect(() => {
    localStorage.setItem('practice_show_dsecode', String(showDseCode));
  }, [showDseCode]);

  useEffect(() => {
    localStorage.setItem('practice_show_timer', String(showTimer));
  }, [showTimer]);

  useEffect(() => {
    localStorage.setItem('practice_mistakes_to_srs_mode', String(mistakesToSrsMode || 'ask'));
  }, [mistakesToSrsMode]);

  // Timer settings for each mode
  const [timedModeTimer, setTimedModeTimer] = useState(() => showTimer);
  const [timedModeIsTimed, setTimedModeIsTimed] = useState(true);
  const [marathonModeTimer, setMarathonModeTimer] = useState(() => showTimer);
  const [marathonModeIsTimed, setMarathonModeIsTimed] = useState(false);

  // Custom mode state
  const [selectedTopics, setSelectedTopics] = useState([]);
  const [selectedSubtopics, setSelectedSubtopics] = useState([]);
  const [customCount, setCustomCount] = useState(10);
  const [customTimerEnabled, setCustomTimerEnabled] = useState(() => showTimer);
  const [customIsTimed, setCustomIsTimed] = useState(false);

  useEffect(() => {
    setTimedModeTimer(showTimer);
    setMarathonModeTimer(showTimer);
    setCustomTimerEnabled(showTimer);
  }, [showTimer]);

  // Quick update topics state
  const [tempLearnedUpTo, setTempLearnedUpTo] = useState(userProfile?.learnedUpTo || '');
  const [tempExceptions, setTempExceptions] = useState(userProfile?.topicExceptions || []);
  const [updating, setUpdating] = useState(false);

  const MAX_QUESTIONS = 40;

  // Get all unique topics from questions
  const allTopics = useMemo(() => {
    return [...new Set(questions.map(q => q.Topic))]
      .filter(t => t && t !== "Uncategorized")
      .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));
  }, [questions]);

  // Get available topics based on user's learned progress
  const availableTopics = useMemo(() => {
    const learnedUpTo = userProfile?.learnedUpTo;
    const exceptions = userProfile?.topicExceptions || [];
    
    if (!learnedUpTo) return [];
    
    return allTopics.filter(topic => {
      const topicNum = topic.match(/^\d+/)?.[0];
      return topicNum && topicNum <= learnedUpTo && !exceptions.includes(topic);
    });
  }, [allTopics, userProfile]);

  // For custom mode: determine which topics can be selected
  const customTopics = useMemo(() => {
    return allTopics.map(topic => {
      const isAvailable = availableTopics.includes(topic);
      return {
        name: topic,
        available: isAvailable
      };
    });
  }, [allTopics, availableTopics]);

  useEffect(() => {
    if (!showCustom) return;
    const selectable = customTopics.filter(t => t.available).map(t => t.name);
    if (selectable.length === 0) return;
    setSelectedTopics((prev) => (prev.length === 0 ? selectable : prev));
  }, [showCustom, customTopics]);

  const availableSubtopics = useMemo(() => {
    if (selectedTopics.length === 0) return [];
    return [...new Set(questions
      .filter(q => selectedTopics.includes(q.Topic))
      .map(q => q.Subtopic))]
      .filter(Boolean)
      .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
  }, [selectedTopics, questions]);

  const toggleTopic = (topic) => {
    setSelectedTopics(prev => 
      prev.includes(topic) ? prev.filter(t => t !== topic) : [...prev, topic]
    );
    setSelectedSubtopics([]);
  };

  const toggleAllCustomTopics = () => {
    const selectable = customTopics.filter(t => t.available).map(t => t.name);
    if (selectable.length === 0) return;
    setSelectedTopics((prev) => (prev.length === selectable.length ? [] : selectable));
    setSelectedSubtopics([]);
  };

  const toggleSubtopic = (sub) => {
    setSelectedSubtopics(prev => 
      prev.includes(sub) ? prev.filter(s => s !== sub) : [...prev, sub]
    );
  };

  const handleUpdateTopics = async () => {
    setUpdating(true);
    try {
      const userRef = doc(db, 'users', currentUser.uid);
      await updateDoc(userRef, {
        learnedUpTo: tempLearnedUpTo,
        topicExceptions: tempExceptions,
        updatedAt: new Date().toISOString()
      });
      await loadUserProfile(currentUser.uid);
      setShowUpdateTopics(false);
      alert(t('practiceMode.topicsUpdated'));
    } catch (error) {
      console.error('Error updating topics:', error);
      alert(t('practiceMode.failedUpdate'));
    }
    setUpdating(false);
  };

  const handleModeSelect = (mode, count, timerEnabled = false, isTimed = false) => {
    if (mode === 'mistakes') {
      navigate('/notebook');
      return;
    }

    if (mode === 'ai-daily') {
      handleAIDailyMission();
      return;
    }

    if (availableTopics.length === 0) {
      alert(t('practice.pleaseSetTopics'));
      navigate('/profile');
      return;
    }

    setSelectedMode(mode);
    setQuestionCount(count);
    
    if (mode === 'custom') {
      setShowCustom(true);
    } else {
      const filtered = questions.filter(q => availableTopics.includes(q.Topic));
      const shuffled = [...filtered].sort(() => 0.5 - Math.random());
      const finalSelection = shuffled.slice(0, Math.min(count, MAX_QUESTIONS, shuffled.length));
      
      startQuiz(finalSelection, mode, timerEnabled, isTimed);
    }
  };

  const handleCarouselModeSelect = (mode) => {
    switch (mode.id) {
      case 'timed':
        handleModeSelect('timed', 10, timedModeTimer, timedModeIsTimed);
        break;
      case 'marathon':
        handleModeSelect('marathon', 10, marathonModeTimer, marathonModeIsTimed);
        break;
      case 'ai-daily':
        handleAIDailyMission();
        break;
      case 'mistake-review':
        navigate('/notebook');
        break;
      case 'srs-review':
        (async () => {
          try {
            const uid = currentUser?.uid;
            if (!uid) return;

            const due = await srsService.getDueCards(uid, undefined, { limit: 1 });
            if (!Array.isArray(due) || due.length === 0) {
              alert(t('calendar.noReviewSessionsFoundForDay'));
              return;
            }

            navigate('/srs-review');
          } catch (e) {
            console.error('Failed to check SRS due cards:', e);
            alert(t('srs.failedLoadDueCardsTryAgain'));
          }
        })();
        break;
      case 'custom':
        handleModeSelect('custom', 10);
        break;
      case 'millionaire':
        navigate('/millionaire');
        break;
      default:
        break;
    }
  };

  const handleAIDailyMission = async () => {
    setLoadingMistakes(true);
    try {
      // Load user's mistakes
      const attempts = await quizService.getUserAttempts(currentUser.uid, 100);
      const incorrectMap = new Map();
      const improvementData = JSON.parse(
        localStorage.getItem('mistake_improvements') || '{}'
      );
      const recentTopics = JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]');
      const MASTERY_THRESHOLD = 3;
      
      attempts.forEach((attempt) => {
        if (!attempt.answers || !attempt.questions) return;
        attempt.questions.forEach((question) => {
          const userAnswer = attempt.answers[question.ID];
          const isCorrect = userAnswer && userAnswer === question.CorrectOption;
          
          if (isCorrect && improvementData[question.ID]) {
            improvementData[question.ID].correctCount =
              (improvementData[question.ID].correctCount || 0) + 1;
            improvementData[question.ID].lastCorrect = attempt.timestamp;
          }
          
          if (userAnswer && userAnswer !== question.CorrectOption) {
            const improveCount = improvementData[question.ID]?.correctCount || 0;
            if (improveCount >= MASTERY_THRESHOLD) return;
            
            if (!incorrectMap.has(question.ID)) {
              incorrectMap.set(question.ID, {
                ...question,
                attemptCount: 1,
                lastAttempted: attempt.timestamp,
                userAnswer,
                improvementCount: improveCount,
              });
            } else {
              const existing = incorrectMap.get(question.ID);
              existing.attemptCount += 1;
              existing.improvementCount = improveCount;
              if (new Date(attempt.timestamp) > new Date(existing.lastAttempted)) {
                existing.lastAttempted = attempt.timestamp;
                existing.userAnswer = userAnswer;
              }
            }
          }
        });
      });

      const mistakes = Array.from(incorrectMap.values());
      
      if (mistakes.length < 10) {
        alert(tf('notebook.needMoreQuestions', { count: mistakes.length }));
        setLoadingMistakes(false);
        return;
      }

      // Use AI selection
      const selected = selectAIDailyMission(mistakes, recentTopics);
      startQuiz(selected, 'ai-daily', true, true);
    } catch (error) {
      console.error('Error loading mistakes for AI Daily Mission:', error);
      alert(t('practiceMode.failedLoadMistakesTryAgain'));
    }
    setLoadingMistakes(false);
  };

  const handleCustomStart = () => {
    let pool = questions.filter(q => selectedTopics.includes(q.Topic));
    
    if (selectedSubtopics.length > 0) {
      pool = pool.filter(q => selectedSubtopics.includes(q.Subtopic));
    }
    
    const shuffled = [...pool].sort(() => 0.5 - Math.random());
    const requestedCount = customCount === 'All' ? pool.length : parseInt(customCount);
    const finalCount = Math.min(requestedCount, MAX_QUESTIONS);
    const finalSelection = shuffled.slice(0, finalCount);
    
    if (finalSelection.length === 0) {
      alert(t('notebook.noQuestionsFound'));
      return;
    }

    if (requestedCount > MAX_QUESTIONS) {
      alert(tf('notebook.sessionLimited', { max: MAX_QUESTIONS }));
    }

    startQuiz(finalSelection, 'custom', customTimerEnabled, customIsTimed);
  };

  const startQuiz = (selectedQuestions, mode, timerEnabled, isTimed) => {
    quizStorage.clearQuizData();
    quizStorage.saveSelectedQuestions(selectedQuestions);
    
    localStorage.setItem('quiz_mode', mode);
    localStorage.setItem('quiz_timer_enabled', timerEnabled.toString());
    localStorage.setItem('quiz_is_timed_mode', isTimed.toString());
    localStorage.setItem('quiz_hide_timer_ui', (!showTimer).toString());
    
    navigate('/quiz');
  };

  // Quick update topics modal
  if (showUpdateTopics) {
    const learnedRangeTopics = allTopics.filter(topic => {
      const topicNum = topic.match(/^\d+/)?.[0];
      return topicNum && topicNum <= tempLearnedUpTo;
    });

    return (
      <div className="max-w-4xl mx-auto space-y-6">
        <div className="rounded-2xl p-4 border border-white/40 bg-white/55 backdrop-blur-xl shadow-lg">
          <div className="absolute inset-0 rounded-2xl opacity-70 bg-[radial-gradient(circle_at_15%_20%,rgba(99,102,241,0.22),transparent_60%),radial-gradient(circle_at_80%_30%,rgba(236,72,153,0.18),transparent_60%),radial-gradient(circle_at_50%_85%,rgba(34,211,238,0.16),transparent_55%)]" />
          <div className="relative rounded-2xl border border-white/40 bg-white/30 backdrop-blur shadow-sm overflow-hidden">
            <div className="p-5 border-b border-white/40 flex items-center justify-between">
              <div className="flex items-center gap-2 min-w-0">
                <BookOpen size={18} className="text-slate-900" />
                <h2 className="text-lg sm:text-xl font-black text-slate-900 truncate">
                  {t('practiceMode.updateYourTopics')}
                </h2>
              </div>
              <button
                type="button"
                onClick={() => setShowUpdateTopics(false)}
                className="w-10 h-10 rounded-xl border border-white/40 bg-white/40 backdrop-blur flex items-center justify-center text-slate-900 hover:bg-white/55 transition-all flex-none"
                aria-label={t('common.close')}
              >
                ×
              </button>
            </div>

            <div className="p-6 space-y-6">
              <div>
                <label className="block text-sm font-bold text-slate-700 mb-3">
                  {t('practiceMode.learnedUpTo')}
                </label>
                <div className="grid grid-cols-6 md:grid-cols-8 gap-2">
                  {allTopics.map((topic) => {
                    const topicNum = topic.match(/^\d+/)?.[0];
                    return (
                      <button
                        key={topic}
                        onClick={() => setTempLearnedUpTo(topicNum)}
                        className={`py-2 rounded-lg border-2 font-bold transition-all ${
                          tempLearnedUpTo === topicNum
                            ? 'border-chemistry-green bg-green-50 text-chemistry-green'
                            : 'border-slate-200 text-slate-600 hover:border-slate-300'
                        }`}
                      >
                        {topicNum}
                      </button>
                    );
                  })}
                </div>
              </div>

            {tempLearnedUpTo && learnedRangeTopics.length > 0 && (
              <div>
                <label className="block text-sm font-bold text-slate-700 mb-3">
                  {t('practiceMode.exceptions')}
                </label>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                  {learnedRangeTopics.map((topic) => {
                    const isException = tempExceptions.includes(topic);
                    return (
                      <button
                        key={topic}
                        onClick={() => setTempExceptions(prev =>
                          prev.includes(topic) ? prev.filter(t => t !== topic) : [...prev, topic]
                        )}
                        className={`flex items-center justify-between p-3 rounded-xl border-2 transition-all ${
                          isException
                            ? 'border-red-300 bg-red-50 text-red-700'
                            : 'border-green-200 bg-green-50 text-green-700'
                        }`}
                      >
                        <span className="text-sm font-semibold">{topic}</span>
                        {isException ? <Lock size={16} /> : <Check size={16} />}
                      </button>
                    );
                  })}
                </div>
              </div>
            )}

            <div className="flex gap-3">
              <button
                onClick={handleUpdateTopics}
                disabled={updating}
                className="flex-1 py-3 bg-chemistry-green text-white rounded-xl font-bold hover:opacity-90 disabled:bg-slate-300 transition-all"
              >
                {updating ? t('practiceMode.updating') : t('practiceMode.saveChanges')}
              </button>
              <button
                onClick={() => setShowUpdateTopics(false)}
                className="px-6 py-3 bg-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-300 transition-all"
              >
                {t('common.cancel')}
              </button>
            </div>
          </div>
        </div>
        </div>
      </div>
    );
  }

  // Custom mode configuration
  if (showCustom) {
    return (
      <div className="max-w-4xl mx-auto space-y-6 animate-in fade-in duration-500">
        <div className="bg-white rounded-2xl shadow-xl border border-slate-200 overflow-hidden">
          <div className="bg-slate-50 p-6 border-b flex justify-between items-center">
            <h2 className="text-xl font-bold flex items-center gap-2 text-slate-800">
              <Settings size={20} className="text-lab-blue" />
              {t('practiceMode.configureCustomSession')}
            </h2>
            <button
              onClick={() => setShowCustom(false)}
              className="text-sm text-slate-600 hover:text-slate-800 hover:underline font-semibold"
            >
              ← {t('practiceMode.back')}
            </button>
          </div>

          <div className="p-8 space-y-8">
            <div>
              <label className="block text-sm font-black text-slate-500 uppercase tracking-widest mb-4">
                {t('practiceMode.selectTopics')}
              </label>
              <div className="flex flex-wrap gap-2 mb-3">
                <button
                  type="button"
                  onClick={toggleAllCustomTopics}
                  className="px-4 py-2 rounded-full text-xs font-black border-2 transition-all bg-white border-slate-200 text-slate-700 hover:border-slate-300"
                >
                  All
                </button>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                {customTopics.map(({ name, available }) => (
                  <button
                    key={name}
                    onClick={() => available && toggleTopic(name)}
                    disabled={!available}
                    className={`flex items-center justify-between p-3 rounded-xl border-2 transition-all ${
                      !available
                        ? 'border-slate-200 bg-slate-50 text-slate-400 cursor-not-allowed opacity-50'
                        : selectedTopics.includes(name)
                        ? 'border-lab-blue bg-blue-50 text-lab-blue shadow-sm'
                        : 'border-slate-100 text-slate-600 hover:border-slate-200'
                    }`}
                  >
                    <span className="text-sm font-semibold flex items-center gap-2">
                      {!available && <Lock size={14} />}
                      {name}
                    </span>
                    {selectedTopics.includes(name) && <Check size={16} />}
                  </button>
                ))}
              </div>
              {customTopics.some(t => !t.available) && (
                <p className="text-xs text-amber-600 mt-2 flex items-center gap-1">
                  <Lock size={12} />
                  {t('practiceMode.lockedTopicsNotLearned')}
                </p>
              )}
            </div>

            {selectedTopics.length > 0 && availableSubtopics.length > 0 && (
              <div className="animate-in slide-in-from-top-4">
                <label className="block text-sm font-black text-slate-500 mb-4 uppercase tracking-widest">
                  {t('practiceMode.focusSubtopics')}
                </label>
                <div className="flex flex-wrap gap-2">
                  {availableSubtopics.map(sub => (
                    <button
                      key={sub}
                      onClick={() => toggleSubtopic(sub)}
                      className={`px-4 py-2 rounded-full text-xs font-bold border-2 transition-all ${
                        selectedSubtopics.includes(sub)
                        ? 'bg-lab-blue border-lab-blue text-white'
                        : 'bg-white border-slate-200 text-slate-500 hover:border-slate-300'
                      }`}
                    >
                      {sub}
                    </button>
                  ))}
                </div>
              </div>
            )}

            <div>
              <label className="block text-sm font-black text-slate-500 mb-4 uppercase tracking-widest">
                {t('practiceMode.sessionLength')}
              </label>
              <div className="grid grid-cols-3 md:grid-cols-6 gap-3">
                {['5', '10', '20', '36'].map(num => (
                  <button
                    key={num}
                    onClick={() => setCustomCount(num)}
                    className={`py-3 rounded-xl border-2 font-bold transition-all ${
                      customCount === num ? 'border-lab-blue bg-blue-50 text-lab-blue' : 'border-slate-100 text-slate-400'
                    }`}
                  >
                    {num}
                  </button>
                ))}
              </div>
            </div>

            {/* Timer Settings for Custom Mode */}
            <div className="space-y-4">
              <div className="bg-slate-50 rounded-xl p-4 border-2 border-slate-200">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <Clock size={20} className="text-lab-blue" />
                    <div>
                      <h3 className="font-bold text-slate-800">{t('quiz.enableTimer')}</h3>
                      <p className="text-xs text-slate-500">{t('quiz.trackTimeSpent')}</p>
                    </div>
                  </div>
                  <button
                    onClick={() => setCustomTimerEnabled(!customTimerEnabled)}
                    className={`relative w-14 h-8 rounded-full transition-all ${
                      customTimerEnabled ? 'bg-chemistry-green' : 'bg-slate-300'
                    }`}
                  >
                    <div className={`absolute top-1 left-1 w-6 h-6 bg-white rounded-full transition-transform ${
                      customTimerEnabled ? 'translate-x-6' : 'translate-x-0'
                    }`} />
                  </button>
                </div>
              </div>

              {customTimerEnabled && (
                <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-200 animate-in fade-in">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <Zap size={20} className="text-amber-600" />
                      <div>
                        <h3 className="font-bold text-amber-900">{t('quiz.timedMode')}</h3>
                        <p className="text-xs text-amber-700">{t('quiz.countdownTimer')}</p>
                      </div>
                    </div>
                    <button
                      onClick={() => setCustomIsTimed(!customIsTimed)}
                      className={`relative w-14 h-8 rounded-full transition-all ${
                        customIsTimed ? 'bg-amber-600' : 'bg-slate-300'
                      }`}
                    >
                      <div className={`absolute top-1 left-1 w-6 h-6 bg-white rounded-full transition-transform ${
                        customIsTimed ? 'translate-x-6' : 'translate-x-0'
                      }`} />
                    </button>
                  </div>
                </div>
              )}
            </div>

            <button 
              disabled={selectedTopics.length === 0}
              onClick={handleCustomStart}
              className="w-full py-5 bg-lab-blue text-white rounded-2xl font-black text-lg shadow-lg hover:bg-blue-800 disabled:bg-slate-200 transition-all flex items-center justify-center gap-2 active:scale-95"
            >
              <Play fill="currentColor" size={18} />
              {t('practiceMode.startPractice')}
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main mode selection screen
  return (
    <div className="max-w-6xl mx-auto space-y-4 pb-6">
      <div className="rounded-2xl border border-white/40 bg-white/55 backdrop-blur-xl shadow-lg px-4 py-3">
        <div className="absolute inset-0 rounded-2xl opacity-70 bg-[radial-gradient(circle_at_20%_20%,rgba(245,158,11,0.16),transparent_60%),radial-gradient(circle_at_80%_30%,rgba(249,115,22,0.14),transparent_60%),radial-gradient(circle_at_50%_85%,rgba(236,72,153,0.10),transparent_55%)]" />
        <div className="relative grid grid-cols-1 sm:grid-cols-3 gap-3">
          {(() => {
            const modeTitleKey = {
              timed: 'practiceModeCarousel.timedTitle',
              marathon: 'practiceModeCarousel.marathonTitle',
              custom: 'practiceModeCarousel.customTitle',
              'ai-daily': 'practiceModeCarousel.aiDailyTitle',
              'srs-review': 'practiceModeCarousel.srsReviewTitle',
              'mistake-review': 'practiceModeCarousel.mistakeReviewTitle',
              millionaire: 'practiceModeCarousel.millionaireTitle',
            };

            const groups = [
              {
                id: 'regular',
                titleKey: 'practiceModeLegend.regular',
                icon: Clock,
                modeIds: ['timed', 'marathon', 'custom'],
              },
              {
                id: 'mistake',
                titleKey: 'practiceModeLegend.mistakeReview',
                icon: Heart,
                modeIds: ['ai-daily', 'srs-review', 'mistake-review'],
              },
              {
                id: 'game',
                titleKey: 'practiceModeLegend.gameMode',
                icon: Gem,
                modeIds: ['millionaire'],
              },
            ];

            return groups.map((group) => {
              const isGroupActive = group.modeIds.includes(activeCarouselModeId);
              const GroupIcon = group.icon;

              return (
                <div key={group.id} className="rounded-xl border border-white/50 bg-white/40 p-2">
                  <button
                    type="button"
                    onClick={() => setActiveCarouselModeId(group.modeIds[0])}
                    className={`w-full rounded-xl px-3 py-2 border border-slate-200 transition-all font-black text-sm flex items-center justify-center gap-2 ${
                      isGroupActive ? 'bg-slate-900 text-white border-slate-900' : 'bg-white/50 text-slate-800 hover:bg-white/70'
                    }`}
                  >
                    {GroupIcon && <GroupIcon size={16} strokeWidth={2.5} className={isGroupActive ? 'text-white' : 'text-slate-800'} />}
                    {t(group.titleKey)}
                  </button>

                  <div className="mt-2 flex flex-nowrap gap-2 justify-center items-center overflow-visible py-1">
                    {group.modeIds.map((modeId) => {
                      const isModeActive = activeCarouselModeId === modeId;

                      const ModeIcon = {
                        timed: Clock,
                        marathon: Infinity,
                        custom: Settings,
                        'ai-daily': Sparkles,
                        'srs-review': Layers,
                        'mistake-review': Heart,
                        millionaire: Gem,
                      }[modeId];

                      const shortLabelKey = {
                        timed: 'practiceModeLegend.timedShort',
                        marathon: 'practiceModeLegend.untimedShort',
                        custom: 'practiceModeLegend.customShort',
                        'ai-daily': 'practiceModeLegend.aiDailyShort',
                        'srs-review': 'practiceModeLegend.srsShort',
                        'mistake-review': 'practiceModeLegend.customShort',
                        millionaire: 'practiceModeLegend.millionaireShort',
                      }[modeId];
                      const shortLabel = shortLabelKey ? t(shortLabelKey) : modeId;

                      const modeActiveClass = {
                        timed: 'bg-gradient-to-r from-red-500 to-orange-500 border-red-600 text-white shadow-sm',
                        marathon: 'bg-gradient-to-r from-purple-600 to-indigo-600 border-indigo-700 text-white shadow-sm',
                        custom: 'bg-gradient-to-r from-amber-700 via-orange-500 to-amber-900 border-amber-900 text-white shadow-sm',
                        'ai-daily': 'bg-gradient-to-r from-cyan-600 via-sky-600 to-indigo-600 border-cyan-700 text-white shadow-sm',
                        'srs-review': 'bg-gradient-to-r from-emerald-600 to-teal-600 border-emerald-700 text-white shadow-sm',
                        'mistake-review': 'bg-gradient-to-r from-rose-500 to-pink-500 border-rose-600 text-white shadow-sm',
                        millionaire: 'bg-gradient-to-r from-amber-500 via-orange-500 to-rose-500 border-amber-600 text-white shadow-sm',
                      }[modeId] || 'bg-slate-900 border-slate-900 text-white shadow-sm';

                      return (
                        <button
                          key={modeId}
                          type="button"
                          onClick={() => setActiveCarouselModeId(modeId)}
                          className={`flex-none min-w-[5.25rem] px-2.5 py-1.5 rounded-lg border border-slate-200 text-xs font-black transition-all whitespace-nowrap leading-none text-center flex items-center justify-center gap-1.5 ${
                            isModeActive
                              ? modeActiveClass
                              : 'bg-white/60 text-slate-700 border-slate-200 hover:bg-white/80'
                          }`}
                        >
                          {ModeIcon && <ModeIcon size={14} strokeWidth={2.5} className={isModeActive ? 'text-white' : 'text-slate-700'} />}
                          {shortLabel}
                        </button>
                      );
                    })}
                  </div>
                </div>
              );
            });
          })()}
        </div>
      </div>

      <div className="flex justify-end">
        <button
          type="button"
          onClick={() => setShowPracticeSettings(true)}
          className="rounded-2xl border border-white/40 bg-white/55 backdrop-blur-xl shadow-lg px-4 py-2 flex items-center gap-2 hover:bg-white/70 transition-all"
        >
          <Settings size={16} className="text-slate-900" />
          <span className="text-sm font-black text-slate-900">{t('practice.quizSettingsTitle')}</span>
        </button>
      </div>

      <FisheyeCarousel
        onModeSelect={handleCarouselModeSelect}
        showHeader={false}
        compact
        initialModeId="timed"
        activeModeId={activeCarouselModeId}
        onActiveModeChange={setActiveCarouselModeId}
      />

      {showPracticeSettings && (
        <div
          className="fixed inset-0 z-50 flex items-end sm:items-center justify-center p-4"
          onClick={() => setShowPracticeSettings(false)}
        >
          <div className="absolute inset-0 bg-black/50" />
          <div
            className="relative w-full max-w-3xl rounded-2xl p-4 border border-white/40 bg-white/55 backdrop-blur-xl shadow-2xl"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="absolute inset-0 rounded-2xl opacity-70 bg-[radial-gradient(circle_at_15%_20%,rgba(99,102,241,0.22),transparent_60%),radial-gradient(circle_at_80%_30%,rgba(236,72,153,0.18),transparent_60%),radial-gradient(circle_at_50%_85%,rgba(34,211,238,0.16),transparent_55%)]" />
            <div className="relative rounded-2xl border border-white/40 bg-white/30 backdrop-blur shadow-sm overflow-hidden">
              <div className="p-5 border-b border-white/40 flex items-center justify-between">
                <div className="flex items-center gap-2 min-w-0">
                  <BookOpen size={18} className="text-slate-900" />
                  <h3 className="text-lg font-black text-slate-900 truncate">
                    {t('practice.quizSettingsTitle')}
                  </h3>
                </div>
                <button
                  type="button"
                  onClick={() => setShowPracticeSettings(false)}
                  className="w-10 h-10 rounded-xl border border-white/40 bg-white/40 backdrop-blur flex items-center justify-center text-slate-900 hover:bg-white/55 transition-all flex-none"
                  aria-label={t('common.close')}
                >
                  ×
                </button>
              </div>

              <div className="p-5 space-y-4">
                {availableTopics.length > 0 ? (
                  <div className="rounded-2xl border border-white/40 bg-white/40 backdrop-blur px-4 py-3">
                    <div className="flex items-center justify-between gap-3">
                      <div className="flex items-center gap-2 min-w-0">
                        <h4 className="font-black text-slate-900 truncate">
                          {t('practice.yourAvailableTopics')} ({availableTopics.length})
                        </h4>
                        <button
                          type="button"
                          onClick={() => setShowAvailableTopicsInfo(true)}
                          className="w-7 h-7 rounded-full border border-white/40 bg-white/40 backdrop-blur flex items-center justify-center text-slate-800 hover:bg-white/55 transition-all flex-none"
                          aria-label={t('practice.availableTopicsInfoTitle')}
                        >
                          <Info size={14} />
                        </button>
                      </div>

                      <div className="flex items-center gap-2 flex-none">
                        <button
                          type="button"
                          onClick={() => setShowUpdateTopics(true)}
                          className="px-4 py-2 rounded-xl font-bold text-sm transition-all whitespace-nowrap border border-white/40 bg-white/40 backdrop-blur hover:bg-white/55 text-slate-900 shadow-sm"
                        >
                          {t('practice.updateTopics')}
                        </button>
                      </div>
                    </div>

                    <div className="mt-3 flex flex-wrap gap-2">
                      {availableTopics.map((topic) => (
                        <span key={topic} className="px-2 py-1 bg-white/70 border border-white/50 text-slate-800 rounded-lg text-xs font-bold shadow-sm">
                          {topic}
                        </span>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="bg-amber-50 border-2 border-amber-300 rounded-xl p-4">
                    <div className="flex items-start gap-3">
                      <AlertCircle className="text-amber-600 flex-shrink-0 mt-0.5" size={20} />
                      <div className="flex-1">
                        <p className="text-amber-900 font-bold mb-2">
                          {t('practice.noTopicsConfigured')}
                        </p>
                        <p className="text-amber-800 text-sm mb-3">
                          {t('practice.pleaseSetTopics')}
                        </p>
                        <button
                          onClick={() => navigate('/profile')}
                          className="px-4 py-2 bg-amber-600 text-white rounded-lg font-bold hover:bg-amber-700 transition-all"
                        >
                          {t('practice.goToProfile')}
                        </button>
                      </div>
                    </div>
                  </div>
                )}

                <div className="rounded-2xl border border-white/40 bg-white/40 backdrop-blur px-4 py-3">
                  <div className="flex flex-wrap items-center gap-3">
                    <div className="text-xs font-black uppercase tracking-wider text-slate-900/80">
                      Hide in quiz
                    </div>
                    <div className="flex flex-wrap gap-2">
                      <button
                        type="button"
                        onClick={() => setShowTopic(v => !v)}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${!showTopic ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(34,211,238,0.55)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        Topic
                      </button>
                      <button
                        type="button"
                        onClick={() => setShowSubtopic(v => !v)}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${!showSubtopic ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(236,72,153,0.45)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        Subtopic
                      </button>
                      <button
                        type="button"
                        onClick={() => setShowDseCode(v => !v)}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${!showDseCode ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(99,102,241,0.5)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        Code
                      </button>
                      <button
                        type="button"
                        onClick={() => setShowTimer(v => !v)}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${!showTimer ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(16,185,129,0.55)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        Timer
                      </button>
                    </div>
                  </div>
                </div>

                <div className="rounded-2xl border border-white/40 bg-white/40 backdrop-blur px-4 py-3">
                  <div className="flex flex-wrap items-center gap-3">
                    <div className="text-xs font-black uppercase tracking-wider text-slate-900/80">
                      {t('practice.mistakesToSrsTitle')}
                    </div>
                    <div className="flex flex-wrap gap-2">
                      <button
                        type="button"
                        onClick={() => setMistakesToSrsMode('always')}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${mistakesToSrsMode === 'always' ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(16,185,129,0.45)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        {t('practice.mistakesToSrsAlways')}
                      </button>
                      <button
                        type="button"
                        onClick={() => setMistakesToSrsMode('never')}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${mistakesToSrsMode === 'never' ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(236,72,153,0.35)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        {t('practice.mistakesToSrsNever')}
                      </button>
                      <button
                        type="button"
                        onClick={() => setMistakesToSrsMode('ask')}
                        className={`px-3 py-1.5 rounded-full text-xs font-black border transition-all ${mistakesToSrsMode === 'ask' ? 'bg-white text-slate-900 border-white shadow-[0_0_0_2px_rgba(255,255,255,0.9),0_0_18px_rgba(99,102,241,0.35)]' : 'bg-transparent text-slate-400 border-white/30 hover:border-white/60 hover:text-slate-600'}`}
                      >
                        {t('practice.mistakesToSrsAsk')}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {showAvailableTopicsInfo && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          onClick={() => setShowAvailableTopicsInfo(false)}
        >
          <div className="absolute inset-0 bg-black/50" />
          <div
            className="relative w-full max-w-lg bg-white rounded-2xl shadow-2xl border-2 border-indigo-200 overflow-hidden"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="p-5 border-b-2 border-indigo-200 flex items-center justify-between bg-indigo-50">
              <div className="flex items-center gap-2">
                <Info size={18} className="text-indigo-700" />
                <h3 className="text-lg font-black text-slate-800">{t('practice.availableTopicsInfoTitle')}</h3>
              </div>
              <button
                type="button"
                onClick={() => setShowAvailableTopicsInfo(false)}
                className="p-2 hover:bg-white rounded-xl transition-all"
                aria-label={t('common.close')}
              >
                ×
              </button>
            </div>
            <div className="p-5">
              <div className="text-sm text-slate-700 leading-relaxed whitespace-pre-wrap">
                {t('practice.availableTopicsInfoBody')}
              </div>
            </div>
          </div>
        </div>
      )}

    </div>
  );
}

========================================================================================================================
FILE: src/pages/DashboardPage_Fixed.jsx
------------------------------------------------------------------------------------------------------------------------
import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { quizService } from '../services/quizService';
import { loadMistakesFromStorage } from '../utils/masteryHelper';
import AttemptDetailModal from '../components/AttemptDetailModal';
import SmartMonthlyCalendar from '../components/dashboard/SmartMonthlyCalendar';
import EventCreationModal from '../components/dashboard/EventCreationModal';
import CompactAttemptsList from '../components/dashboard/CompactAttemptsList';
import ChemistryLoading from '../components/ChemistryLoading';
import { LogOut, AlertCircle, RefreshCw, X, Info, Gift, Target, Brain, TrendingUp, BarChart2, ChevronRight, Sparkles } from 'lucide-react';
import { awardTokens, canClaimReward, recordRewardClaim } from '../services/tokenService';
import { performanceService } from '../services/performanceService';
import { calendarServiceOptimized } from '../services/calendarServiceOptimized';

// ✅ FIXED: Now receives questions as prop
export default function DashboardPage({ questions = [] }) {
  const { currentUser, userProfile, logout } = useAuth();
  const { t } = useLanguage();
  const navigate = useNavigate();

  const notebookPath = '/notebook';

  const [attempts, setAttempts] = useState([]);
  const [mistakes, setMistakes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedAttempt, setSelectedAttempt] = useState(null);
  const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
  const [showEventModal, setShowEventModal] = useState(false);
  const [calendarKey, setCalendarKey] = useState(0);
  const [dailyClaiming, setDailyClaiming] = useState(false);
  const [dailyClaimMessage, setDailyClaimMessage] = useState(null);
  const [aiRecommendations, setAIRecommendations] = useState([]);
  const [showAiSuggestionsInfo, setShowAiSuggestionsInfo] = useState(false);

  const topicsToFocus = useMemo(() => {
    try {
      const raw = localStorage.getItem('dashboard_topics_to_focus_cache_v1');
      const parsed = raw ? JSON.parse(raw) : null;
      const top = parsed?.top;
      if (Array.isArray(top) && top.length > 0) return top;
    } catch {
      // ignore
    }

    // Fallback (no cache yet): minimal local calc from stored mistakes
    const byTopicWrong = {};
    (mistakes || []).forEach((m) => {
      const topic = m?.Topic || m?.topic;
      if (!topic) return;
      const wrong = Number(m?.attemptCount || 0);
      byTopicWrong[topic] = (byTopicWrong[topic] || 0) + wrong;
    });

    const totalByTopic = {};
    (questions || []).forEach((q) => {
      const topic = q?.Topic || q?.topic;
      if (!topic) return;
      totalByTopic[topic] = (totalByTopic[topic] || 0) + 1;
    });

    return Object.entries(byTopicWrong)
      .map(([topic, wrong]) => {
        const total = totalByTopic[topic] || 0;
        const density = total > 0 ? wrong / total : wrong;
        return { topic, score: wrong, total, density };
      })
      .sort((a, b) => b.density - a.density)
      .slice(0, 4);
  }, [mistakes, questions]);

  // ✅ REMOVED: No longer loading questions here - using prop instead
  // const { questions: allQuestions, loading: questionsLoading } = useQuizData(...)

  useEffect(() => {
    loadAttempts();
    loadMistakes();
    loadAIRecommendations();
  }, [currentUser]);

  async function loadAIRecommendations() {
    if (!currentUser?.uid) return;
    try {
      const recommendations = await performanceService.getRecommendations(currentUser.uid);
      setAIRecommendations(recommendations || []);
    } catch (e) {
      console.error('Error loading AI recommendations:', e);
      setAIRecommendations([]);
    }
  }

  async function handleAcceptRecommendation(recommendation, event) {
    event?.stopPropagation();
    if (!currentUser?.uid) return;
    try {
      await calendarServiceOptimized.createAIRecommendationEvent(currentUser.uid, recommendation);
      await loadAIRecommendations();
      setCalendarKey((prev) => prev + 1);
      alert(t('calendar.aiRecommendationAddedSuccess'));
    } catch (error) {
      console.error('❌ Error accepting recommendation:', error);
      alert(t('calendar.failedStartStudySessionTryAgain'));
    }
  }

  async function handleDismissRecommendation(recommendationId, event) {
    event?.stopPropagation();
    if (!currentUser?.uid) return;
    try {
      await performanceService.dismissRecommendation(currentUser.uid, recommendationId);
      await loadAIRecommendations();
    } catch (error) {
      console.error('Error dismissing recommendation:', error);
    }
  }

  async function loadAttempts() {
    if (!currentUser) { setLoading(false); return; }
    try {
      setError(null);
      setLoading(true);
      const userAttempts = await quizService.getUserAttempts(currentUser.uid, 200);
      setAttempts(userAttempts);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  function loadMistakes() {
    try {
      const loadedMistakes = loadMistakesFromStorage();
      setMistakes(loadedMistakes);
    } catch (err) {
      console.error('Error loading mistakes:', err);1
      setMistakes([]);
    }
  }

  async function handleLogout() {
    try { 
      await logout(); 
      navigate('/login'); 
    } catch (e) { 
      console.error(e); 
    }
  }

  function getDailyRewardKey(dateObj = new Date()) {
    const yyyy = dateObj.getFullYear();
    const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
    const dd = String(dateObj.getDate()).padStart(2, '0');
    return `daily_reward_${yyyy}-${mm}-${dd}`;
  }

  async function handleDailyReward() {
    if (!currentUser?.uid) return;
    const rewardKey = getDailyRewardKey(new Date());

    setDailyClaiming(true);
    setDailyClaimMessage(null);
    try {
      const check = await canClaimReward(currentUser.uid, rewardKey);
      if (!check?.canClaim) {
        setDailyClaimMessage(check?.message || 'Already claimed');
        setDailyClaiming(false);
        return;
      }

      const amount = 5;
      await awardTokens(currentUser.uid, amount, 'Daily Reward', {
        category: 'daily_reward',
        rewardKey
      });
      await recordRewardClaim(currentUser.uid, rewardKey, 24);
      setDailyClaimMessage(`+${amount} diamonds!`);
    } catch (e) {
      console.error(e);
      setDailyClaimMessage('Claim failed');
    }
    setDailyClaiming(false);
  }

  function handleEventCreated() {
    setCalendarKey(prev => prev + 1); // Force calendar reload
    setShowEventModal(false);
  }

  // ✅ FIXED: Check if questions are still loading
  if (loading || questions.length === 0) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-50">
        <ChemistryLoading persistKey="startup" />
      </div>
    );
  }

  return (
    <div className="space-y-6 p-4 wood-bg min-h-screen">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* HEADER */}
        <div className="flex justify-center">
          <div className="paper-island paper-island-lg paper-amber w-full">
            <div className="paper-island-content">
              <div className="flex justify-between items-start gap-6">
                <div className="min-w-0">
                  <h1 className="text-3xl sm:text-4xl font-black text-slate-900 mb-1 leading-tight tracking-tight bellmt-title ink-slate">
                    {t('dashboard.welcomeBack')}, {currentUser?.displayName}!
                  </h1>
                  <p className="text-sm sm:text-base text-slate-700 font-semibold truncate">{currentUser?.email}</p>
                </div>
                <div className="flex gap-3 flex-shrink-0">
                  <div className="flex flex-col items-end">
                    <button
                      type="button"
                      onClick={handleDailyReward}
                      disabled={dailyClaiming}
                      className="flex items-center gap-2 px-4 py-2 bg-chemistry-green text-white rounded-xl font-bold transition-all shadow-sm hover:opacity-95 disabled:bg-slate-300 disabled:cursor-not-allowed"
                    >
                      <Gift size={18} />
                      {dailyClaiming ? t('dashboard.claiming') : t('dashboard.dailyReward')}
                    </button>
                    {dailyClaimMessage && (
                      <div className="mt-1 text-xs font-bold text-slate-700">{dailyClaimMessage}</div>
                    )}
                  </div>
                  <button
                    onClick={() => setShowLogoutConfirm(true)}
                    className="flex items-center gap-2 px-4 py-2 bg-white/70 hover:bg-white text-slate-800 rounded-xl font-bold transition-all shadow-sm border border-white/60 hover:scale-[1.02] active:scale-[0.99]"
                  >
                    <LogOut size={18} />
                    {t('dashboard.logout')}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* ERROR DISPLAY */}
        {error && (
          <div className="bg-red-50 border-2 border-red-200 rounded-xl p-5">
            <div className="flex items-start gap-3">
              <AlertCircle className="text-red-600 flex-shrink-0 mt-1" size={20} />
              <div className="flex-1">
                <h3 className="font-bold text-red-900 mb-1">
                  {t('dashboard.errorLoadingAttempts')}
                </h3>
                <p className="text-sm text-red-800 mb-3">{error}</p>
                <button
                  onClick={loadAttempts}
                  className="flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg font-bold hover:bg-red-700 transition-all"
                >
                  <RefreshCw size={16} />
                  {t('dashboard.retry')}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* BENTO GRID */}
        <div className="grid grid-cols-1 lg:grid-cols-12 gap-6 auto-rows-[minmax(140px,auto)]">
          <div className="lg:col-span-12 lg:row-span-2">
            <div className="h-full bento-glass bento-glass-hover">
              <div className="bento-glass-content p-6">
                <SmartMonthlyCalendar
                  key={calendarKey}
                  userId={currentUser?.uid}
                  questions={questions}
                  onAddEvent={() => setShowEventModal(true)}
                  embedded
                />
              </div>
            </div>
          </div>

          <div className="lg:col-span-6">
            <div className="h-full bento-glass bento-glass-hover">
              <div className="bento-glass-content p-6 bg-gradient-to-br from-white/70 via-indigo-50/40 to-purple-50/50 rounded-2xl">
                <div className="flex items-center justify-between gap-3 mb-4">
                  <div className="flex items-center gap-2">
                    <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-100 to-purple-200 flex items-center justify-center shadow-sm">
                      <Brain className="text-indigo-600" size={22} />
                    </div>
                    <div className="min-w-0">
                      <h3 className="text-lg font-black text-slate-800 leading-tight">{t('dashboard.learningInsights')}</h3>
                      <div className="text-xs font-semibold text-slate-600 flex items-center gap-1">
                        <Sparkles size={12} className="text-indigo-600" />
                        <span className="truncate">{t('dashboard.startLearningJourney')}</span>
                      </div>
                    </div>
                  </div>
                  <button
                    onClick={() => navigate(notebookPath)}
                    className="flex items-center gap-1 px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold text-sm transition-all shadow-sm"
                  >
                    {t('dashboard.viewAll')}
                    <ChevronRight size={16} />
                  </button>
                </div>

                {mistakes.length === 0 ? (
                  <div className="space-y-4">
                    {/* Show features even without data */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2 mb-3">
                        <BarChart2 className="text-indigo-600" size={16} />
                        <span className="text-sm font-black text-slate-700">{t('dashboard.availableFeatures')}</span>
                      </div>
                      
                      <div 
                        onClick={() => navigate(notebookPath)}
                        className="p-3 bg-gradient-to-r from-indigo-50 to-blue-50 rounded-xl border border-indigo-200 hover:border-indigo-300 hover:shadow-sm transition-all cursor-pointer"
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <TrendingUp className="text-indigo-600" size={16} />
                            <div>
                              <div className="text-sm font-black text-indigo-800">{t('dashboard.learningAnalytics')}</div>
                              <div className="text-xs text-indigo-600">{t('dashboard.learningAnalyticsDesc')}</div>
                            </div>
                          </div>
                          <ChevronRight className="text-indigo-500" size={16} />
                        </div>
                      </div>

                      <div 
                        onClick={() => navigate(notebookPath)}
                        className="p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-xl border border-purple-200 hover:border-purple-300 hover:shadow-sm transition-all cursor-pointer"
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <Brain className="text-purple-600" size={16} />
                            <div>
                              <div className="text-sm font-black text-purple-800">{t('dashboard.mistakeDeckWithSRS')}</div>
                              <div className="text-xs text-purple-600">{t('dashboard.mistakeDeckWithSRSDesc')}</div>
                            </div>
                          </div>
                          <ChevronRight className="text-purple-500" size={16} />
                        </div>
                      </div>

                      <div 
                        onClick={() => navigate(notebookPath)}
                        className="p-3 bg-gradient-to-r from-green-50 to-emerald-50 rounded-xl border border-green-200 hover:border-green-300 hover:shadow-sm transition-all cursor-pointer"
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <Target className="text-green-600" size={16} />
                            <div>
                              <div className="text-sm font-black text-green-800">{t('dashboard.masteryArchiveSystem')}</div>
                              <div className="text-xs text-green-600">{t('dashboard.masteryArchiveSystemDesc')}</div>
                            </div>
                          </div>
                          <ChevronRight className="text-green-500" size={16} />
                        </div>
                      </div>

                      <div 
                        onClick={() => navigate(notebookPath)}
                        className="p-3 bg-gradient-to-r from-amber-50 to-orange-50 rounded-xl border border-amber-200 hover:border-amber-300 hover:shadow-sm transition-all cursor-pointer"
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <BarChart2 className="text-amber-600" size={16} />
                            <div>
                              <div className="text-sm font-black text-amber-800">{t('dashboard.progressTrackingCharts')}</div>
                              <div className="text-xs text-amber-600">{t('dashboard.progressTrackingChartsDesc')}</div>
                            </div>
                          </div>
                          <ChevronRight className="text-amber-500" size={16} />
                        </div>
                      </div>
                    </div>

                    {/* CTA Button */}
                    <button
                      onClick={() => navigate(notebookPath)}
                      className="w-full py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-xl font-bold hover:from-indigo-700 hover:to-purple-700 transition-all flex items-center justify-center gap-2 shadow-lg shadow-indigo-600/20"
                    >
                      <Brain size={18} />
                      {t('dashboard.exploreLearningNotebook')}
                    </button>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {/* Quick Stats */}
                    <div className="grid grid-cols-3 gap-3">
                      <div className="text-center p-3 bg-red-50 rounded-xl border border-red-100">
                        <div className="text-lg font-black text-red-600">{mistakes.length}</div>
                        <div className="text-xs text-red-600 font-semibold">{t('dashboard.totalMistakes')}</div>
                      </div>
                      <div className="text-center p-3 bg-amber-50 rounded-xl border border-amber-100">
                        <div className="text-lg font-black text-amber-600">{new Set(mistakes.map(m => m.Topic)).size}</div>
                        <div className="text-xs text-amber-600 font-semibold">{t('dashboard.topics')}</div>
                      </div>
                      <div className="text-center p-3 bg-green-50 rounded-xl border border-green-100">
                        <div className="text-lg font-black text-green-600">{mistakes.filter(m => m.attemptCount > 1).length}</div>
                        <div className="text-xs text-green-600 font-semibold">{t('dashboard.repeated')}</div>
                      </div>
                    </div>

                    {/* Top Topics to Focus */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2 mb-2">
                        <Target className="text-rose-600" size={16} />
                        <span className="text-sm font-black text-slate-700">{t('dashboard.topTopicsToFocus')}</span>
                      </div>
                      {topicsToFocus.slice(0, 3).map((item, idx) => (
                        <div
                          key={item.topic}
                          className="flex items-center justify-between p-3 bg-white rounded-xl border border-slate-200 hover:border-rose-300 hover:bg-rose-50 transition-all cursor-pointer"
                          onClick={() => navigate(notebookPath)}
                        >
                          <div className="flex items-center gap-3">
                            <div className="w-6 h-6 rounded-full bg-rose-100 flex items-center justify-center text-xs font-black text-rose-700">
                              {idx + 1}
                            </div>
                            <div>
                              <div className="text-sm font-black text-slate-800">{item.topic}</div>
                              <div className="text-xs text-slate-500">{item.wrong} {t('dashboard.mistakes')}</div>
                            </div>
                          </div>
                          <div className="text-right">
                            <div className="text-sm font-black text-rose-600">{item.density.toFixed(2)}</div>
                            <div className="text-xs text-slate-500">{t('dashboard.density')}</div>
                          </div>
                        </div>
                      ))}
                    </div>

                    {/* Learning Features Preview */}
                    <div className="pt-3 border-t border-slate-200">
                      <div className="flex items-center gap-2 mb-3">
                        <BarChart2 className="text-indigo-600" size={16} />
                        <span className="text-sm font-black text-slate-700">{t('dashboard.learningFeatures')}</span>
                      </div>
                      <div className="space-y-2">
                        <div 
                          onClick={() => navigate(notebookPath)}
                          className="p-3 bg-gradient-to-r from-indigo-50 to-blue-50 rounded-xl border border-indigo-200 hover:border-indigo-300 hover:shadow-sm transition-all cursor-pointer"
                        >
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                              <TrendingUp className="text-indigo-600" size={16} />
                              <div>
                                <div className="text-sm font-black text-indigo-800">{t('dashboard.learningAnalytics')}</div>
                                <div className="text-xs text-indigo-600">{t('dashboard.learningAnalyticsDesc')}</div>
                              </div>
                            </div>
                            <ChevronRight className="text-indigo-500" size={16} />
                          </div>
                        </div>

                        <div 
                          onClick={() => navigate(notebookPath)}
                          className="p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-xl border border-purple-200 hover:border-purple-300 hover:shadow-sm transition-all cursor-pointer"
                        >
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                              <Brain className="text-purple-600" size={16} />
                              <div>
                                <div className="text-sm font-black text-purple-800">{t('dashboard.mistakeDeckWithSRS')}</div>
                                <div className="text-xs text-purple-600">{t('dashboard.mistakeDeckWithSRSDesc')}</div>
                              </div>
                            </div>
                            <ChevronRight className="text-purple-500" size={16} />
                          </div>
                        </div>

                        <div 
                          onClick={() => navigate(notebookPath)}
                          className="p-3 bg-gradient-to-r from-green-50 to-emerald-50 rounded-xl border border-green-200 hover:border-green-300 hover:shadow-sm transition-all cursor-pointer"
                        >
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                              <Target className="text-green-600" size={16} />
                              <div>
                                <div className="text-sm font-black text-green-800">{t('dashboard.masteryArchiveSystem')}</div>
                                <div className="text-xs text-green-600">{t('dashboard.masteryArchiveSystemDesc')}</div>
                              </div>
                            </div>
                            <ChevronRight className="text-green-500" size={16} />
                          </div>
                        </div>

                        <div 
                          onClick={() => navigate(notebookPath)}
                          className="p-3 bg-gradient-to-r from-amber-50 to-orange-50 rounded-xl border border-amber-200 hover:border-amber-300 hover:shadow-sm transition-all cursor-pointer"
                        >
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                              <BarChart2 className="text-amber-600" size={16} />
                              <div>
                                <div className="text-sm font-black text-amber-800">{t('dashboard.progressTrackingCharts')}</div>
                                <div className="text-xs text-amber-600">{t('dashboard.progressTrackingChartsDesc')}</div>
                              </div>
                            </div>
                            <ChevronRight className="text-amber-500" size={16} />
                          </div>
                        </div>
                      </div>
                    </div>

                    {/* CTA Button */}
                    <button
                      onClick={() => navigate(notebookPath)}
                      className="w-full py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-xl font-bold hover:from-indigo-700 hover:to-purple-700 transition-all flex items-center justify-center gap-2 shadow-lg shadow-indigo-600/20"
                    >
                      <Brain size={18} />
                      {t('dashboard.openLearningNotebook')}
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>

          <div className="lg:col-span-6">
            <div className="h-full bento-glass bento-glass-hover">
              <div className="bento-glass-content p-6">
                <div className="space-y-3">
                  <div className="flex items-center justify-between gap-3">
                    <h3 className="text-lg font-black text-slate-800">{t('dashboard.priorityReviewAiStudySuggestionTitle')}</h3>
                    <button
                      type="button"
                      onClick={() => setShowAiSuggestionsInfo(true)}
                      className="w-9 h-9 rounded-full border-2 border-slate-200 hover:border-purple-300 hover:bg-purple-50 hover:scale-110 hover:shadow-md active:scale-95 transition-all duration-200 flex items-center justify-center text-purple-700"
                      title={t('dashboard.howThisWorks')}
                    >
                      <Info size={18} strokeWidth={2.5} />
                    </button>
                  </div>

                  {aiRecommendations.length > 0 ? (
                    <div className="p-4 rounded-xl bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200">
                      <div className="space-y-2">
                        {aiRecommendations.slice(0, 3).map((rec) => (
                          <div
                            key={rec.id}
                            className="bg-white rounded-lg p-3 border border-purple-200"
                          >
                            <div className="flex items-start justify-between">
                              <div className="flex-1">
                                <div className="flex items-center gap-2 mb-1">
                                  <span className={`px-2 py-0.5 rounded text-xs font-bold ${
                                    rec.priority === 'HIGH' ? 'bg-red-100 text-red-700' :
                                    rec.priority === 'MEDIUM' ? 'bg-amber-100 text-amber-700' :
                                    'bg-blue-100 text-blue-700'
                                  }`}>
                                    {rec.priority}
                                  </span>
                                  <span className="font-bold text-sm text-slate-800">
                                    {rec.subtopic}
                                  </span>
                                </div>
                                <p className="text-xs text-slate-600">{rec.reason}</p>
                                <div className="flex gap-2 mt-2 text-xs text-slate-500 flex-wrap">
                                  <span>📅 {t('calendar.suggestedLabel')}: {new Date(rec.suggestedDate).toLocaleDateString()}</span>
                                  <span>•</span>
                                  <span>📊 {t('calendar.currentLabel')}: {rec.currentAccuracy}%</span>
                                </div>
                              </div>

                              <div className="flex gap-1 ml-3">
                                <button
                                  onClick={(e) => handleAcceptRecommendation(rec, e)}
                                  className="p-2 bg-purple-100 hover:bg-purple-200 rounded-lg transition-all"
                                  title={t('calendar.addToCalendar')}
                                >
                                  👍
                                </button>
                                <button
                                  onClick={(e) => handleDismissRecommendation(rec.id, e)}
                                  className="p-2 bg-slate-100 hover:bg-slate-200 rounded-lg transition-all"
                                  title={t('calendar.dismiss')}
                                >
                                  👎
                                </button>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ) : (
                    <div className="p-6 rounded-xl border-2 border-slate-200 bg-slate-50 text-slate-600 text-sm font-semibold">
                      {t('dashboard.aiStudySuggestionsEmpty')}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          <div className="lg:col-span-12">
            <div className="h-full bento-glass bento-glass-hover">
              <div className="bento-glass-content p-6">
                <CompactAttemptsList
                  attempts={(attempts || []).slice(0, 10)}
                  onSelectAttempt={setSelectedAttempt}
                  loading={loading}
                  embedded
                />
              </div>
            </div>
          </div>
        </div>

        {null}

        {showAiSuggestionsInfo && (
          <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4" onClick={() => setShowAiSuggestionsInfo(false)}>
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-xl border-2 border-purple-200" onClick={(e) => e.stopPropagation()}>
              <div className="p-5 border-b-2 border-purple-200 flex items-center justify-between bg-purple-50">
                <div className="flex items-center gap-2">
                  <Sparkles size={20} className="text-purple-700" />
                  <h3 className="text-lg font-black text-slate-800">{t('calendar.aiSuggestionsByTopicTitle')}</h3>
                </div>
                <button type="button" onClick={() => setShowAiSuggestionsInfo(false)} className="p-2 hover:bg-white rounded-xl transition-all" aria-label={t('common.close')}>
                  <X size={20} />
                </button>
              </div>
              <div className="p-5 space-y-4">
                <div className="p-4 rounded-xl border-2 border-purple-200 bg-purple-50">
                  <p className="text-sm text-slate-700 leading-relaxed">
                    {t('calendar.aiSuggestionsByTopicDesc')}
                  </p>
                </div>

                <div className="space-y-2">
                  <h4 className="font-bold text-slate-800 text-sm">{t('dashboard.aiHowGeneratesTitle')}</h4>
                  <div className="p-3 rounded-lg bg-slate-50 border border-slate-200 text-xs text-slate-600">
                    {t('dashboard.aiHowGeneratesDesc')}
                  </div>
                </div>

                <div className="space-y-2">
                  <h4 className="font-bold text-slate-800 text-sm">{t('dashboard.aiPriorityLevelsTitle')}</h4>
                  <div className="flex gap-2 flex-wrap">
                    <span className="px-2 py-1 bg-red-100 text-red-700 rounded text-xs font-bold">{t('dashboard.priorityHigh')}</span>
                    <span className="px-2 py-1 bg-amber-100 text-amber-700 rounded text-xs font-bold">{t('dashboard.priorityMedium')}</span>
                    <span className="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-bold">{t('dashboard.priorityLow')}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Attempt Detail Modal */}
        {selectedAttempt && (
          <AttemptDetailModal
            attempt={selectedAttempt}
            onClose={() => setSelectedAttempt(null)}
          />
        )}

        {/* ✅ FIXED: Using questions prop */}
        {showEventModal && (
          <EventCreationModal
            userId={currentUser?.uid}
            questions={questions}
            onClose={() => setShowEventModal(false)}
            onEventCreated={handleEventCreated}
          />
        )}

        {/* Logout Confirmation Modal */}
        {showLogoutConfirm && (
          <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-in fade-in slide-in-from-bottom duration-200">
              <div className="p-6 border-b border-slate-200">
                <div className="flex items-center gap-3">
                  <div className="w-12 h-12 rounded-full bg-rose-100 flex items-center justify-center">
                    <LogOut className="text-rose-600" size={24} />
                  </div>
                  <div>
                    <h3 className="text-xl font-black text-slate-800">
                      {t('dashboard.confirmLogout')}
                    </h3>
                    <p className="text-sm text-slate-500">
                      {t('dashboard.areYouSureLogout')}
                    </p>
                  </div>
                </div>
              </div>
              <div className="p-6">
                <p className="text-slate-600 mb-6">
                  {t('dashboard.needSignInAgain')}
                </p>
                <div className="flex gap-3">
                  <button
                    onClick={() => setShowLogoutConfirm(false)}
                    className="flex-1 px-4 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-xl font-bold transition-all"
                  >
                    {t('dashboard.cancel')}
                  </button>
                  <button
                    onClick={handleLogout}
                    className="flex-1 px-4 py-3 bg-rose-500 hover:bg-rose-600 text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2"
                  >
                    <LogOut size={18} />
                    {t('dashboard.logout')}
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

========================================================================================================================
FILE: src/components/dashboard/PriorityReviewSection.jsx
------------------------------------------------------------------------------------------------------------------------
import React, { useMemo, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { AlertTriangle, Play, ArrowRight, Zap, X, Info } from 'lucide-react';
import { getTopMistakesByPriority, getMasteryState } from '../../utils/masteryHelper';
import { useLanguage } from '../../contexts/LanguageContext';

/**
 * PriorityReviewSection: Shows top 3 urgent mistakes based on ISRS priority
 * Displays with Quick Fix button to practice immediately
 */
export default function PriorityReviewSection({ mistakes, recentTopics = [], embedded = false }) {
  const navigate = useNavigate();
  const { t } = useLanguage();
  const topMistakes = useMemo(() => getTopMistakesByPriority(mistakes || [], recentTopics, 3), [mistakes, recentTopics]);
  const [showInfo, setShowInfo] = useState(false);

  if (!topMistakes || topMistakes.length === 0) {
    return (
      <div className={embedded ? 'h-full' : 'bg-gradient-to-br from-slate-50 to-slate-100 rounded-2xl shadow-lg border-2 border-slate-200 p-6'}>
        <div className="flex items-center gap-3 mb-4">
          <div className="w-12 h-12 rounded-xl bg-slate-200 flex items-center justify-center">
            <Zap className="text-slate-600" size={28} />
          </div>
          <h3 className="text-xl font-black text-slate-800">{t('dashboard.priorityReviewTitle')}</h3>
        </div>
        <p className="text-slate-600 text-center py-8">
          {t('dashboard.priorityReviewEmpty')}
        </p>
      </div>
    );
  }

  const handleQuickFix = (questionId) => {
    // Navigate to quiz engine with specific question
    navigate('/', { state: { focusQuestionId: questionId } });
  };

  return (
    <div className={embedded ? 'h-full' : 'bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6'}>
      {/* Header */}
      <div className="flex items-center justify-between gap-3 mb-6">
        <div className="w-12 h-12 rounded-xl bg-red-100 flex items-center justify-center">
          <AlertTriangle className="text-red-600" size={28} />
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="text-xl font-black text-slate-800">{t('dashboard.priorityReviewTitle')}</h3>
          <p className="text-xs text-slate-500 mt-1">{t('dashboard.top3UrgentMistakes')}</p>
        </div>
        <button
          type="button"
          onClick={() => setShowInfo(true)}
          className="w-9 h-9 rounded-xl border-2 border-slate-200 hover:border-red-300 hover:bg-red-50 transition-all flex items-center justify-center font-black text-red-700 hover:scale-110 active:scale-105"
          title={t('dashboard.howThisWorks')}
        >
          ?
        </button>
      </div>

      {showInfo && (
        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4" onClick={() => setShowInfo(false)}>
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-xl border-2 border-slate-200" onClick={(e) => e.stopPropagation()}>
            <div className="p-5 border-b-2 border-slate-200 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Info size={20} className="text-red-600" />
                <h3 className="text-lg font-black text-slate-800">{t('dashboard.priorityReviewMechanismTitle')}</h3>
              </div>
              <button type="button" onClick={() => setShowInfo(false)} className="p-2 hover:bg-slate-100 rounded-xl transition-all" aria-label={t('common.close')}>
                <X size={20} />
              </button>
            </div>
            <div className="p-5 space-y-3 text-sm text-slate-700">
              <p className="font-medium">
                {t('dashboard.priorityReviewMechanismDesc')}
              </p>
              <div className="space-y-2">
                <div>
                  <div className="font-black text-slate-800">{t('dashboard.whatIncreasesPriorityTitle')}</div>
                  <div className="text-slate-600 font-medium">{t('dashboard.whatIncreasesPriorityDesc')}</div>
                </div>
                <div>
                  <div className="font-black text-slate-800">{t('dashboard.whatQuickFixDoesTitle')}</div>
                  <div className="text-slate-600 font-medium">{t('dashboard.whatQuickFixDoesDesc')}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Mistakes List */}
      <div className="space-y-3">
        {topMistakes.map((mistake, index) => {
          const state = getMasteryState(mistake.correctCount || 0);
          const priority = mistake.masteryPriority || 0;
          const priorityLabel = priority > 8 ? t('dashboard.priorityCritical') : priority > 5 ? t('dashboard.priorityHigh') : t('dashboard.priorityMedium');
          const priorityColor = priority > 8 ? 'text-red-700 bg-red-50' : priority > 5 ? 'text-orange-700 bg-orange-50' : 'text-yellow-700 bg-yellow-50';

          return (
            <div
              key={mistake.questionId || index}
              className={`rounded-xl p-4 border-l-4 transition-all ${state.borderClass} ${state.bgClass}`}
            >
              {/* Top Row: Rank + Priority + Status */}
              <div className="flex items-start justify-between mb-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-bold text-slate-600">#{index + 1}</span>
                  <span className={`px-2 py-1 rounded-full text-xs font-bold ${priorityColor}`}>
                    {tf('dashboard.priorityLabel', { level: priorityLabel })}
                  </span>
                  <span className={`px-2 py-1 rounded-full text-xs font-bold ${state.badgeClass}`}>
                    {state.label}
                  </span>
                </div>
              </div>

              {/* Question Preview */}
              <div className="mb-3">
                <p className="text-sm font-semibold text-slate-700 line-clamp-2">
                  {mistake.Question || t('dashboard.questionTextNotAvailable')}
                </p>
                <div className="flex items-center gap-2 mt-2 text-xs text-slate-600">
                  <span className="font-bold text-slate-700">{mistake.Topic}</span>
                  {mistake.errorType && (
                    <>
                      <span>•</span>
                      <span className="capitalize">{mistake.errorType}</span>
                    </>
                  )}
                </div>
              </div>

              {/* Stats & Button */}
              <div className="flex items-center justify-between">
                <div className="flex gap-4 text-xs text-slate-600">
                  <span>{t('dashboard.attempts')}: <span className="font-bold">{mistake.attemptCount || 1}</span></span>
                  <span>{t('dashboard.correct')}: <span className="font-bold">{mistake.correctCount || 0}</span></span>
                </div>
                <button
                  onClick={() => handleQuickFix(mistake.questionId)}
                  className="flex items-center gap-2 px-3 py-2 bg-gradient-to-r from-red-500 to-orange-500 text-white rounded-lg font-bold text-sm hover:shadow-lg hover:from-red-600 hover:to-orange-600 transition-all active:scale-95"
                >
                  <Play size={14} />
                  {t('dashboard.quickFix')}
                </button>
              </div>
            </div>
          );
        })}
      </div>

      {/* CTA Footer */}
      <div className="mt-6 pt-4 border-t border-slate-200">
        <button
          onClick={() => navigate('/notebook')}
          className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-slate-100 hover:bg-slate-200 text-slate-800 rounded-xl font-bold transition-all"
        >
          {t('dashboard.viewFullMistakeNotebook')}
          <ArrowRight size={16} />
        </button>
      </div>
    </div>
  );
}

========================================================================================================================
FILE: src/components/dashboard/SpacedRepetitionModal.jsx
------------------------------------------------------------------------------------------------------------------------
import React, { useState, useMemo, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { X, Play, Eye, CheckSquare, Filter, Tag, Layers, ArrowRight, Timer, Zap } from 'lucide-react';
import { motion } from 'framer-motion';
import { srsService } from '../../services/srsService';
import { quizStorage } from '../../utils/quizStorage';
import { useLanguage } from '../../contexts/LanguageContext';
import { getNow } from '../../utils/timeTravel';

/**
 * SpacedRepetitionModal - COMPLETE ENHANCED VERSION with SRS Service
 * 
 * FEATURES:
 * ✅ Default: "5-Mistake Review" - AI selects 5 random questions
 * ✅ Question number selector (1 to all available)
 * ✅ Auto-select all topics → auto-select all subtopics → auto-select all questions
 * ✅ Timer and timed mode options for all review modes
 * ✅ Improved side-by-side topic/subtopic layout
 * ✅ Single question review option
 * ✅ Custom batch review with full filtering
 * ✅ SRS service integration for fetching due cards
 */
export default function SpacedRepetitionModal({ 
  userId,
  questions = [],
  initialCards = null,
  embedded = false,
  settingsOnly = false,
  maxCardsToLoad = 50,
  onClose, 
  onStartReview 
}) {
  const { t, tf } = useLanguage();
  const safeOnClose = typeof onClose === 'function' ? onClose : () => {};
  // Review modes: '5-mistake' (default), 'single', 'batch'
  const [reviewMode, setReviewMode] = useState('5-mistake');
  const [questionCount, setQuestionCount] = useState(10);
  const [selectedTopicFilters, setSelectedTopicFilters] = useState([]);
  const [selectedSubtopicFilters, setSelectedSubtopicFilters] = useState([]);
  const [allTopicsSelected, setAllTopicsSelected] = useState(true);
  const [allSubtopicsSelected, setAllSubtopicsSelected] = useState(true);
  const [enableTimer, setEnableTimer] = useState(true);
  const [timedMode, setTimedMode] = useState(true);
  const [dueCards, setDueCards] = useState([]);
  const [totalDueCount, setTotalDueCount] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedCardIds, setSelectedCardIds] = useState(new Set());
  const [overdueCount, setOverdueCount] = useState(0);
  const [batchFiltersVisuallyCleared, setBatchFiltersVisuallyCleared] = useState(false);

  const didInitTopicFiltersRef = useRef(false);
  const didInitSubtopicFiltersRef = useRef(false);

  const MAX_DUE_CARDS_TO_LOAD = Math.max(1, Number(maxCardsToLoad || 0) || 50);

  // Load due cards on mount
  useEffect(() => {
    if (Array.isArray(initialCards)) {
      const all = initialCards;
      setTotalDueCount(all.filter((c) => !c?.completed).length);
      setDueCards(all.slice(0, MAX_DUE_CARDS_TO_LOAD));
      setOverdueCount(0);
      setSelectedCardIds(new Set(all.slice(0, MAX_DUE_CARDS_TO_LOAD).map(card => card.id)));
      setError(null);
      setIsLoading(false);
      return;
    }

    setTotalDueCount(null);

    const loadDueCards = async () => {
      try {
        setIsLoading(true);
        const [cards, overdue] = await Promise.all([
          // Include due + overdue cards (<= today) so users always see what needs review.
          srsService.getDueCards(userId, getNow(), { limit: MAX_DUE_CARDS_TO_LOAD }),
          srsService.getOverdueCount(userId, getNow())
        ]);
        setDueCards(cards);
        setTotalDueCount(null);
        setOverdueCount(overdue);
        
        // Auto-select all cards initially for batch mode
        setSelectedCardIds(new Set(cards.map(card => card.id)));
      } catch (err) {
        console.error('Error loading due cards:', err);
        setError(t('srs.failedLoadDueCardsTryAgain'));
      } finally {
        setIsLoading(false);
      }
    };

    if (userId) {
      loadDueCards();
    }
  }, [userId, initialCards]);

  // Get all non-completed reviews
  const availableReviews = useMemo(() => {
    return dueCards.filter(card => !card.completed);
  }, [dueCards]);

  // Get unique topics
  const availableTopics = useMemo(() => {
    const topics = new Set();
    availableReviews.forEach(card => {
      if (card.topic) topics.add(card.topic);
    });
    return Array.from(topics).sort();
  }, [availableReviews]);

  const topicCounts = useMemo(() => {
    const counts = {};
    availableReviews.forEach((card) => {
      const k = card?.topic;
      if (!k) return;
      counts[k] = (counts[k] || 0) + 1;
    });
    return counts;
  }, [availableReviews]);

  // Get subtopics based on selected topics
  const availableSubtopics = useMemo(() => {
    const subtopics = new Set();
    availableReviews.forEach(card => {
      if (card.subtopic) {
        if (allTopicsSelected || selectedTopicFilters.includes(card.topic)) {
          subtopics.add(card.subtopic);
        }
      }
    });
    return Array.from(subtopics).sort();
  }, [availableReviews, selectedTopicFilters, allTopicsSelected]);

  const subtopicCounts = useMemo(() => {
    const counts = {};
    availableReviews.forEach((card) => {
      const k = card?.subtopic;
      if (!k) return;
      if (!(allTopicsSelected || selectedTopicFilters.includes(card.topic))) return;
      counts[k] = (counts[k] || 0) + 1;
    });
    return counts;
  }, [availableReviews, allTopicsSelected, selectedTopicFilters]);

  // Filtered reviews based on topic/subtopic selection
  const filteredReviews = useMemo(() => {
    return availableReviews.filter(card => {
      if (!allTopicsSelected && !selectedTopicFilters.includes(card.topic)) return false;
      if (!allSubtopicsSelected && !selectedSubtopicFilters.includes(card.subtopic)) return false;
      return true;
    });
  }, [availableReviews, selectedTopicFilters, selectedSubtopicFilters, allTopicsSelected, allSubtopicsSelected]);

  const batchHasNoSelectedCards = reviewMode === 'batch' && selectedCardIds.size === 0;
  const shouldVisuallyClearBatchFilters = reviewMode === 'batch' && batchFiltersVisuallyCleared && batchHasNoSelectedCards;

  // Group due cards by date for display
  const groupedByDate = useMemo(() => {
    const groups = {};
    filteredReviews.forEach(card => {
      const dueDate = new Date(card.nextReviewDate).toLocaleDateString();
      if (!groups[dueDate]) {
        groups[dueDate] = [];
      }
      groups[dueDate].push(card);
    });
    return groups;
  }, [filteredReviews]);

  // Default filters: ALL topics/subtopics on first load.
  useEffect(() => {
    if (!didInitTopicFiltersRef.current && availableTopics.length > 0) {
      didInitTopicFiltersRef.current = true;
      setAllTopicsSelected(true);
      setSelectedTopicFilters([]);
    }
  }, [availableTopics]);

  useEffect(() => {
    if (!didInitSubtopicFiltersRef.current && availableSubtopics.length > 0) {
      didInitSubtopicFiltersRef.current = true;
      setAllSubtopicsSelected(true);
      setSelectedSubtopicFilters([]);
    }
  }, [availableSubtopics]);

  // Adjust question count when filtered reviews change
  useEffect(() => {
    const len = filteredReviews.length;
    if (len <= 0) return;
    setQuestionCount((prev) => {
      const nextDefault = 10;
      if (prev == null || Number.isNaN(prev) || prev < 1) return Math.min(nextDefault, len);
      if (prev > len) return len;
      return prev;
    });
  }, [filteredReviews.length]);

  const toggleTopicFilter = (topic) => {
    if (shouldVisuallyClearBatchFilters) {
      setBatchFiltersVisuallyCleared(false);
      setAllTopicsSelected(false);
      setSelectedTopicFilters([topic]);
      return;
    }
    setSelectedTopicFilters((prev) => {
      const base = allTopicsSelected ? availableTopics : prev;
      const next = base.includes(topic) ? base.filter((t) => t !== topic) : [...base, topic];
      setAllTopicsSelected(false);
      return next;
    });
  };

  const toggleSubtopicFilter = (subtopic) => {
    if (shouldVisuallyClearBatchFilters) {
      setBatchFiltersVisuallyCleared(false);
      setAllSubtopicsSelected(false);
      setSelectedSubtopicFilters([subtopic]);
      return;
    }
    setSelectedSubtopicFilters((prev) => {
      const base = allSubtopicsSelected ? availableSubtopics : prev;
      const next = base.includes(subtopic) ? base.filter((s) => s !== subtopic) : [...base, subtopic];
      setAllSubtopicsSelected(false);
      return next;
    });
  };

  const toggleCardSelection = (cardId) => {
    if (batchFiltersVisuallyCleared) setBatchFiltersVisuallyCleared(false);
    setSelectedCardIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(cardId)) {
        newSet.delete(cardId);
      } else {
        newSet.add(cardId);
      }
      return newSet;
    });
  };

  const toggleAllCards = () => {
    const allFilteredSelected =
      filteredReviews.length > 0 && filteredReviews.every((card) => selectedCardIds.has(card.id));

    if (allFilteredSelected) {
      setSelectedCardIds(new Set());
      setBatchFiltersVisuallyCleared(true);
      return;
    }

    setSelectedCardIds(new Set(filteredReviews.map(card => card.id)));
    setBatchFiltersVisuallyCleared(false);
  };

  const selectTopicsUpTo = (targetTopic) => {
    const targetIndex = availableTopics.indexOf(targetTopic);
    if (targetIndex === -1) return;
    setSelectedTopicFilters(availableTopics.slice(0, targetIndex + 1));
  };

  const selectSubtopicsUpTo = (targetSubtopic) => {
    const targetIndex = availableSubtopics.indexOf(targetSubtopic);
    if (targetIndex === -1) return;
    setSelectedSubtopicFilters(availableSubtopics.slice(0, targetIndex + 1));
  };

  // Get random N questions from filtered reviews
  const getRandomQuestions = (count) => {
    const shuffled = [...filteredReviews].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, shuffled.length));
  };

  const handleStartReview = async () => {
    let selectedCards = [];
    
    if (reviewMode === '5-mistake') {
      selectedCards = getRandomQuestions(questionCount);
    } else if (reviewMode === 'single') {
      // For single question mode, use the first due card
      selectedCards = filteredReviews.slice(0, 1);
    } else { // batch
      if (settingsOnly) {
        selectedCards = getRandomQuestions(Math.min(questionCount, filteredReviews.length));
      } else {
        selectedCards = filteredReviews.filter(card => selectedCardIds.has(card.id));
      }
    }
    
    if (selectedCards.length === 0) {
      alert(t('srs.pleaseSelectAtLeastOne'));
      return;
    }

    // Persist SRS cards metadata for ResultsPage to submit back to SRS
    localStorage.setItem('quiz_mode', 'spaced-repetition');
    localStorage.setItem('quiz_srs_cards', JSON.stringify(selectedCards.map(card => ({
      id: card.id,
      questionId: card.questionId,
      interval: card.interval,
      easeFactor: card.easeFactor
    }))));

    const eventIds = selectedCards
      .map((c) => c.eventId)
      .filter(Boolean);
    if (eventIds.length > 0) {
      localStorage.setItem('quiz_event_ids', JSON.stringify(eventIds));
    } else {
      localStorage.removeItem('quiz_event_ids');
    }

    const questionIds = selectedCards.map(card => card.questionId);
    const selectedQuestions = questions.filter(q => questionIds.includes(q.ID));

    if (selectedQuestions.length === 0) {
      alert(t('srs.questionsStillLoading'));
      return;
    }

    quizStorage.clearQuizData();
    quizStorage.saveSelectedQuestions(selectedQuestions);
    localStorage.setItem('quiz_timer_enabled', String(enableTimer));
    localStorage.setItem('quiz_is_timed_mode', String(timedMode));
    localStorage.setItem('quiz_review_mode', reviewMode);

    if (typeof onStartReview === 'function') {
      onStartReview(reviewMode, questionIds);
      return;
    }

    window.location.href = '/quiz';
  };

  const effectiveQuestionCount = reviewMode === 'single' 
    ? 1 
    : reviewMode === 'batch'
    ? (settingsOnly ? Math.min(questionCount, filteredReviews.length) : selectedCardIds.size)
    : Math.min(questionCount, filteredReviews.length);

  const modalContent = isLoading ? (
    <div className={embedded ? "w-full" : "fixed inset-0 bg-black/50 z-[9999] flex items-center justify-center p-4"}>
      <div className={embedded ? "bg-white rounded-2xl p-8 shadow-lg border-2 border-slate-100" : "bg-white rounded-2xl p-8 shadow-2xl"}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600 mx-auto"></div>
        <p className="text-center mt-4 text-slate-600">{t('srs.loadingDueCards')}</p>
      </div>
    </div>
  ) : error ? (
    <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md mx-auto">
      <div className="text-red-600 text-center mb-4">⚠️</div>
      <p className="text-center text-red-600 font-semibold">{error}</p>
      {!embedded && (
        <button
            onClick={safeOnClose}
            className="mt-6 w-full px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded-lg font-semibold transition-all"
          >
            {t('common.close')}
          </button>
      )}
    </div>
  ) : (
    <div 
      className={embedded ? "w-full" : "fixed inset-0 bg-black/50 z-[9999] flex items-center justify-center p-4"}
      onClick={embedded ? undefined : safeOnClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        onClick={(e) => e.stopPropagation()}
        className={embedded
          ? "bg-white rounded-2xl shadow-lg border-2 border-slate-100 w-full overflow-hidden flex flex-col"
          : "bg-white rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col"}
      >
        {/* Header */}
        <div className="border-b p-6 flex justify-between items-center flex-shrink-0 bg-gradient-to-r from-purple-50 to-pink-50">
          <div>
            <h2 className="text-2xl font-black text-slate-800">{t('srs.title')}</h2>
            <p className="text-sm text-slate-600 mt-1">
              {totalDueCount != null
                ? tf('srs.questionsNeedReviewShownOutOfTotal', { shown: availableReviews.length, total: totalDueCount })
                : tf('srs.questionsNeedReviewCount', { count: availableReviews.length })}
            </p>
            {overdueCount > 0 && (
              <p className="text-xs text-red-600 font-bold mt-1">
                {tf('srs.overdueReviewsNotShown', { count: overdueCount, plural: overdueCount > 1 ? 's' : '' })}
              </p>
            )}
          </div>
          {!embedded && (
            <button onClick={safeOnClose} className="p-2 hover:bg-white/50 rounded-lg transition-all">
              <X size={24} />
            </button>
          )}
        </div>

        <div className="p-6 space-y-5 overflow-y-auto flex-1">
          {/* Review Mode Selector */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              {t('srs.reviewMode')}
            </label>
            <div className="grid grid-cols-3 gap-3">
              {/* Quick Review (5-Mistake Default) */}
              <button
                onClick={() => setReviewMode('5-mistake')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  reviewMode === '5-mistake' 
                    ? 'border-purple-500 bg-purple-50 shadow-lg' 
                    : 'border-slate-200 hover:border-purple-300'
                }`}
              >
                <div className="flex items-center gap-2 mb-2">
                  <Zap className={reviewMode === '5-mistake' ? 'text-purple-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${reviewMode === '5-mistake' ? 'text-purple-900' : 'text-slate-600'}`}>
                    {t('srs.quickReview')}
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  {t('srs.aiSelectsRandomQuestions')}
                </div>
                {reviewMode === '5-mistake' && (
                  <div className="mt-2 text-xs bg-purple-600 text-white px-2 py-1 rounded-full font-bold inline-block">
                    {t('srs.defaultBadge')}
                  </div>
                )}
              </button>

              {/* Single Question */}
              <button
                onClick={() => setReviewMode('single')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  reviewMode === 'single' 
                    ? 'border-purple-500 bg-purple-50 shadow-lg' 
                    : 'border-slate-200 hover:border-purple-300'
                }`}
              >
                <div className="flex items-center gap-2 mb-2">
                  <Eye className={reviewMode === 'single' ? 'text-purple-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${reviewMode === 'single' ? 'text-purple-900' : 'text-slate-600'}`}>
                    {t('srs.singleQuestion')}
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">{t('srs.reviewOneMistake')}</div>
              </button>

              {/* Custom Batch */}
              <button
                onClick={() => setReviewMode('batch')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  reviewMode === 'batch' 
                    ? 'border-purple-500 bg-purple-50 shadow-lg' 
                    : 'border-slate-200 hover:border-purple-300'
                }`}
              >
                <div className="flex items-center gap-2 mb-2">
                  <CheckSquare className={reviewMode === 'batch' ? 'text-purple-600' : 'text-slate-400'} size={20} />
                  <span className={`font-bold ${reviewMode === 'batch' ? 'text-purple-900' : 'text-slate-600'}`}>
                    {t('srs.customBatch')}
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">{t('srs.selectSpecificCards')}</div>
              </button>
            </div>
          </div>

          {/* Question Count Selector (for 5-mistake mode only) */}
          {reviewMode === '5-mistake' && (
            <div className="bg-gradient-to-r from-purple-50 to-pink-50 rounded-xl p-5 border-2 border-purple-200">
              <label className="block text-sm font-black text-purple-900 mb-3 flex items-center gap-2">
                <CheckSquare size={16} />
                {t('srs.numberOfQuestions')}
              </label>
              <div className="flex items-center gap-4 mb-3">
                <input
                  type="range"
                  min="1"
                  max={Math.max(1, filteredReviews.length)}
                  value={questionCount}
                  onChange={(e) => setQuestionCount(parseInt(e.target.value))}
                  className="flex-1 h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer accent-purple-600"
                />
                <div className="flex items-center gap-2">
                  <input
                    type="number"
                    min="1"
                    max={Math.max(1, filteredReviews.length)}
                    value={questionCount}
                    onChange={(e) => setQuestionCount(Math.max(1, Math.min(parseInt(e.target.value) || 1, filteredReviews.length)))}
                    className="w-20 px-3 py-2 border-2 border-purple-300 rounded-lg font-bold text-center text-purple-900 bg-white"
                  />
                  <span className="text-sm text-purple-700 font-semibold whitespace-nowrap">
                    / {filteredReviews.length}
                  </span>
                </div>
              </div>
              <div className="flex gap-2 flex-wrap">
                <button 
                  onClick={() => setQuestionCount(5)} 
                  className="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 rounded-lg text-xs font-bold border border-purple-200 transition-all"
                >
                  {tf('srs.nQuestions', { count: 5 })}
                </button>
                <button 
                  onClick={() => setQuestionCount(10)} 
                  className="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 rounded-lg text-xs font-bold border border-purple-200 transition-all"
                >
                  {tf('srs.nQuestions', { count: 10 })}
                </button>
                <button 
                  onClick={() => setQuestionCount(filteredReviews.length)} 
                  className="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 rounded-lg text-xs font-bold border border-purple-200 transition-all"
                >
                  {tf('srs.allCount', { count: filteredReviews.length })}
                </button>
              </div>
            </div>
          )}

          {reviewMode === 'batch' && settingsOnly && (
            <div className="bg-gradient-to-r from-indigo-50 to-blue-50 rounded-xl p-5 border-2 border-indigo-200">
              <label className="block text-sm font-black text-indigo-900 mb-3 flex items-center gap-2">
                <CheckSquare size={16} />
                {t('srs.numberOfQuestions')}
              </label>
              <div className="flex items-center gap-4 mb-3">
                <input
                  type="range"
                  min="1"
                  max={Math.max(1, filteredReviews.length)}
                  value={Math.min(questionCount, Math.max(1, filteredReviews.length))}
                  onChange={(e) => setQuestionCount(parseInt(e.target.value))}
                  className="flex-1 h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer"
                />
                <div className="bg-white px-4 py-2 rounded-lg border border-indigo-200 font-black text-indigo-900 min-w-[80px] text-center">
                  {Math.min(questionCount, filteredReviews.length)}
                </div>
              </div>
              <p className="text-xs text-indigo-700 font-semibold">
                {tf('srs.questionsNeedReviewShownOutOfTotal', { shown: Math.min(questionCount, filteredReviews.length), total: filteredReviews.length })}
              </p>
            </div>
          )}

          {/* Timer Settings */}
          <div className="bg-blue-50 rounded-xl p-5 border-2 border-blue-200">
            <div className="flex items-center gap-2 mb-4">
              <Timer className="text-blue-600" size={20} />
              <h3 className="font-black text-blue-900">{t('srs.timerSettings')}</h3>
            </div>
            
            <div className="space-y-3">
              {/* Enable Timer */}
              <button
                onClick={() => setEnableTimer(!enableTimer)}
                className={`w-full px-4 py-3 rounded-lg border-2 transition-all flex items-center gap-3 ${
                  enableTimer 
                    ? 'bg-blue-100 border-blue-500' 
                    : 'bg-white border-slate-200'
                }`}
              >
                <div className={`w-5 h-5 rounded border-2 flex items-center justify-center flex-shrink-0 ${
                  enableTimer ? 'border-blue-600 bg-blue-600' : 'border-slate-300'
                }`}>
                  {enableTimer && (
                    <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                    </svg>
                  )}
                </div>
                <span className={`font-bold flex-1 text-left ${enableTimer ? 'text-blue-900' : 'text-slate-600'}`}>
                  {t('srs.showTimer')}
                </span>
                {enableTimer && (
                  <span className="text-xs bg-white px-2 py-1 rounded font-bold text-blue-700">{t('common.on')}</span>
                )}
              </button>

              {/* Timed Mode */}
              <button
                onClick={() => setTimedMode(!timedMode)}
                disabled={!enableTimer}
                className={`w-full px-4 py-3 rounded-lg border-2 transition-all flex items-center gap-3 ${
                  timedMode && enableTimer
                    ? 'bg-amber-100 border-amber-500' 
                    : 'bg-white border-slate-200'
                } ${!enableTimer ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                <div className={`w-5 h-5 rounded border-2 flex items-center justify-center flex-shrink-0 ${
                  timedMode && enableTimer ? 'border-amber-600 bg-amber-600' : 'border-slate-300'
                }`}>
                  {timedMode && enableTimer && (
                    <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                    </svg>
                  )}
                </div>
                <span className={`font-bold flex-1 text-left ${timedMode && enableTimer ? 'text-amber-900' : 'text-slate-600'}`}>
                  {t('srs.timedMode75sPerQuestion')}
                </span>
                {timedMode && enableTimer && (
                  <span className="text-xs bg-white px-2 py-1 rounded font-bold text-amber-700">⏱️ {t('common.on')}</span>
                )}
              </button>

              <p className="text-xs text-blue-700 italic pl-8">
                💡 {timedMode && enableTimer 
                  ? t('srs.mustAnswerWithin75SecondsPerQuestion') 
                  : enableTimer 
                  ? t('srs.timerTracksSpeedNoLimit') 
                  : t('srs.noTimerTracking')}
              </p>
            </div>
          </div>
          {/* Batch Review - Card Selection */}
          {reviewMode === 'batch' && !settingsOnly && (
            <div className="bg-white rounded-xl p-6 border-2 border-slate-200">
              <div className="flex items-center gap-3 mb-4">
                <Filter size={18} className="text-slate-600" />
                <h3 className="font-black text-slate-800">{t('srs.selectCardsToReview')}</h3>
                <span className="ml-auto text-xs bg-white px-3 py-1 rounded-full font-bold text-slate-600 border border-slate-200">
                  {tf('srs.selectedCountOutOfTotal', { selected: selectedCardIds.size, total: filteredReviews.length })}
                </span>
              </div>
              
              {/* Select All Button */}
              <div className="mb-4 flex justify-between items-center">
                <button
                  onClick={toggleAllCards}
                  className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold text-sm transition-all flex items-center gap-2"
                >
                  <CheckSquare size={16} />
                  {selectedCardIds.size === filteredReviews.length ? t('srs.deselectAll') : t('srs.selectAll')}
                </button>
                
                {/* Topic/Subtopic Filters */}
                <div className="flex gap-3 items-start">
                  <div className="w-[360px] h-[190px] flex flex-col">
                    <div className="flex items-center justify-between mb-1">
                      <div className="flex items-center gap-2 text-xs font-black text-slate-700 uppercase tracking-wider">
                        <Tag size={14} className="text-slate-500" />
                        {tf('calendar.topicsCount', { selected: shouldVisuallyClearBatchFilters ? 0 : (allTopicsSelected ? availableTopics.length : selectedTopicFilters.length), total: availableTopics.length })}
                      </div>
                      <div className="flex items-center gap-2">
                        <button
                          type="button"
                          onClick={() => {
                            setAllTopicsSelected(true);
                            setSelectedTopicFilters([]);
                            setBatchFiltersVisuallyCleared(false);
                          }}
                          disabled={availableTopics.length === 0}
                          className={`text-[11px] font-black ${availableTopics.length === 0 ? 'text-slate-300 cursor-not-allowed' : 'text-indigo-700 hover:text-indigo-900'}`}
                        >
                          {t('common.selectAll')}
                        </button>
                        <button
                          type="button"
                          onClick={() => {
                            setAllTopicsSelected(false);
                            setSelectedTopicFilters([]);
                            setBatchFiltersVisuallyCleared(false);
                          }}
                          disabled={!allTopicsSelected && selectedTopicFilters.length === 0}
                          className={`text-[11px] font-black ${(!allTopicsSelected && selectedTopicFilters.length === 0) ? 'text-slate-300 cursor-not-allowed' : 'text-slate-500 hover:text-slate-700'}`}
                        >
                          {t('common.clear')}
                        </button>
                      </div>
                    </div>

                    <div className="flex flex-wrap gap-2 flex-1 min-h-0 overflow-auto pr-1">
                      {availableTopics.map(topic => (
                        <button
                          key={topic}
                          onClick={() => toggleTopicFilter(topic)}
                          className={`px-3 py-2 rounded-lg text-sm font-bold transition-all whitespace-nowrap flex items-center gap-2 ${
                            allTopicsSelected
                              ? 'bg-white text-slate-600 border border-slate-200 hover:bg-slate-50'
                              : selectedTopicFilters.includes(topic)
                                ? 'bg-indigo-600 text-white shadow-md'
                                : 'bg-white text-slate-600 border border-slate-200 hover:bg-slate-50'
                          }`}
                        >
                          {topic}
                          <span className={`text-xs px-2 py-0.5 rounded-full font-black ${
                            (!allTopicsSelected && selectedTopicFilters.includes(topic)) ? 'bg-white/20 text-white' : 'bg-slate-100 text-slate-700'
                          }`}
                          >
                            {topicCounts[topic] || 0}
                          </span>
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="w-[360px] h-[190px] flex flex-col">
                    <div className="flex items-center justify-between mb-1">
                      <div className="flex items-center gap-2 text-xs font-black text-slate-700 uppercase tracking-wider">
                        <Layers size={14} className="text-slate-500" />
                        {tf('calendar.subtopicsCount', { selected: shouldVisuallyClearBatchFilters ? 0 : (allSubtopicsSelected ? availableSubtopics.length : selectedSubtopicFilters.length), total: availableSubtopics.length })}
                      </div>
                      <div className="flex items-center gap-2">
                        <button
                          type="button"
                          onClick={() => {
                            setAllSubtopicsSelected(true);
                            setSelectedSubtopicFilters([]);
                            setBatchFiltersVisuallyCleared(false);
                          }}
                          disabled={availableSubtopics.length === 0}
                          className={`text-[11px] font-black ${availableSubtopics.length === 0 ? 'text-slate-300 cursor-not-allowed' : 'text-purple-700 hover:text-purple-900'}`}
                        >
                          {t('common.selectAll')}
                        </button>
                        <button
                          type="button"
                          onClick={() => {
                            setAllSubtopicsSelected(false);
                            setSelectedSubtopicFilters([]);
                            setBatchFiltersVisuallyCleared(false);
                          }}
                          disabled={!allSubtopicsSelected && selectedSubtopicFilters.length === 0}
                          className={`text-[11px] font-black ${(!allSubtopicsSelected && selectedSubtopicFilters.length === 0) ? 'text-slate-300 cursor-not-allowed' : 'text-slate-500 hover:text-slate-700'}`}
                        >
                          {t('common.clear')}
                        </button>
                      </div>
                    </div>

                    <div className="flex flex-wrap gap-2 flex-1 min-h-0 overflow-auto pr-1">
                      {availableSubtopics.map(subtopic => (
                        <button
                          key={subtopic}
                          onClick={() => toggleSubtopicFilter(subtopic)}
                          className={`px-3 py-2 rounded-lg text-sm font-bold transition-all whitespace-nowrap flex items-center gap-2 ${
                            allSubtopicsSelected
                              ? 'bg-white text-slate-600 border border-slate-200 hover:bg-slate-50'
                              : selectedSubtopicFilters.includes(subtopic)
                                ? 'bg-purple-600 text-white shadow-md'
                                : 'bg-white text-slate-600 border border-slate-200 hover:bg-slate-50'
                          }`}
                        >
                          {subtopic}
                          <span className={`text-xs px-2 py-0.5 rounded-full font-black ${
                            (!allSubtopicsSelected && selectedSubtopicFilters.includes(subtopic)) ? 'bg-white/20 text-white' : 'bg-slate-100 text-slate-700'
                          }`}
                          >
                            {subtopicCounts[subtopic] || 0}
                          </span>
                        </button>
                      ))}
                      {availableSubtopics.length === 0 && (
                        <div className="text-xs text-slate-500">{t('calendar.noSubtopicsAvailable')}</div>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              {/* Cards Grouped by Date */}
              <div className="space-y-4 max-h-96 overflow-y-auto">
                {Object.entries(groupedByDate).map(([date, cards]) => (
                  <div key={date} className="border-2 border-slate-200 rounded-lg overflow-hidden">
                    <div className="bg-slate-100 px-4 py-2 font-bold text-sm text-slate-700">
                      {t('srs.dueLabel')}: {date}
                    </div>
                    <div className="divide-y divide-slate-200">
                      {cards.map(card => (
                        <div
                          key={card.id}
                          onClick={() => toggleCardSelection(card.id)}
                          className={`px-4 py-3 flex items-center gap-3 cursor-pointer transition-all ${
                            selectedCardIds.has(card.id) ? 'bg-indigo-50' : 'hover:bg-slate-50'
                          }`}
                        >
                          <div className={`w-5 h-5 rounded border-2 flex items-center justify-center flex-shrink-0 ${
                            selectedCardIds.has(card.id)
                              ? 'border-indigo-600 bg-indigo-600'
                              : 'border-slate-300'
                          }`}>
                            {selectedCardIds.has(card.id) && (
                              <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                              </svg>
                            )}
                          </div>
                          
                          <div className="flex-1">
                            <div className="flex items-center gap-2 mb-1">
                              <span className="px-2 py-0.5 bg-indigo-100 text-indigo-700 rounded text-xs font-bold">
                                {card.topic || t('srs.noTopic')}
                              </span>
                              {card.subtopic && (
                                <>
                                  <span className="text-slate-400">→</span>
                                  <span className="px-2 py-0.5 bg-purple-100 text-purple-700 rounded text-xs font-bold">
                                    {card.subtopic}
                                  </span>
                                </>
                              )}
                            </div>
                            
                            <div 
                              className="text-sm text-slate-600 line-clamp-2"
                              dangerouslySetInnerHTML={{ 
                                __html: `${t('srs.questionIdLabel')}: ${card.questionId}<span class=\"text-slate-400\"> (${t('srs.questionIdHelp')})</span>` 
                              }}
                            />
                            
                            <div className="flex gap-4 mt-2 text-xs text-slate-500">
                              <span>📅 {t('srs.intervalLabel')}: {card.interval}</span>
                              <span>🔄 {t('srs.attemptLabel')}: {card.attemptNumber || 1}</span>
                              <span>⭐ {t('srs.easeLabel')}: {card.easeFactor?.toFixed(2) || '2.50'}</span>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
                
                {filteredReviews.length === 0 && (
                  <div className="text-center py-12">
                    <p className="text-slate-500">{t('srs.noDueCardsMatchFilters')}</p>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Footer - Start Review Button */}
        <div className="border-t p-6 flex-shrink-0 bg-slate-50">
          <button
            onClick={handleStartReview}
            disabled={effectiveQuestionCount === 0}
            className="w-full px-6 py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white rounded-xl font-black transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg text-lg"
          >
            <Play size={22} fill="currentColor" />
            {reviewMode === '5-mistake' 
              ? tf('srs.startQuickReviewCount', { count: effectiveQuestionCount })
              : reviewMode === 'single'
              ? t('srs.startSingleReview')
              : tf('srs.startBatchReviewCount', { count: effectiveQuestionCount })}
          </button>
          
          {/* Settings Summary */}
          <div className="text-center mt-3 text-xs text-slate-600 flex items-center justify-center gap-3 flex-wrap">
            {enableTimer && (
              <span className="flex items-center gap-1">
                <Timer size={12} />
                {timedMode ? t('srs.timedModeSummary75') : t('srs.timerTrackingEnabled')}
              </span>
            )}
            {!enableTimer && <span className="text-slate-400">{t('srs.noTimer')}</span>}
          </div>
        </div>
      </motion.div>
    </div>
  );

  if (embedded) return modalContent;
  return createPortal(modalContent, document.body);
}

========================================================================================================================
FILE: src/App_Final.jsx
------------------------------------------------------------------------------------------------------------------------
import React from 'react';
import ForumPage from './pages/ForumPage';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { LanguageProvider } from './contexts/LanguageContext';
import PrivateRoute from './components/PrivateRoute';
import Header from './components/Header';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage_Fixed';
import TopicSelectionPage from './pages/TopicSelectionPage_Updated';
import PracticeModeSelection from './pages/PracticeModeSelection';
import QuizPage from './pages/QuizPage';
import ResultsPage from './pages/ResultsPage_Updated_Fixed';
import MillionaireQuiz from './pages/MillionaireQuiz';
import LeaderboardPage from './pages/LeaderboardPage';
import ProfilePage from './pages/ProfilePage';
import HistoryPage from './pages/HistoryPage_Fixed';
import MistakeNotebookPage from './pages/MistakeNotebookPage';
import FirebaseTestPage from './pages/FirebaseTestPage';
import DebugDashboard from './pages/DebugDashboard';
import SRSReviewPage from './pages/SRSReviewPage';
import { useQuizData } from './hooks/useQuizData';
import ChemistryLoading from './components/ChemistryLoading';
import ChemStore from './components/ChemStore';
import TokenLog from './components/TokenLog';

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTK36yaUN-NMCkQNT-DAHgc6FMZPjUc0Yv3nYEK4TA9W2qE9V1TqVD10Tq98-wXQoAvKOZlwGWRSDkU/pub?gid=1182550140&single=true&output=csv';

function AppContent() {
  const location = useLocation();
  const { questions, loading, error } = useQuizData(SHEET_URL);
  const isNotebookRoute = location.pathname === '/notebook';
  const noShellRoutes = new Set(['/dashboard', '/login', '/register', '/millionaire']);
  const useNoShell = noShellRoutes.has(location.pathname);
  const hideHeaderRoutes = new Set(['/login', '/register', '/millionaire']);
  const showHeader = !hideHeaderRoutes.has(location.pathname);

  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <ChemistryLoading persistKey="startup" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <div className="text-center bg-white p-8 rounded-2xl shadow-xl border-2 border-red-200">
          <p className="text-red-500 font-bold mb-2">Error loading questions</p>
          <p className="text-academic-slate">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <>
      {showHeader && <Header />}
      <div className={useNoShell ? '' : isNotebookRoute ? '' : 'container mx-auto px-4 py-6'}>
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />

          {/* Protected Routes */}
          {/* ✅ FIXED: Now passes questions prop to DashboardPage */}
          <Route
            path="/dashboard"
            element={
              <PrivateRoute>
                <DashboardPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/"
            element={
              <PrivateRoute>
                <Navigate to="/dashboard" replace />
              </PrivateRoute>
            }
          />

          {/* Practice Mode Selection */}
          <Route
            path="/practice"
            element={
              <PrivateRoute>
                <PracticeModeSelection questions={questions} />
              </PrivateRoute>
            }
          />

          <Route
            path="/srs-review"
            element={
              <PrivateRoute>
                <SRSReviewPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          {/* Legacy Topic Selection */}
          <Route
            path="/topics"
            element={
              <PrivateRoute>
                <TopicSelectionPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/quiz"
            element={
              <PrivateRoute>
                <QuizPage />
              </PrivateRoute>
            }
          />

          <Route
            path="/millionaire"
            element={
              <PrivateRoute>
                <MillionaireQuiz questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/results"
            element={
              <PrivateRoute>
                <ResultsPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/leaderboard"
            element={
              <PrivateRoute>
                <LeaderboardPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/profile"
            element={
              <PrivateRoute>
                <ProfilePage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/history"
            element={
              <PrivateRoute>
                <HistoryPage />
              </PrivateRoute>
            }
          />
          
          {/* Mistake Notebook - NEW */}
          <Route
            path="/notebook"
            element={
              <PrivateRoute>
                <MistakeNotebookPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/forum"
            element={
              <PrivateRoute>
                <ForumPage />
              </PrivateRoute>
            }
          />

          {/* ChemStore - FIXED: Now inside Routes */}
          <Route
            path="/store"
            element={
              <PrivateRoute>
                <ChemStore />
              </PrivateRoute>
            }
          />

          {/* Token Log - FIXED: Now inside Routes */}
          <Route
            path="/token-log"
            element={
              <PrivateRoute>
                <TokenLog />
              </PrivateRoute>
            }
          />

          {/* Firebase Test Page - for debugging */}
          <Route
            path="/test-firebase"
            element={
              <PrivateRoute>
                <FirebaseTestPage />
              </PrivateRoute>
            }
          />
          
          {/* Debug Dashboard - comprehensive diagnostics */}
          <Route
            path="/debug"
            element={
              <PrivateRoute>
                <DebugDashboard />
              </PrivateRoute>
            }
          />

          {/* Catch all - redirect to dashboard */}
          <Route path="*" element={<Navigate to="/dashboard" replace />} />
        </Routes>
      </div>
    </>
  );
}

function AppShell() {
  const location = useLocation();
  const noShellRoutes = new Set(['/dashboard', '/login', '/register']);
  const useNoShell = noShellRoutes.has(location.pathname);

  return (
    <div className={useNoShell ? 'min-h-screen' : 'min-h-screen bg-gray-50'}>
      <AppContent />
    </div>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AuthProvider>
        <Router>
          <AppShell />
        </Router>
      </AuthProvider>
    </LanguageProvider>
  );
}

========================================================================================================================
NOTEBOOK: ISRS_Refactoring_Guide.ipynb
------------------------------------------------------------------------------------------------------------------------
CELL 0 [markdown]
## Implementation Checklist & Next Steps

### Phase 1: Dependencies & Setup
- [ ] Install `@floating-ui/react` and `recharts`: `npm install @floating-ui/react recharts`
- [ ] Update imports in MistakeNotebookPage.jsx
- [ ] Add new helper functions (calculateMasteryPriority, getMasteryState, etc.)

### Phase 2: Core Features
- [ ] Replace SmartTooltip with TooltipWithPortal (Floating UI)
- [ ] Implement ISRS priority scoring
- [ ] Add Rule of 3 archiving logic
- [ ] Create CalendarHeatmap component
- [ ] Create TopicHeatmap and ImprovementTrendChart components

### Phase 3: UI Integration
- [ ] Add "AI Daily Mission" button (uses selectAIDailyMission)
- [ ] Add Error Type tagging dropdown for each mistake
- [ ] Add ErrorTagSelector component to mistake cards
- [ ] Update filter UI for nested topic/subtopic selection
- [ ] Integrate CalendarHeatmap in main render
- [ ] Integrate Learning Analytics Dashboard

### Phase 4: State Management & Persistence
- [ ] Add state variables for errorTags, archivedMistakes, recentQuizTopics
- [ ] Implement useEffect hooks for localStorage sync
- [ ] Implement useMemo for performance optimization
- [ ] Test Rule of 3 archiving workflow

### Phase 5: Testing & Refinement
- [ ] Test ISRS score calculation with various attempt counts
- [ ] Verify tooltip edge detection and flipping
- [ ] Test interleaved practice selection (≥3 topics)
- [ ] Verify localStorage persistence across sessions
- [ ] Test i18n integration for all new text

### Key i18n Keys to Add
```javascript
{
  notebook: {
    aiDailyMission: "AI Daily Mission",
    mistakeClearingActivity: "30-Day Mistake-Clearing Activity",
    errorDensityByTopic: "Error Density by Topic",
    improvementTrend: "Improvement Trend",
    tagError: "Tag Error Type",
    less: "Less",
    more: "More"
  }
}
```

### Performance Considerations
- **useMemo**: Wrap ISRS priority calculations (depends on: mistakes, recentQuizTopics)
- **useMemo**: Wrap error density map (depends on: mistakes)
- **useMemo**: Wrap activity heatmap data (depends on: improvements)
- **Debounce**: Filter changes to prevent excessive re-calculations
- **Lazy Load**: Consider lazy-loading chart components if performance degrades

### localStorage Schema
```javascript
{
  "mistake_improvements": { // existing
    "question_id": { correctCount, lastCorrect, ... }
  },
  "mistake_archive": { // new
    "question_id": { correctCount, lastCorrect, archivedAt, ... }
  },
  "mistake_error_tags": { // new
    "question_id": "calculation" // error type
  },
  "recent_quiz_topics": [ // new
    "Topic1", "Topic2", "Topic3"
  ]
}
```

CELL 1 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 8. MAIN COMPONENT STATE VARIABLES & HOOKS
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Key state variables to add to MistakeNotebookPage component:
 */

// Existing:
// const [mistakes, setMistakes] = useState([]);
// const [improvements, setImprovements] = useState({});
// const [selectedTopics, setSelectedTopics] = useState([]);
// const [selectedSubtopics, setSelectedSubtopics] = useState([]);

// NEW:
const [errorTags, setErrorTags] = useState(() => 
  JSON.parse(localStorage.getItem('mistake_error_tags') || '{}')
);

const [archivedMistakes, setArchivedMistakes] = useState(() =>
  JSON.parse(localStorage.getItem('mistake_archive') || '{}')
);

const [recentQuizTopics, setRecentQuizTopics] = useState(() =>
  JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]')
);

// ───────────────────────────────────────────────────────────────────────────────

/**
 * KEY EFFECTS TO ADD:
 */

// Sync error tags to localStorage
useEffect(() => {
  localStorage.setItem('mistake_error_tags', JSON.stringify(errorTags));
}, [errorTags]);

// Apply Rule of 3 archiving on improvements change
useEffect(() => {
  const updated = applyRuleOfThree(improvements);
  if (Object.keys(updated).length !== Object.keys(improvements).length) {
    setImprovements(updated);
  }
}, [improvements]);

// Track recent quiz topics for context boost
useEffect(() => {
  const recent = JSON.parse(localStorage.getItem('quiz_history') || '[]')
    .slice(0, 3)
    .map(q => q.Topic);
  setRecentQuizTopics(recent);
  localStorage.setItem('recent_quiz_topics', JSON.stringify(recent));
}, []);

// ───────────────────────────────────────────────────────────────────────────────

/**
 * MEMOIZED CALCULATIONS: Performance optimization
 */

const prioritizedMistakes = useMemo(() => {
  return mistakes
    .map(m => ({
      ...m,
      masteryPriority: calculateMasteryPriority(m),
      masteryState: getMasteryState(m.improvementCount ?? 0)
    }))
    .sort((a, b) => b.masteryPriority - a.masteryPriority);
}, [mistakes, recentQuizTopics]); // Re-calc when quiz history changes

const errorDensityMap = useMemo(() => {
  const map = {};
  mistakes.forEach(m => {
    if (!map[m.Topic]) map[m.Topic] = { errors: 0, total: 0 };
    map[m.Topic].total += m.attemptCount || 1;
    map[m.Topic].errors++;
  });
  return map;
}, [mistakes]);

CELL 2 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 7. METACOGNITIVE ERROR TAGGING SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════

const ERROR_TYPES = [
  { value: 'misread', label: 'Misread Question', color: 'blue' },
  { value: 'calculation', label: 'Calculation Error', color: 'red' },
  { value: 'conceptual', label: 'Conceptual Gap', color: 'orange' },
  { value: 'careless', label: 'Careless Mistake', color: 'yellow' },
  { value: 'vocab', label: 'Vocabulary Gap', color: 'purple' },
  { value: 'diagram', label: 'Diagram Misread', color: 'pink' },
];

/**
 * ErrorTagSelector: Dropdown to assign error type to a mistake
 */
function ErrorTagSelector({ questionId, currentTag, onTag }) {
  const { t } = useLanguage();
  const [open, setOpen] = useState(false);
  
  return (
    <div className="relative">
      <button
        onClick={() => setOpen(!open)}
        className={`px-3 py-1.5 rounded-lg text-xs font-bold border border-slate-300 flex items-center gap-1 ${
          currentTag
            ? `bg-slate-100 text-slate-700`
            : 'bg-white text-slate-500 hover:border-slate-400'
        }`}
      >
        {currentTag ? ERROR_TYPES.find(e => e.value === currentTag)?.label : t('notebook.tagError')}
        <ChevronDown size={12} />
      </button>
      
      {open && (
        <div className="absolute top-full mt-1 left-0 bg-white border border-slate-200 rounded-lg shadow-lg z-10 min-w-max">
          {ERROR_TYPES.map(type => (
            <button
              key={type.value}
              onClick={() => {
                onTag(questionId, type.value);
                setOpen(false);
              }}
              className={`block w-full text-left px-4 py-2 text-sm hover:bg-slate-50 border-b border-slate-100 last:border-b-0 ${
                currentTag === type.value ? 'bg-blue-50 text-blue-700 font-bold' : ''
              }`}
            >
              <span className={`inline-block w-2 h-2 rounded-full mr-2 bg-${type.color}-500`} />
              {type.label}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}

CELL 3 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 6. AI DAILY MISSION: Automated Practice Selection with Interleaved Practice
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * selectAIDailyMission: Automatically select 20 questions using ISRS ranking
 * Enforces interleaved practice: ensures questions span ≥3 different topics
 * 
 * @param {Array} mistakes - All mistake questions
 * @returns {Array} Selected 20 questions with topic diversity
 */
function selectAIDailyMission(mistakes) {
  // Calculate priority score for each mistake
  const prioritizedMistakes = mistakes
    .map(m => ({
      ...m,
      masteryPriority: calculateMasteryPriority(m)
    }))
    .sort((a, b) => b.masteryPriority - a.masteryPriority);
  
  // Enforce interleaved practice: collect questions by topic
  const byTopic = {};
  prioritizedMistakes.forEach(m => {
    if (!byTopic[m.Topic]) byTopic[m.Topic] = [];
    byTopic[m.Topic].push(m);
  });
  
  const topicList = Object.keys(byTopic).sort(
    (a, b) => byTopic[b][0].masteryPriority - byTopic[a][0].masteryPriority
  );
  
  // Select questions in round-robin: spread across topics
  const selected = [];
  const topicIndices = {};
  topicList.forEach(t => topicIndices[t] = 0);
  
  while (selected.length < 20 && topicList.some(t => topicIndices[t] < byTopic[t].length)) {
    for (const topic of topicList) {
      if (selected.length >= 20) break;
      if (topicIndices[topic] < byTopic[topic].length) {
        selected.push(byTopic[topic][topicIndices[topic]]);
        topicIndices[topic]++;
      }
    }
  }
  
  // Verify at least 3 different topics
  const topicCount = new Set(selected.map(q => q.Topic)).size;
  if (topicCount < 3) {
    console.warn(`AI Daily Mission: Only ${topicCount} topics, need ≥3 for interleaved practice`);
  }
  
  return selected.slice(0, 20);
}

// ───────────────────────────────────────────────────────────────────────────────

/**
 * Rule of 3: Archive question after 3 consecutive correct answers
 * Move from active mistakes to mistake_archive in localStorage
 */
function applyRuleOfThree(improvements) {
  const archived = JSON.parse(localStorage.getItem('mistake_archive') || '{}');
  const activeImprovements = { ...improvements };
  
  Object.entries(improvements).forEach(([questionId, data]) => {
    if (data.correctCount >= 3) {
      archived[questionId] = { ...data, archivedAt: new Date().toISOString() };
      delete activeImprovements[questionId];
    }
  });
  
  localStorage.setItem('mistake_archive', JSON.stringify(archived));
  localStorage.setItem('mistake_improvements', JSON.stringify(activeImprovements));
  
  return activeImprovements;
}

CELL 4 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 5. LEARNING ANALYTICS DASHBOARD
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * TopicHeatmap: Error Density (Wrong/Total attempts per topic)
 * Color scale: Yellow (low errors) → Deep Crimson (high errors)
 */
function TopicHeatmap({ mistakes }) {
  const { t } = useLanguage();
  
  const errorDensity = useMemo(() => {
    const topicMap = {};
    
    mistakes.forEach(m => {
      if (!topicMap[m.Topic]) {
        topicMap[m.Topic] = { attempted: 0, wrong: 0 };
      }
      topicMap[m.Topic].wrong++;
      topicMap[m.Topic].attempted += Math.max(m.attemptCount, 1);
    });
    
    // Calculate error density ratio
    return Object.entries(topicMap).map(([topic, data]) => ({
      topic,
      errorDensity: Math.min(1.0, data.wrong / Math.max(data.attempted, 1)),
      wrongCount: data.wrong,
      attemptedCount: data.attempted
    })).sort((a, b) => b.errorDensity - a.errorDensity);
  }, [mistakes]);
  
  const getHeatColor = (density) => {
    if (density < 0.2) return 'bg-yellow-100 text-yellow-800';
    if (density < 0.4) return 'bg-orange-100 text-orange-800';
    if (density < 0.6) return 'bg-red-300 text-red-900';
    if (density < 0.8) return 'bg-red-500 text-red-50';
    return 'bg-crimson-700 text-white';
  };
  
  return (
    <div className="bg-white rounded-xl p-6 border border-slate-200">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <BarChart2 size={20} />
        {t('notebook.errorDensityByTopic')}
      </h3>
      
      <div className="space-y-2">
        {errorDensity.map(({ topic, errorDensity: density, wrongCount, attemptedCount }) => (
          <div key={topic} className="flex items-center gap-4">
            <div className="w-32 font-semibold text-sm text-slate-700 truncate">
              {topic}
            </div>
            
            <div className="flex-1">
              <div className={`h-8 rounded-lg flex items-center justify-center font-bold text-sm transition-all ${getHeatColor(density)}`}>
                {(density * 100).toFixed(0)}% ({wrongCount}/{attemptedCount})
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// ───────────────────────────────────────────────────────────────────────────────

/**
 * ImprovementTrendChart: Stacked area chart of mastery state progression
 * Shows volume of questions flowing through: Unprocessed → Acquiring → Consolidating → Mastered
 */
function ImprovementTrendChart({ improvements }) {
  const { t } = useLanguage();
  
  const trendData = useMemo(() => {
    const stateHistory = {};
    
    Object.values(improvements).forEach(data => {
      const state = getMasteryState(data.correctCount || 0);
      const dateStr = data.lastCorrect
        ? new Date(data.lastCorrect).toISOString().split('T')[0]
        : new Date().toISOString().split('T')[0];
      
      if (!stateHistory[dateStr]) {
        stateHistory[dateStr] = { Unprocessed: 0, Acquiring: 0, Consolidating: 0, Mastered: 0 };
      }
      stateHistory[dateStr][state.label]++;
    });
    
    return Object.entries(stateHistory)
      .sort((a, b) => new Date(a[0]) - new Date(b[0]))
      .map(([date, states]) => ({ date, ...states }))
      .slice(-14); // Last 14 days
  }, [improvements]);
  
  return (
    <div className="bg-white rounded-xl p-6 border border-slate-200">
      <h3 className="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
        <TrendingUp size={20} />
        {t('notebook.improvementTrend')}
      </h3>
      
      <ResponsiveContainer width="100%" height={300}>
        <AreaChart data={trendData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Area type="monotone" dataKey="Unprocessed" stackId="1" stroke="#ef4444" fill="#fecaca" />
          <Area type="monotone" dataKey="Acquiring" stackId="1" stroke="#f59e0b" fill="#fed7aa" />
          <Area type="monotone" dataKey="Consolidating" stackId="1" stroke="#eab308" fill="#fef08a" />
          <Area type="monotone" dataKey="Mastered" stackId="1" stroke="#22c55e" fill="#bbf7d0" />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}

CELL 5 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 4. CALENDAR HEATMAP: 30-Day Mistake-Clearing Activity Visualization
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * CalendarHeatmap: 7-column grid showing 30 days of mistake-clearing activity
 * Color intensity represents daily activity level
 */
function CalendarHeatmap({ improvements }) {
  const { t } = useLanguage();
  
  // Calculate daily activity data
  const activityMap = useMemo(() => {
    const map = {};
    const now = new Date();
    
    // Initialize last 30 days
    for (let i = 0; i < 30; i++) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split('T')[0];
      map[dateStr] = 0;
    }
    
    // Count mistakes cleared per day
    Object.values(improvements).forEach(data => {
      if (data.lastCorrect) {
        const dateStr = new Date(data.lastCorrect).toISOString().split('T')[0];
        if (map[dateStr] !== undefined) {
          map[dateStr]++;
        }
      }
    });
    
    return map;
  }, [improvements]);
  
  const days = Object.entries(activityMap).reverse().sort();
  const maxActivity = Math.max(...Object.values(activityMap), 1);
  
  // Color intensity based on activity
  const getColor = (count) => {
    const intensity = count / maxActivity;
    if (intensity === 0) return 'bg-slate-100';
    if (intensity < 0.33) return 'bg-blue-200';
    if (intensity < 0.67) return 'bg-blue-400';
    return 'bg-blue-600';
  };
  
  return (
    <div className="bg-white rounded-xl p-4 border border-slate-200">
      <h3 className="font-bold text-slate-700 mb-4 flex items-center gap-2">
        <Calendar size={16} />
        {t('notebook.mistakeClearingActivity')}
      </h3>
      
      <div className="grid grid-cols-7 gap-1">
        {days.map(([dateStr, count], idx) => {
          const date = new Date(dateStr + 'T00:00:00');
          const weekday = date.toLocaleDateString('en-US', { weekday: 'short' });
          
          return (
            <div key={dateStr} className="flex flex-col items-center">
              {idx < 7 && <span className="text-xs text-slate-400 h-5">{weekday}</span>}
              <div
                className={`w-8 h-8 rounded ${getColor(count)} flex items-center justify-center text-xs font-bold text-slate-700 hover:ring-2 ring-blue-400 transition-all`}
                title={`${dateStr}: ${count} cleared`}
              >
                {count > 0 ? count : ''}
              </div>
            </div>
          );
        })}
      </div>
      
      <div className="flex items-center gap-2 mt-4 text-xs text-slate-500">
        <span>{t('notebook.less')}</span>
        <div className="flex gap-1">
          {[0, 0.33, 0.67, 1.0].map(i => (
            <div key={i} className={`w-3 h-3 rounded ${getColor(i * maxActivity)}`} />
          ))}
        </div>
        <span>{t('notebook.more')}</span>
      </div>
    </div>
  );
}

CELL 6 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 3. FLOATING UI SMART TOOLTIP: Viewport-Aware with Portal Rendering
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * TooltipWithPortal: Smart tooltip using Floating UI
 * - Automatically detects viewport edges and flips position
 * - Renders to document.body via Portal to avoid z-index/overflow issues
 * - Handles mouse enter/leave for show/hide
 */
function TooltipWithPortal({ trigger, content, placement = 'top' }) {
  const [open, setOpen] = useState(false);
  const arrowRef = useRef(null);
  
  const { refs, floatingStyles, middlewareData } = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    middleware: [
      offset(10),           // 10px gap from trigger
      flip(),               // Flip to opposite side if too close to edge
      shift({ padding: 8 }) // Shift to keep within viewport
    ],
    whileElementsMounted: autoUpdate  // Update on DOM changes
  });
  
  return (
    <>
      <div
        ref={refs.setReference}
        onMouseEnter={() => setOpen(true)}
        onMouseLeave={() => setOpen(false)}
        className="cursor-help"
      >
        {trigger}
      </div>
      
      {open && createPortal(
        <div
          ref={refs.setFloating}
          style={floatingStyles}
          className="z-[9999] bg-slate-900 text-white text-xs rounded-xl p-3 shadow-2xl ring-1 ring-white/10 max-w-xs pointer-events-none"
        >
          {content}
        </div>,
        document.body
      )}
    </>
  );
}

CELL 7 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 2. ISRS CALCULATION: Multi-Weighted Mastery Priority Score
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Calculate comprehensive mastery priority score using weighted integration
 * Score = (U × 0.4) + (D × 0.4) + (R × 0.2)
 * 
 * @param {Object} mistake - Question mistake object
 * @param {number} mistake.lastAttempted - ISO timestamp of last attempt
 * @param {number} mistake.attemptCount - Total attempts on this question
 * @param {string} mistake.Topic - Topic of the question
 * @returns {number} Priority score (higher = more urgent)
 */
function calculateMasteryPriority(mistake) {
  // 1. URGENCY: Ebbinghaus Forgetting Curve
  const now = Date.now();
  const lastAttemptTime = new Date(mistake.lastAttempted).getTime();
  const daysSinceLastAttempt = (now - lastAttemptTime) / (1000 * 60 * 60 * 24);
  
  // U = 2^(days/7) - exponential curve matching forgetting pattern
  const U = Math.pow(2, daysSinceLastAttempt / 7);
  
  // 2. DIFFICULTY: Based on attempt count
  // At 3+ attempts, question is at maximum difficulty (D = 1.0)
  const D = Math.min(1.0, (mistake.attemptCount || 1) / 3);
  
  // 3. RECENCY/CONTEXT: Boost if matches recent quiz topics
  let R = 0.5; // Baseline score
  
  const recentTopics = JSON.parse(localStorage.getItem('recent_quiz_topics') || '[]');
  if (recentTopics.includes(mistake.Topic)) {
    R = 1.5; // 1.5x boost for contextual relevance
  }
  
  // Final weighted score
  const score = (U * 0.4) + (D * 0.4) + (R * 0.2);
  
  return score;
}

// ───────────────────────────────────────────────────────────────────────────────

/**
 * Get current mastery state based on improvement count
 * State machine: 0 (Unprocessed) → 1 (Acquiring) → 2 (Consolidating) → 3 (Mastered)
 */
function getMasteryState(improvementCount = 0) {
  if (improvementCount === 0) return { state: 0, label: 'Unprocessed' };
  if (improvementCount === 1) return { state: 1, label: 'Acquiring' };
  if (improvementCount === 2) return { state: 2, label: 'Consolidating' };
  return { state: 3, label: 'Mastered' };
}

CELL 8 [code]
// ═══════════════════════════════════════════════════════════════════════════════
// 1. SETUP: Dependencies and Imports to Add
// ═══════════════════════════════════════════════════════════════════════════════

// Add to package.json:
// "npm install @floating-ui/react recharts"

// New imports for MistakeNotebookPage.jsx:
import { useFloating, offset, flip, shift, arrow } from '@floating-ui/react';
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { createPortal } from 'react-dom';

// Existing imports to keep:
import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';

CELL 9 [markdown]
# MistakeNotebookPage Refactoring: Multi-Weighted ISRS System

## Overview
Comprehensive refactoring of MistakeNotebookPage.jsx implementing:
- **Integrated Spaced Repetition System (ISRS)** with weighted mastery scoring
- **Smart Tooltips** using viewport-aware positioning (Floating UI)
- **AI Daily Mission** for automated practice selection with interleaved practice
- **Learning Analytics Dashboard** with heatmaps and trend visualization
- **Calendar Heatmap** for 30-day activity tracking
- **Rule of 3 Archiving** for automatic mastery graduation

### Core Formulas
**MasteryPriority Score**: $\text{Score} = (U \times 0.4) + (D \times 0.4) + (R \times 0.2)$

- **Urgency (U)**: $U = 2^{days/7}$ (Ebbinghaus Forgetting Curve)
- **Difficulty (D)**: Normalized from attempt count (maxed at 1.0 for 3+ attempts)
- **Recency (R)**: Context boost from recent quiz topics (1.5x multiplier if matched)
