

===== FILE: src/App_Final.jsx =====

import React from 'react';
import ForumPage from './pages/ForumPage';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { LanguageProvider } from './contexts/LanguageContext';
import PrivateRoute from './components/PrivateRoute';
import Header from './components/Header';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage_Fixed';
import TopicSelectionPage from './pages/TopicSelectionPage_Updated';
import PracticeModeSelection from './pages/PracticeModeSelection';
import QuizPage from './pages/QuizPage';
import ResultsPage from './pages/ResultsPage_Updated_Fixed';
import MillionaireQuiz from './pages/MillionaireQuiz';
import LeaderboardPage from './pages/LeaderboardPage';
import ProfilePage from './pages/ProfilePage';
import HistoryPage from './pages/HistoryPage_Fixed';
import MistakeNotebookPage from './pages/MistakeNotebookPage';
import FirebaseTestPage from './pages/FirebaseTestPage';
import DebugDashboard from './pages/DebugDashboard';
import SRSReviewPage from './pages/SRSReviewPage';
import { useQuizData } from './hooks/useQuizData';
import ChemistryLoading from './components/ChemistryLoading';
import ChemStore from './components/ChemStore';
import TokenLog from './components/TokenLog';
import { ChemCityRoot } from './components/chemcity/ChemCityRoot';
import LandingPage from './pages/LandingPage';
import VisionPage from './pages/VisionPage';

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTK36yaUN-NMCkQNT-DAHgc6FMZPjUc0Yv3nYEK4TA9W2qE9V1TqVD10Tq98-wXQoAvKOZlwGWRSDkU/pub?gid=1182550140&single=true&output=csv';

function AppContent() {
  const location = useLocation();
  const { questions, loading, error } = useQuizData(SHEET_URL);
  const isNotebookRoute = location.pathname === '/notebook';
  const isChemCityRoute = location.pathname === '/chemcity';
  const noShellRoutes = new Set(['/', '/vision', '/dashboard', '/login', '/register', '/millionaire']);
  const useNoShell = noShellRoutes.has(location.pathname);
  const hideHeaderRoutes = new Set(['/', '/vision', '/login', '/register', '/millionaire']);
  const showHeader = !hideHeaderRoutes.has(location.pathname);

  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <ChemistryLoading persistKey="startup" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50">
        <div className="text-center bg-white p-8 rounded-2xl shadow-xl border-2 border-red-200">
          <p className="text-red-500 font-bold mb-2">Error loading questions</p>
          <p className="text-academic-slate">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <>
      {showHeader && <Header />}
      <div
        className={`${showHeader && !isChemCityRoute ? 'pt-[76px]' : ''} ${isChemCityRoute ? 'bg-slate-950' : ''} ${(useNoShell || isNotebookRoute || isChemCityRoute) ? '' : 'container mx-auto px-4 py-6'}`.trim()}
      >
        <Routes>
          {/* Public Routes */}
          <Route path="/" element={<LandingPage />} />
          <Route path="/vision" element={<VisionPage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />

          {/* Protected Routes */}
          {/* ✅ FIXED: Now passes questions prop to DashboardPage */}
          <Route
            path="/dashboard"
            element={
              <PrivateRoute>
                <DashboardPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/home"
            element={
              <PrivateRoute>
                <Navigate to="/dashboard" replace />
              </PrivateRoute>
            }
          />

          {/* Practice Mode Selection */}
          <Route
            path="/practice"
            element={
              <PrivateRoute>
                <PracticeModeSelection questions={questions} />
              </PrivateRoute>
            }
          />

          <Route
            path="/srs-review"
            element={
              <PrivateRoute>
                <SRSReviewPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          {/* Legacy Topic Selection */}
          <Route
            path="/topics"
            element={
              <PrivateRoute>
                <TopicSelectionPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/quiz"
            element={
              <PrivateRoute>
                <QuizPage />
              </PrivateRoute>
            }
          />

          <Route
            path="/millionaire"
            element={
              <PrivateRoute>
                <MillionaireQuiz questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/results"
            element={
              <PrivateRoute>
                <ResultsPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/leaderboard"
            element={
              <PrivateRoute>
                <LeaderboardPage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/profile"
            element={
              <PrivateRoute>
                <ProfilePage />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/history"
            element={
              <PrivateRoute>
                <HistoryPage />
              </PrivateRoute>
            }
          />
          
          {/* Mistake Notebook - NEW */}
          <Route
            path="/notebook"
            element={
              <PrivateRoute>
                <MistakeNotebookPage questions={questions} />
              </PrivateRoute>
            }
          />
          
          <Route
            path="/forum"
            element={
              <PrivateRoute>
                <ForumPage />
              </PrivateRoute>
            }
          />

          {/* ChemStore - FIXED: Now inside Routes */}
          <Route
            path="/store"
            element={
              <PrivateRoute>
                <ChemStore />
              </PrivateRoute>
            }
          />

          <Route
            path="/chemcity"
            element={
              <PrivateRoute>
                <ChemCityRoot />
              </PrivateRoute>
            }
          />

          {/* Token Log - FIXED: Now inside Routes */}
          <Route
            path="/token-log"
            element={
              <PrivateRoute>
                <TokenLog />
              </PrivateRoute>
            }
          />

          {/* Firebase Test Page - for debugging */}
          <Route
            path="/test-firebase"
            element={
              <PrivateRoute>
                <FirebaseTestPage />
              </PrivateRoute>
            }
          />
          
          {/* Debug Dashboard - comprehensive diagnostics */}
          <Route
            path="/debug"
            element={
              <PrivateRoute>
                <DebugDashboard />
              </PrivateRoute>
            }
          />

          {/* Catch all - redirect to dashboard */}
          <Route path="*" element={<Navigate to="/dashboard" replace />} />
        </Routes>
      </div>
    </>
  );
}

function AppShell() {
  const location = useLocation();
  const noShellRoutes = new Set(['/', '/dashboard', '/login', '/register', '/millionaire']);
  const useNoShell = noShellRoutes.has(location.pathname);

  return (
    <div className={useNoShell ? 'min-h-screen' : 'min-h-screen bg-gray-50'}>
      <AppContent />
    </div>
  );
}

export default function App() {
  return (
    <LanguageProvider>
      <AuthProvider>
        <Router>
          <AppShell />
        </Router>
      </AuthProvider>
    </LanguageProvider>
  );
}

===== FILE: src/components/Header.jsx =====

import React, { useEffect, useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { Home, Trophy, User, LogOut, History, ChevronDown, Menu, X, Languages, BookOpen, MessageSquare, Gem, ShoppingBag, Clock, AlertTriangle, Pencil, Bell, BellDot, Trash2, AlertCircle, Building2 } from 'lucide-react';
import { quizStorage } from '../utils/quizStorage';
import { forumService } from '../services/forumService';

import ChemCityUserProfileIcon from './ChemCityUserProfileIcon';

export default function Header() {
    const { currentUser, logout, userProfile, profileError } = useAuth();
    const { language, toggleLanguage, isEnglish, t, tf } = useLanguage();
    const navigate = useNavigate();
    const location = useLocation();
    const [showUserMenu, setShowUserMenu] = useState(false);
    const [showMobileNav, setShowMobileNav] = useState(false);
    const [showLogoutModal, setShowLogoutModal] = useState(false);
    const [showNotifPanel, setShowNotifPanel] = useState(false);
    const [unreadCount, setUnreadCount] = useState(0);
    const [notifs, setNotifs] = useState([]);
    const [notifLimit, setNotifLimit] = useState(10);
    const [showDeleteAllNotifsConfirm, setShowDeleteAllNotifsConfirm] = useState(false);

    useEffect(() => {
        if (!currentUser || !showNotifPanel) return;
        const unsub = forumService.subscribeToNotifications(currentUser.uid, (data) => {
            setNotifs(data);
            setUnreadCount(data.filter(n => !n.read).length);
        }, notifLimit);
        return () => unsub && unsub();
    }, [currentUser, showNotifPanel, notifLimit]);

    useEffect(() => {
        if (!showNotifPanel) {
            setNotifLimit(10);
        }
    }, [showNotifPanel]);

    const handleMarkNotifRead = async (id) => {
        try {
            await forumService.markNotificationRead(id);
        } catch { /* ignore */ }
    };

    const handleMarkAllNotifsRead = async () => {
        if (!currentUser) return;
        try {
            await forumService.markAllNotificationsRead(currentUser.uid);
        } catch { /* ignore */ }
    };

    const handleDeleteNotif = async (id) => {
        try {
            await forumService.deleteNotification(id);
        } catch { /* ignore */ }
    };

    const handleDeleteAllNotifs = async () => {
        if (!currentUser) return;
        setShowDeleteAllNotifsConfirm(true);
    };

    const confirmDeleteAllNotifs = async () => {
        if (!currentUser) return;
        try {
            await forumService.deleteAllNotifications(currentUser.uid, 200);
            setShowDeleteAllNotifsConfirm(false);
        } catch { /* ignore */ }
    };

    const formatAgo = (iso) => {
        const diffMs = Date.now() - new Date(iso).getTime();
        const mins = Math.floor(diffMs / 60000);
        if (mins < 1) return t('forum.justNow');
        if (mins < 60) return tf('forum.timeAgoMinutesShort', { count: mins });
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return tf('forum.timeAgoHoursShort', { count: hrs });
        return tf('forum.timeAgoDaysShort', { count: Math.floor(hrs / 24) });
    };

    const typeLabel = (n) => {
        switch (n.type) {
            case 'like': return t('forum.likedYourComment');
            case 'reply': return t('forum.repliedToPost');
            case 'post_like': return t('forum.likedYourPost');
            case 'reply_like': return t('forum.likedYourReply');
            case 'comment_reply': return t('forum.repliedToComment');
            case 'comment_reply_like': return t('forum.likedYourReply');
            default: return t('forum.interactedWithContent');
        }
    };

    // Get tokens from userProfile with real-time sync
    const tokens = userProfile?.tokens;
    const tokensDisplay =
        profileError && (tokens === undefined || tokens === null)
            ? '—'
            : (tokens ?? 0);

    if (location.pathname === '/login' || location.pathname === '/register') {
        return null;
    }

    const isInQuiz = location.pathname === '/quiz';

    async function handleLogoutConfirm() {
        try {
            await logout();
            navigate('/');
        } catch (error) {
            console.error('Failed to log out:', error);
        }
    }

    const handleLogoutClick = () => {
        if (isInQuiz) {
            const confirmed = window.confirm(
                t('header.confirmLogoutInQuiz')
            );
            if (!confirmed) return;
            quizStorage.clearQuizData();
            handleLogoutConfirm();
        } else {
            setShowLogoutModal(true);
        }
    };

    const handleNavigation = (path, options = {}) => {
        if (isInQuiz && path !== '/quiz') {
            const confirmed = window.confirm(
                t('header.confirmLeaveQuiz')
            );
            if (!confirmed) {
                return;
            }
            quizStorage.clearQuizData();
        }

        navigate(path, options);
        setShowUserMenu(false);
        setShowMobileNav(false);
    };

    const handleNotebookHome = () => {
        // Force Mistake Notebook to reset to the 3-button home screen even if we're already on /notebook.
        // We do this by pushing a unique navigation state nonce that MistakeNotebookPage listens for.
        handleNavigation('/notebook', { state: { forceNotebookHome: Date.now() } });
    };

    const isActive = (path) => location.pathname === path;

    return (
        <>
            <header className="fixed top-0 left-0 right-0 z-50 py-1">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                    <div className="floating-island island-amber w-full md:mx-auto px-3 sm:px-3 py-0.5">
                        <div className="floating-island-content flex justify-between items-center h-14 gap-4 min-w-0">
                        {/* Logo and Brand */}
                        <div className="flex-shrink min-w-0">
                            <div className="flex items-center gap-2 cursor-pointer" onClick={() => handleNavigation('/dashboard')}>
                                <div className="transition-transform active:scale-95">
                                    <img
                                        src="/ChemistreeIcon_square.png"
                                        alt="Chemistree"
                                        className="w-10 h-10"
                                        draggable="false"
                                    />
                                </div>
                                <div className="min-w-0 flex-1">
                                    <h1 className="text-xl font-black leading-tight whitespace-nowrap chem-sans" style={{ color: '#76A8A5' }}>
                                        Chemistree
                                    </h1>
                                    <p className="text-[10px] text-slate-500 font-bold -mt-1 hidden sm:block whitespace-nowrap overflow-hidden text-ellipsis chem-sans">
                                        by ChemLeung
                                    </p>
                                </div>
                            </div>
                        </div>

                        {/* Desktop Navigation Links */}
                        {currentUser && (
                            <div className="hidden md:flex flex-1 justify-center">
                                <nav className="flex items-center gap-4">
                                <button
                                    onClick={() => handleNavigation('/dashboard')}
                                    className={`nav-orb ${isActive('/dashboard') ? 'bg-lab-blue text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('nav.dashboard')}
                                    title={t('nav.dashboard')}
                                >
                                    <Home size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('nav.dashboard')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/practice')}
                                    className={`nav-orb ${isActive('/practice') || isActive('/quiz') ? 'bg-chemistry-green text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('nav.practice')}
                                    title={t('nav.practice')}
                                >
                                    <Pencil size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('nav.practice')}</span>
                                </button>

                                <button
                                    onClick={handleNotebookHome}
                                    className={`nav-orb ${isActive('/notebook') ? 'bg-orange-600 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('dashboard.mistakeNotebook')}
                                    title={t('dashboard.mistakeNotebook')}
                                >
                                    <BookOpen size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('dashboard.mistakeNotebook')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/forum')}
                                    className={`nav-orb ${isActive('/forum') ? 'bg-purple-600 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('forum.title')}
                                    title={t('forum.title')}
                                >
                                    <MessageSquare size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('forum.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/leaderboard')}
                                    className={`nav-orb ${isActive('/leaderboard') ? 'bg-amber-500 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label={t('leaderboard.title')}
                                    title={t('leaderboard.title')}
                                >
                                    <Trophy size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('leaderboard.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/chemcity')}
                                    className={`nav-orb ${isActive('/chemcity') ? 'bg-sky-600 text-white' : 'bg-white/70 text-slate-800 hover:bg-white/80'}`}
                                    aria-label="ChemCity"
                                    title="ChemCity"
                                >
                                    <Building2 size={20} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">ChemCity</span>
                                </button>

                                {/* TOKENS */}
                                <button
                                    onClick={() => handleNavigation('/store')}
                                    className={`nav-orb ${isActive('/store') ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white' : 'bg-gradient-to-r from-amber-400 to-orange-500 text-white'}`}
                                    aria-label={t('store.title')}
                                    title={t('store.title')}
                                >
                                    <Gem size={20} fill="currentColor" />
                                    <span className="nav-orb-badge bg-slate-900/90">{tokensDisplay}</span>
                                    <span className="nav-orb-label font-extrabold text-slate-900">{t('store.title')}</span>
                                </button>

                                <button
                                    onClick={toggleLanguage}
                                    className="nav-orb bg-gradient-to-r from-slate-600 to-slate-700 text-white"
                                    aria-label={isEnglish ? t('auth.switchToChinese') : t('auth.switchToEnglish')}
                                    title={isEnglish ? t('auth.switchToChinese') : t('auth.switchToEnglish')}
                                >
                                    <Languages size={20} strokeWidth={3} />
                                    <span className="nav-orb-label font-extrabold text-slate-900">{isEnglish ? t('auth.languageNameChinese') : t('auth.languageNameEnglish')}</span>
                                </button>
                                </nav>
                            </div>
                        )}

                        {/* Mobile + Desktop User Menu */}
                        {currentUser && (
                            <div className="flex items-center gap-2 flex-shrink min-w-0 justify-end">
                                <button
                                    onClick={() => setShowMobileNav(!showMobileNav)}
                                    className="md:hidden p-2 rounded-lg hover:bg-slate-100 transition-all active:scale-95"
                                >
                                    {showMobileNav ? <X size={24} /> : <Menu size={24} />}
                                </button>

                                {/* Notifications (right side) */}
                                <div className="relative">
                                    <button
                                        onClick={() => setShowNotifPanel(v => !v)}
                                        className="relative p-2 rounded-lg hover:bg-white/60 transition-all active:scale-[0.99]"
                                        aria-label={t('forum.notifications')}
                                        title={t('forum.notifications')}
                                    >
                                        {unreadCount > 0 ? <BellDot size={22} className="text-purple-700" /> : <Bell size={22} className="text-slate-700" />}
                                        {unreadCount > 0 && (
                                            <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] rounded-full w-5 h-5 flex items-center justify-center font-black">
                                                {unreadCount > 9 ? t('common.ninePlus') : unreadCount}
                                            </span>
                                        )}
                                    </button>

                                    {showNotifPanel && (
                                        <>
                                            <div className="fixed inset-0 z-40" onClick={() => setShowNotifPanel(false)} />
                                            <div className="absolute right-0 mt-2 w-80 bg-white rounded-2xl shadow-2xl border-2 border-slate-200 z-50 overflow-hidden max-h-[480px] flex flex-col">
                                                <div className="p-4 border-b flex items-center justify-between bg-slate-50">
                                                    <h3 className="font-bold text-slate-800 flex items-center gap-2">
                                                        <Bell size={18} />
                                                        {t('forum.notifications')}
                                                        {unreadCount > 0 && <span className="bg-red-500 text-white text-xs rounded-full px-2 py-0.5">{unreadCount}</span>}
                                                    </h3>
                                                    <div className="flex items-center gap-2">
                                                        {unreadCount > 0 && (
                                                            <button onClick={handleMarkAllNotifsRead} className="text-xs text-lab-blue hover:underline font-semibold">
                                                                {t('forum.markAllRead')}
                                                            </button>
                                                        )}
                                                        {notifs.length > 0 && (
                                                            <button
                                                                type="button"
                                                                onClick={handleDeleteAllNotifs}
                                                                className="p-1 hover:bg-rose-50 rounded text-rose-600"
                                                                aria-label={t('forum.deleteAll')}
                                                                title={t('forum.deleteAll')}
                                                            >
                                                                <Trash2 size={16} />
                                                            </button>
                                                        )}
                                                        <button onClick={() => setShowNotifPanel(false)} className="p-1 hover:bg-slate-200 rounded"><X size={16} /></button>
                                                    </div>
                                                </div>

                                                <div className="overflow-y-auto flex-1">
                                                    {notifs.length === 0 ? (
                                                        <div className="text-center py-10 text-slate-400 text-sm">{t('forum.noNotificationsYet')}</div>
                                                    ) : (
                                                        <>
                                                            {notifs.map(n => (
                                                                <div
                                                                    key={n.id}
                                                                    onClick={() => handleMarkNotifRead(n.id)}
                                                                    className={`p-4 border-b cursor-pointer hover:bg-slate-50 transition-all ${!n.read ? 'bg-blue-50' : ''}`}
                                                                >
                                                                    <div className="flex items-start gap-3">
                                                                        <div className={`w-2 h-2 rounded-full mt-2 flex-shrink-0 ${!n.read ? 'bg-lab-blue' : 'bg-transparent'}`} />
                                                                        <ChemCityUserProfileIcon userId={n.senderId} displayName={n.senderDisplayName || t('common.someone')} size={28} />
                                                                        <div className="flex-1 min-w-0">
                                                                            <p className="text-sm text-slate-800 font-medium leading-snug">
                                                                                <span className="font-bold">{n.senderDisplayName || t('common.someone')}</span> {typeLabel(n)}
                                                                            </p>
                                                                            {n.previewText && (
                                                                                <p className="text-xs text-slate-500 mt-1 truncate">"{n.previewText}"</p>
                                                                            )}
                                                                            {n.postTitle && (
                                                                                <p className="text-xs text-lab-blue mt-0.5 truncate">→ {n.postTitle}</p>
                                                                            )}
                                                                            <p className="text-xs text-slate-400 mt-1">{formatAgo(n.createdAt)}</p>
                                                                        </div>
                                                                        <button
                                                                            onClick={(e) => { e.stopPropagation(); handleDeleteNotif(n.id); }}
                                                                            className="p-1 hover:bg-slate-200 rounded text-slate-500 hover:text-rose-600"
                                                                            title={t('forum.delete') || 'Delete'}
                                                                        >
                                                                            <X size={16} />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                            {notifs.length >= notifLimit && (
                                                                <div className="p-3 flex justify-center">
                                                                    <button
                                                                        onClick={() => setNotifLimit((n) => n + 10)}
                                                                        className="px-4 py-2 rounded-lg font-bold bg-slate-100 text-slate-700 hover:bg-slate-200 transition-all"
                                                                    >
                                                                        {t('forum.viewMore')}
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                        </>
                                    )}
                                </div>

                                <div className="relative">
                                    <button
                                        onClick={() => setShowUserMenu(!showUserMenu)}
                                        className="flex items-center gap-3 px-3 py-1.5 rounded-xl hover:bg-white/60 transition-all active:scale-[0.99] border-2 border-transparent hover:border-white/60 max-w-[240px] sm:max-w-[280px]"
                                        title={currentUser.displayName || currentUser.email || t('common.anonymous')}
                                    >
                                        <ChemCityUserProfileIcon
                                            userId={currentUser?.uid}
                                            displayName={currentUser?.displayName || currentUser?.email || t('common.anonymous')}
                                            size={32}
                                            className="shadow-md flex-shrink-0"
                                        />
                                        <div className="hidden sm:block text-left min-w-0">
                                            <p
                                                className="text-sm font-bold text-slate-900 truncate max-w-[140px] lg:max-w-[180px]"
                                                title={currentUser.displayName || t('common.anonymous')}
                                            >
                                                {currentUser.displayName || t('common.anonymous')}
                                            </p>
                                            <p
                                                className="text-xs text-slate-700 truncate max-w-[140px] lg:max-w-[180px]"
                                                title={currentUser.email || ''}
                                            >
                                                {currentUser.email}
                                            </p>
                                        </div>
                                        <ChevronDown size={16} className="text-slate-600 hidden sm:block flex-shrink-0" />
                                    </button>

                                    {showUserMenu && (
                                        <>
                                            <div
                                                className="fixed inset-0 z-40"
                                                onClick={() => setShowUserMenu(false)}
                                            />
                                            <div className="absolute right-0 mt-2 w-56 bg-white rounded-xl shadow-xl border-2 border-slate-200 z-50 overflow-hidden">
                                                <button
                                                    onClick={() => handleNavigation('/profile')}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-slate-50 transition-all text-left active:scale-[0.99]"
                                                >
                                                    <User size={18} className="text-slate-700" />
                                                    <span className="font-bold text-slate-900">
                                                        {t('profile.profileSettings')}
                                                    </span>
                                                </button>
                                                <button
                                                    onClick={() => handleNavigation('/history')}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-slate-50 transition-all text-left border-t border-slate-100 active:scale-[0.99]"
                                                >
                                                    <History size={18} className="text-slate-700" />
                                                    <span className="font-bold text-slate-900">
                                                        {t('header.myHistory')}
                                                    </span>
                                                </button>
                                                <button
                                                    onClick={() => handleNavigation('/token-log')}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-slate-50 transition-all text-left border-t border-slate-100 active:scale-[0.99]"
                                                >
                                                    <Clock size={18} className="text-amber-500" />
                                                    <span className="font-bold text-slate-900">
                                                        {t('header.tokenHistory')}
                                                    </span>
                                                </button>
                                                <button
                                                    onClick={handleLogoutClick}
                                                    className="w-full flex items-center gap-3 px-4 py-3 hover:bg-red-50 transition-all text-left border-t border-slate-100 active:scale-[0.99]"
                                                >
                                                    <LogOut size={18} className="text-red-600" />
                                                    <span className="font-bold text-red-600">
                                                        {t('nav.logout')}
                                                    </span>
                                                </button>
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
                </div>

                {/* Mobile Navigation Menu */}
                {showMobileNav && currentUser && (
                    <>
                        <div
                            className="fixed inset-0 bg-black bg-opacity-25 z-30"
                            onClick={() => setShowMobileNav(false)}
                        />
                        <div className="md:hidden fixed top-[64px] left-0 right-0 bg-white border-b-2 border-slate-200 shadow-xl z-40 animate-in slide-in-from-top duration-200">
                            <nav className="flex flex-col p-2">
                                {/* Token Display - Mobile */}
                                <div className="mb-2 p-3 bg-gradient-to-r from-amber-400 to-orange-500 rounded-lg">
                                    <div className="flex items-center justify-between text-white">
                                        <div className="flex items-center gap-2">
                                        <Gem size={20} fill="currentColor" />
                                        <span className="font-black text-lg">{tokensDisplay}</span>
                                        <span className="text-sm opacity-90">{t('header.tokens')}</span>
                                    </div>
                                    <button
                                        onClick={() => handleNavigation('/store')}
                                        className="px-3 py-1 bg-white/20 rounded-lg font-bold text-sm hover:bg-white/30 transition-all active:scale-[0.98]"
                                    >
                                        <ShoppingBag size={16} className="inline mr-1" />
                                        {t('store.title')}
                                    </button>
                                </div>
                            </div>

                                <button
                                    onClick={() => handleNavigation('/dashboard')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/dashboard')
                                            ? 'bg-lab-blue text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <Home size={20} />
                                    <span>{t('nav.dashboard')}</span>
                                </button>
                                <button
                                    onClick={() => handleNavigation('/practice')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/practice') || isActive('/quiz')
                                            ? 'bg-chemistry-green text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <img
                                        src="/ChemistreeIcon_square.png"
                                        alt="Chemistree"
                                        className="w-8 h-8"
                                        draggable="false"
                                    />
                                    <span>{t('nav.practice')}</span>
                                </button>
                                
                                <button
                                    onClick={handleNotebookHome}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/notebook')
                                            ? 'bg-orange-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <BookOpen size={20} />
                                    <span>{t('dashboard.mistakeNotebook')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/forum')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/forum')
                                            ? 'bg-purple-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <MessageSquare size={20} />
                                    <span>{t('forum.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/leaderboard')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/leaderboard')
                                            ? 'bg-amber-500 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <Trophy size={20} />
                                    <span>{t('leaderboard.title')}</span>
                                </button>

                                <button
                                    onClick={() => handleNavigation('/chemcity')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/chemcity')
                                            ? 'bg-sky-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <Building2 size={20} />
                                    <span>ChemCity</span>
                                </button>
                                <button
                                    onClick={() => handleNavigation('/history')}
                                    className={`flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] ${isActive('/history')
                                            ? 'bg-purple-600 text-white'
                                            : 'text-slate-900 hover:bg-slate-100'
                                        }`}
                                >
                                    <History size={20} />
                                    <span>{t('history.title')}</span>
                                </button>

                                <button
                                    onClick={() => {
                                        toggleLanguage();
                                        setShowMobileNav(false);
                                    }}
                                    className="flex items-center gap-3 px-4 py-3 rounded-lg font-bold transition-all active:scale-[0.99] bg-gradient-to-r from-amber-400 to-orange-500 text-white hover:from-amber-500 hover:to-orange-600 mt-2 shadow-md"
                                >
                                    <Languages size={20} strokeWidth={3} />
                                    <span>{isEnglish ? t('auth.languageNameChinese') : t('auth.languageNameEnglish')}</span>
                                </button>
                            </nav>
                        </div>
                    </>
                )}
            </header>

            {/* Logout Confirmation Modal */}
            {showLogoutModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-in zoom-in duration-200">
                        <div className="p-6">
                            <div className="flex items-center gap-3 mb-4">
                                <div className="w-12 h-12 rounded-full bg-red-100 flex items-center justify-center">
                                    <AlertTriangle className="text-red-600" size={24} />
                                </div>
                                <div>
                                    <h3 className="text-xl font-black text-slate-800">
                                        {t('dashboard.confirmLogout')}
                                    </h3>
                                    <p className="text-sm text-slate-500">
                                        {t('dashboard.areYouSureLogout')}
                                    </p>
                                </div>
                            </div>
                            <p className="text-slate-600 mb-6">
                                {t('header.logoutWarning')}
                            </p>
                            <div className="flex gap-3">
                                <button
                                    onClick={() => setShowLogoutModal(false)}
                                    className="flex-1 px-6 py-3 bg-slate-100 text-slate-700 rounded-xl font-bold hover:bg-slate-200 transition-all"
                                >
                                    {t('common.cancel')}
                                </button>
                                <button
                                    onClick={() => {
                                        setShowLogoutModal(false);
                                        handleLogoutConfirm();
                                    }}
                                    className="flex-1 px-6 py-3 bg-red-600 text-white rounded-xl font-bold hover:bg-red-700 transition-all flex items-center justify-center gap-2"
                                >
                                    <LogOut size={18} />
                                    {t('nav.logout')}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {showDeleteAllNotifsConfirm && (
                <div className="fixed inset-0 z-[70] flex items-center justify-center p-4" onClick={() => setShowDeleteAllNotifsConfirm(false)}>
                    <div className="absolute inset-0 bg-black/40" />
                    <div
                        className="relative w-full max-w-sm bg-white rounded-2xl shadow-2xl border-2 border-slate-200 overflow-hidden"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <div className="p-4 border-b bg-slate-50 flex items-center gap-3">
                            <AlertCircle className="text-rose-600" size={18} />
                            <h4 className="font-black text-slate-800">{t('forum.deleteAllNotificationsTitle')}</h4>
                        </div>
                        <div className="p-4 text-sm text-slate-700">
                            {t('forum.deleteAllNotificationsBody')}
                        </div>
                        <div className="p-4 border-t bg-white flex justify-end gap-2">
                            <button
                                type="button"
                                onClick={() => setShowDeleteAllNotifsConfirm(false)}
                                className="px-4 py-2 rounded-lg font-bold bg-slate-200 text-slate-700 hover:bg-slate-300 transition-all"
                            >
                                {t('common.cancel')}
                            </button>
                            <button
                                type="button"
                                onClick={confirmDeleteAllNotifs}
                                className="px-4 py-2 rounded-lg font-bold bg-rose-600 text-white hover:bg-rose-700 transition-all"
                            >
                                {t('common.delete')}
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </>
    );
}

===== FILE: src/components/ChemStore.jsx =====

// ============================================================================
// CHEMSTORE - Token Economy Shop
// ============================================================================

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { ArrowLeft, ShoppingBag } from 'lucide-react';
import { getCosmeticsMap } from '../lib/chemcity/gachaStaticCache';
import { callChemCityBuyTickets, callChemCityPurchaseCosmetic } from '../lib/chemcity/cloudFunctions';

export default function ChemStore() {
  const navigate = useNavigate();
  const { currentUser, userProfile } = useAuth();
  const { t } = useLanguage();
  const [selectedCategory, setSelectedCategory] = useState('tickets');
  const [purchasing, setPurchasing] = useState(null);
  const [notification, setNotification] = useState(null);

  const [cosmeticsMap, setCosmeticsMap] = useState(null);

  const chemcity = userProfile?.chemcity || {};
  const currencies = chemcity?.currencies || {};
  const coins = Number(currencies.coins || 0);
  const tickets = Number(currencies.tickets || 0);
  const ownedCosmetics = Array.isArray(chemcity?.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
  const ownedCosmeticsSet = new Set(ownedCosmetics);

  const gender = userProfile?.gender || 'boy';

  // Show notification
  const showNotification = (message, type = 'success') => {
    setNotification({ message, type });
    setTimeout(() => setNotification(null), 3000);
  };

  useEffect(() => {
    let mounted = true;
    getCosmeticsMap()
      .then((m) => {
        if (!mounted) return;
        setCosmeticsMap(m);
      })
      .catch(() => {
        if (!mounted) return;
        setCosmeticsMap(new Map());
      });
    return () => {
      mounted = false;
    };
  }, []);

  const categories = [
    { key: 'tickets', label: 'Tickets', icon: '🎟️' },
    { key: 'avatars', label: 'Avatars', icon: '🧑' },
    { key: 'backgrounds', label: 'Backgrounds', icon: '🖼️' },
  ];

  const allCosmetics = cosmeticsMap ? Array.from(cosmeticsMap.values()) : [];
  const shopCosmetics = allCosmetics.filter((c) => c?.availability?.channels?.shop === true && c?.deprecated !== true);
  const currentCosmetics =
    selectedCategory === 'avatars'
      ? shopCosmetics.filter((c) => c.type === 'avatar')
      : selectedCategory === 'backgrounds'
        ? shopCosmetics.filter((c) => c.type === 'background')
        : [];

  const handleBuyTickets = async (count) => {
    if (purchasing) return;
    setPurchasing(`tickets_${count}`);
    try {
      await callChemCityBuyTickets({ count });
      showNotification(`Bought ${count} tickets`, 'success');
    } catch (e) {
      showNotification(e?.message || 'Failed to buy tickets', 'error');
    }
    setPurchasing(null);
  };

  const handleBuyCosmetic = async (cosmetic, currency) => {
    if (purchasing) return;
    setPurchasing(cosmetic.id);
    try {
      await callChemCityPurchaseCosmetic({ cosmeticId: cosmetic.id, currency });
      showNotification(`Purchased ${cosmetic.name}`, 'success');
    } catch (e) {
      showNotification(e?.message || 'Purchase failed', 'error');
    }
    setPurchasing(null);
  };

  return (
    <div className="max-w-7xl mx-auto space-y-6">
      {/* Notification */}
      {notification && (
        <div className={`fixed top-20 right-4 z-50 px-6 py-3 rounded-lg shadow-2xl animate-in slide-in-from-top-2 ${
          notification.type === 'success' 
            ? 'bg-gradient-to-r from-green-500 to-emerald-600 text-white' 
            : 'bg-gradient-to-r from-red-500 to-rose-600 text-white'
        }`}>
          <p className="font-bold">{notification.message}</p>
        </div>
      )}

      {/* Header */}
      <div className="flex items-center gap-4">
        <button
          onClick={() => navigate('/dashboard')}
          className="p-3 bg-white rounded-lg border-2 border-slate-200 hover:border-lab-blue transition-all"
        >
          <ArrowLeft size={20} />
        </button>
        
        <div className="flex-1 receipt-widget">
          <div className="receipt-perforation" />
          <div className="receipt-widget-content p-6">
            <h1 className="text-3xl font-black flex items-center gap-3 text-slate-900 bellmt-title ink-amber">
              <ShoppingBag size={32} className="text-amber-700" />
              {t('store.title')}
            </h1>
            <p className="text-slate-700 mt-1 font-semibold">
              {t('store.subtitle')}
            </p>
            <div className="flex items-start justify-between gap-6">
              <div className="min-w-0">
                <div className="mt-3 receipt-rule" />
                <p className="mt-3 text-sm text-slate-700 font-medium">
                  {t('store.subtitle')}
                </p>
              </div>

              <div className="flex-shrink-0 text-right">
                <div className="text-xs font-bold tracking-widest text-slate-500 uppercase">
                  {t('store.yourBalance')}
                </div>
                <div className="mt-2 flex items-center justify-end gap-2">
                  <span className="px-3 py-1 rounded-full bg-slate-100 border border-slate-200 text-slate-800 font-black tabular-nums">
                    {coins} coins
                  </span>
                  <span className="px-3 py-1 rounded-full bg-slate-100 border border-slate-200 text-slate-800 font-black tabular-nums">
                    {tickets} tickets
                  </span>
                </div>
                <div className="mt-3 receipt-rule" />
                <div className="mt-2 font-mono text-[11px] text-slate-500">
                  #{String(currentUser?.uid || '').slice(0, 6).toUpperCase()} · {new Date().toLocaleDateString('en-GB')}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Category Tabs */}
      <div className="bg-white rounded-2xl shadow-xl border-2 border-slate-200 overflow-hidden">
        <div className="flex border-b-2 border-slate-200">
          {categories.map(cat => (
            <button
              key={cat.key}
              onClick={() => setSelectedCategory(cat.key)}
              className={`flex-1 px-6 py-4 font-bold text-base transition-all flex items-center justify-center gap-2 ${
                selectedCategory === cat.key
                  ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white'
                  : 'text-slate-600 hover:bg-slate-50'
              }`}
            >
              <span className="text-2xl">{cat.icon}</span>
              {cat.label}
            </button>
          ))}
        </div>

        {/* Items Grid */}
        <div className="p-6">
          {selectedCategory === 'tickets' ? (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {[1, 10, 50].map((count) => {
                const cost = 250 * count;
                const canAfford = coins >= cost;
                return (
                  <div
                    key={count}
                    className="bg-white rounded-2xl border-2 border-slate-200 p-6 shadow-sm"
                  >
                    <div className="text-2xl font-black text-slate-900">{count} Tickets</div>
                    <div className="mt-1 text-slate-600 font-semibold">Cost: {cost} coins</div>
                    <button
                      onClick={() => handleBuyTickets(count)}
                      disabled={!canAfford || purchasing === `tickets_${count}`}
                      className={`mt-4 w-full px-4 py-3 rounded-xl font-black transition-all ${
                        canAfford
                          ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:opacity-90'
                          : 'bg-slate-200 text-slate-400 cursor-not-allowed'
                      }`}
                    >
                      {purchasing === `tickets_${count}` ? 'Buying...' : canAfford ? 'Buy' : 'Not enough coins'}
                    </button>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {currentCosmetics.map((cosmetic) => {
                const owned = ownedCosmeticsSet.has(cosmetic.id);
                const coinCost = Number(cosmetic?.shopData?.coinCost || 0);
                const canBuyWithCoins = Number.isFinite(coinCost) && coinCost > 0;
                const canAfford = canBuyWithCoins ? coins >= coinCost : false;

                return (
                  <div
                    key={cosmetic.id}
                    className="relative bg-white rounded-2xl border-2 border-slate-200 overflow-hidden transition-all hover:shadow-lg"
                  >
                    <div className="p-4 bg-slate-50 flex items-center justify-center">
                      {cosmetic.type === 'background' ? (
                        <img
                          src={cosmetic.imageUrl}
                          alt=""
                          className="w-full h-40 object-cover rounded-xl"
                          draggable={false}
                        />
                      ) : (
                        <div className="relative w-full h-40 rounded-xl overflow-hidden bg-gradient-to-b from-indigo-900 to-gray-900">
                          <img
                            src={cosmetic.imageUrl}
                            alt=""
                            draggable={false}
                            className="absolute bottom-0 left-0 h-full w-[200%] object-contain"
                            style={{ transform: gender === 'girl' ? 'translateX(-50%)' : 'translateX(0%)' }}
                          />
                        </div>
                      )}
                    </div>

                    <div className="p-5">
                      <div className="text-lg font-black text-slate-900 truncate">{cosmetic.name}</div>

                      <div className="mt-3 flex items-center justify-between">
                        <div className="text-slate-700 font-black tabular-nums">
                          {canBuyWithCoins ? `${coinCost} coins` : 'Not for sale'}
                        </div>

                        {owned ? (
                          <div className="px-3 py-1 rounded-full bg-green-100 text-green-700 font-black text-sm">
                            Owned
                          </div>
                        ) : (
                          <button
                            onClick={() => handleBuyCosmetic(cosmetic, 'coins')}
                            disabled={!canBuyWithCoins || !canAfford || purchasing === cosmetic.id}
                            className={`px-4 py-2 rounded-xl font-black transition-all ${
                              canBuyWithCoins && canAfford
                                ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:opacity-90'
                                : 'bg-slate-200 text-slate-400 cursor-not-allowed'
                            }`}
                          >
                            {purchasing === cosmetic.id ? 'Buying...' : canBuyWithCoins ? 'Buy' : 'Locked'}
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                );
              })}

              {currentCosmetics.length === 0 && (
                <div className="text-center py-12 col-span-full">
                  <p className="text-slate-400 text-lg">No items for sale yet.</p>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

    </div>
  );
}

===== FILE: src/components/chemcity/ChemStore.tsx =====

import React, { useEffect, useState } from 'react';
import { X, ShoppingBag, Clock, Lock, Plus, Coins, Gem, Tag, RefreshCw } from 'lucide-react';
import { useChemCityStore } from '../../store/chemcityStore';
import { getEffectiveCoinPrice } from '../../lib/chemcity/shop';
import { countdownToMidnight, STORE_SLOT_UNLOCK_COSTS, STORE_MAX_SLOTS } from '../../lib/chemcity/dailyStore';
import type { SlimItemDocument } from '../../lib/chemcity/types';

function needsAnonymousCrossOrigin(url?: string | null): boolean {
  if (!url) return false;
  const u = url.toLowerCase();
  return u.includes('drive.google.com') || u.includes('googleusercontent.com');
}

// Preload card images in the background
function preloadCardImages(items: SlimItemDocument[]) {
  items.forEach(item => {
    if (item.imageUrl) {
      const img = new Image();
      if (needsAnonymousCrossOrigin(item.imageUrl)) {
        img.crossOrigin = 'anonymous';
        img.referrerPolicy = 'no-referrer';
      }
      img.src = item.imageUrl;
    }
  });
}

const RARITY_CONFIG: Record<string, {
  borderColor: string; glowColor: string; bgGradient: string; artBg: string;
  badgeColor: string; badgeText: string; labelBg: string;
}> = {
  common:    { borderColor: '#94a3b8', glowColor: 'rgba(148,163,184,0.2)', bgGradient: 'linear-gradient(165deg,#1e293b,#0f172a)', artBg: 'rgba(255,255,255,0.04)', badgeColor: 'rgba(148,163,184,0.2)', badgeText: '#94a3b8', labelBg: 'rgba(148,163,184,0.15)' },
  uncommon:  { borderColor: '#34d399', glowColor: 'rgba(52,211,153,0.28)',  bgGradient: 'linear-gradient(165deg,#0f3d33,#071a16)', artBg: 'rgba(52,211,153,0.06)',  badgeColor: 'rgba(52,211,153,0.18)', badgeText: '#34d399', labelBg: 'rgba(52,211,153,0.14)' },
  rare:      { borderColor: '#60a5fa', glowColor: 'rgba(96,165,250,0.35)',  bgGradient: 'linear-gradient(165deg,#1e3a5f,#0f172a)', artBg: 'rgba(96,165,250,0.07)',  badgeColor: 'rgba(96,165,250,0.2)',  badgeText: '#60a5fa', labelBg: 'rgba(96,165,250,0.15)'  },
  epic:      { borderColor: '#a855f7', glowColor: 'rgba(168,85,247,0.35)',  bgGradient: 'linear-gradient(165deg,#2d1b4e,#0f0a1e)', artBg: 'rgba(168,85,247,0.07)',  badgeColor: 'rgba(168,85,247,0.2)',  badgeText: '#a855f7', labelBg: 'rgba(168,85,247,0.15)' },
  legendary: { borderColor: '#fbbf24', glowColor: 'rgba(251,191,36,0.45)',  bgGradient: 'linear-gradient(165deg,#3d2800,#1a0f00)', artBg: 'rgba(251,191,36,0.09)',  badgeColor: 'rgba(251,191,36,0.2)',  badgeText: '#fbbf24', labelBg: 'rgba(251,191,36,0.15)' },
};

export const ChemStore: React.FC = () => {
  const user             = useChemCityStore(s => s.user);
  const dailyStoreItems  = useChemCityStore(s => s.dailyStoreItems);
  const storeSlotCount   = useChemCityStore(s => s.storeSlotCount);
  const openPurchaseConfirm = useChemCityStore(s => s.openPurchaseConfirm);
  const unlockStoreSlot  = useChemCityStore(s => s.unlockStoreSlot);
  const devRefreshStaticData = useChemCityStore(s => s.devRefreshStaticData);
  const devGrantCoins = useChemCityStore(s => s.devGrantCoins);
  const devRerollStore = useChemCityStore(s => s.devRerollStore);

  const [countdown, setCountdown]   = useState(() => countdownToMidnight());
  const [unlockingSlot, setUnlockingSlot] = useState(false);
  const [unlockError, setUnlockError] = useState<string | null>(null);

  useEffect(() => {
    const id = setInterval(() => setCountdown(countdownToMidnight()), 1000);
    return () => clearInterval(id);
  }, []);

  // Preload store item images when they change
  useEffect(() => {
    preloadCardImages(dailyStoreItems);
  }, [dailyStoreItems]);

  const discount  = user?.activeBonuses.shopDiscountPercent ?? 0;
  const coins     = user?.currencies.coins ?? 0;
  const ownedSet  = new Set(user?.ownedItems ?? []);

  const isDevBuild = !!(import.meta as any)?.env?.DEV;
  const isDevToggle = (() => {
    try {
      const qs = new URLSearchParams(window.location.search);
      if (qs.get('cc_dev') === '1') return true;
      return localStorage.getItem('cc_dev') === '1';
    } catch {
      return false;
    }
  })();
  const isLocalhost = (() => {
    try {
      return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    } catch {
      return false;
    }
  })();
  const showDevControls = isDevBuild || isDevToggle || isLocalhost;

  const nextSlotNum  = storeSlotCount + 1;
  const nextSlotCost = STORE_SLOT_UNLOCK_COSTS[nextSlotNum] ?? null;
  const canUnlockMore = storeSlotCount < STORE_MAX_SLOTS;
  const canAffordNext = nextSlotCost != null && coins >= nextSlotCost;

  const handleUnlockSlot = async () => {
    if (unlockingSlot || !canUnlockMore || !canAffordNext) return;
    setUnlockingSlot(true);
    setUnlockError(null);
    try { await unlockStoreSlot(); }
    catch (err: any) { setUnlockError(err?.message ?? 'Failed to unlock slot.'); }
    finally { setUnlockingSlot(false); }
  };

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@500;600;700;800&display=swap');
        @keyframes shimmerSlide { 0%,100%{transform:translateX(-200%)} 50%{transform:translateX(200%)} }
        @keyframes legendGlow { 0%,100%{box-shadow:0 0 20px rgba(251,191,36,0.4),0 4px 12px rgba(0,0,0,0.5)} 50%{box-shadow:0 0 36px rgba(251,191,36,0.7),0 4px 16px rgba(0,0,0,0.6)} }
        .store-card:hover { transform:translateY(-4px) !important; }
        .store-card { transition:transform 0.2s ease, box-shadow 0.2s ease !important; }
        .owned-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.5); border-radius:inherit; display:flex; align-items:center; justify-content:center; }
        .slot-bar-segment { height:4px; border-radius:2px; flex:1; transition:background 0.4s ease; }
      `}</style>

      <div style={{ display: 'flex', flexDirection: 'column', flex: 1, paddingTop: 132, fontFamily: "'Quicksand',sans-serif", minHeight: 0 }}>

        {/* ── Store Header ── */}
        <div style={{
          padding: '16px 20px 14px',
          borderBottom: '1px solid rgba(197,215,181,0.1)',
          background: 'linear-gradient(135deg, rgba(118,168,165,0.1) 0%, transparent 80%)',
          flexShrink: 0,
        }}>
          <div style={{ display: 'flex', alignItems: 'flex-start', justifyContent: 'space-between', marginBottom: 10, gap: 12 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
              <div style={{
                background: 'linear-gradient(135deg,rgba(118,168,165,0.3),rgba(118,168,165,0.1))',
                border: '1.5px solid rgba(118,168,165,0.5)',
                borderRadius: 12, width: 46, height: 46,
                display: 'flex', alignItems: 'center', justifyContent: 'center',
              }}>
                <ShoppingBag size={22} color="#76A8A5" />
              </div>
              <div>
                <div style={{ color: '#fff', fontWeight: 800, fontSize: 18 }}>ChemStore</div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, color: 'rgba(197,215,181,0.5)', fontSize: 12, fontWeight: 600 }}>
                  <Clock size={11} />
                  <span>Resets in {countdown}</span>
                </div>
              </div>
            </div>
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end', gap: 10, flexWrap: 'wrap', rowGap: 8, maxWidth: 520 }}>
              {showDevControls && (
                <>
                  <button
                    type="button"
                    onClick={() => devRefreshStaticData()}
                    style={{
                      display: 'flex', alignItems: 'center', gap: 6,
                      background: 'rgba(255,255,255,0.06)',
                      border: '1px solid rgba(255,255,255,0.12)',
                      borderRadius: 12,
                      padding: '6px 10px',
                      cursor: 'pointer',
                      color: 'rgba(255,255,255,0.55)',
                      fontWeight: 800,
                      fontSize: 11,
                      fontFamily: "'Quicksand',sans-serif",
                    }}
                    title="DEV: refresh ChemCity static data"
                  >
                    <RefreshCw size={14} />
                    Refresh
                  </button>

                  <button
                    type="button"
                    onClick={() => devRerollStore()}
                    style={{
                      display: 'flex', alignItems: 'center', gap: 6,
                      background: 'rgba(118,168,165,0.14)',
                      border: '1px solid rgba(118,168,165,0.28)',
                      borderRadius: 12,
                      padding: '6px 10px',
                      cursor: 'pointer',
                      color: 'rgba(197,215,181,0.9)',
                      fontWeight: 900,
                      fontSize: 11,
                      fontFamily: "'Quicksand',sans-serif",
                    }}
                    title="DEV: reroll store items"
                  >
                    Reroll
                  </button>

                  <button
                    type="button"
                    onClick={() => devGrantCoins(1000)}
                    style={{
                      display: 'flex', alignItems: 'center', gap: 6,
                      background: 'rgba(251,191,36,0.12)',
                      border: '1px solid rgba(251,191,36,0.25)',
                      borderRadius: 12,
                      padding: '6px 10px',
                      cursor: 'pointer',
                      color: 'rgba(251,191,36,0.9)',
                      fontWeight: 900,
                      fontSize: 11,
                      fontFamily: "'Quicksand',sans-serif",
                    }}
                    title="DEV: +1000 coins"
                  >
                    +1000
                  </button>
                </>
              )}

              {discount > 0 && (
                <div style={{
                  display: 'flex', alignItems: 'center', gap: 5,
                  background: 'rgba(52,211,153,0.15)', border: '1.5px solid rgba(52,211,153,0.4)',
                  borderRadius: 20, padding: '5px 12px',
                }}>
                  <Tag size={13} color="#34d399" />
                  <span style={{ color: '#34d399', fontWeight: 800, fontSize: 13 }}>{discount}% OFF</span>
                </div>
              )}
            </div>
          </div>

          {/* Slot progress bar */}
          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <div style={{ display: 'flex', gap: 3, flex: 1 }}>
              {Array.from({ length: STORE_MAX_SLOTS }, (_, i) => (
                <div key={i} className="slot-bar-segment" style={{
                  background: i < storeSlotCount ? 'rgba(118,168,165,0.8)' : 'rgba(255,255,255,0.08)',
                }} />
              ))}
            </div>
            <span style={{ color: 'rgba(255,255,255,0.4)', fontSize: 11, fontWeight: 700, flexShrink: 0 }}>
              {storeSlotCount}/{STORE_MAX_SLOTS} slots
            </span>
          </div>
        </div>

        {/* ── Card Display ── */}
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {dailyStoreItems.length === 0 ? (
            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: 200, gap: 12 }}>
              <ShoppingBag size={40} color="rgba(255,255,255,0.1)" style={{ animation: 'legendGlow 2s infinite' }} />
              <p style={{ color: 'rgba(255,255,255,0.3)', fontSize: 14, fontWeight: 600, margin: 0 }}>Loading store…</p>
            </div>
          ) : (
            <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
              {/* ── Card Row ── */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${Math.min(dailyStoreItems.length, 3)}, 1fr)`,
                gap: 12,
                justifyItems: 'center',
              }}>
                {dailyStoreItems.map((item, idx) => {
                  const isOwned = ownedSet.has(item.id);
                  const cfg = RARITY_CONFIG[item.rarity] ?? RARITY_CONFIG.common;
                  const rawCoin = item.shopData?.coinCost;
                  const rawDiamond = item.shopData?.diamondCost;
                  const effCoin = rawCoin != null ? getEffectiveCoinPrice(rawCoin, user?.activeBonuses ?? null) : null;
                  const coinSaved = rawCoin != null && effCoin != null ? rawCoin - effCoin : 0;

                  return (
                    <div key={item.id} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 8, width: '100%', maxWidth: 160 }}>
                      {/* Vertical RPG card */}
                      <button
                        onClick={() => openPurchaseConfirm(item.id)}
                        className="store-card"
                        style={{
                          position: 'relative',
                          width: '100%', maxWidth: 150, height: 210,
                          borderRadius: 14,
                          border: `2px solid ${cfg.borderColor}`,
                          background: cfg.bgGradient,
                          boxShadow: item.rarity === 'legendary'
                            ? `0 0 28px ${cfg.glowColor}, 0 6px 20px rgba(0,0,0,0.6)`
                            : `0 0 14px ${cfg.glowColor}, 0 4px 12px rgba(0,0,0,0.5)`,
                          cursor: 'pointer', overflow: 'hidden', padding: 0,
                          animation: item.rarity === 'legendary' ? 'legendGlow 2.5s ease-in-out infinite' : 'none',
                        }}
                      >
                        {/* Shimmer for legendary */}
                        {item.rarity === 'legendary' && (
                          <div style={{
                            position: 'absolute', inset: 0, zIndex: 1, pointerEvents: 'none',
                            background: 'linear-gradient(105deg,transparent 30%,rgba(255,215,0,0.12) 50%,transparent 70%)',
                            animation: 'shimmerSlide 3s ease-in-out infinite',
                          }} />
                        )}

                        {/* Slot # badge */}
                        <div style={{
                          position: 'absolute', top: 6, left: 8, zIndex: 3,
                          color: 'rgba(255,255,255,0.3)', fontSize: 9, fontWeight: 700,
                          fontFamily: "'Quicksand',sans-serif",
                        }}>#{idx + 1}</div>

                        {/* Stars */}
                        <div style={{
                          position: 'absolute', top: 5, right: 7, zIndex: 3,
                          color: cfg.badgeText, fontSize: 8, letterSpacing: 1,
                        }}>{'✦'.repeat({ common:1, uncommon:2, rare:2, epic:3, legendary:4 }[item.rarity] ?? 1)}</div>

                        {/* Art */}
                        <div style={{
                          height: 130, margin: '14px 10px 6px',
                          background: cfg.artBg,
                          border: `1px solid ${cfg.borderColor}`,
                          borderRadius: 8,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          overflow: 'hidden',
                          position: 'relative',
                          zIndex: 2,
                        }}>
                          {item.imageUrl ? (
                            <img
                              src={item.imageUrl}
                              alt={item.name}
                              style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                              {...(needsAnonymousCrossOrigin(item.imageUrl)
                                ? { crossOrigin: 'anonymous' as const, referrerPolicy: 'no-referrer' as const }
                                : {})}
                              loading="lazy"
                              onError={e => { (e.target as HTMLImageElement).style.display='none'; }}
                            />
                          ) : (
                            <span style={{ fontSize: 48 }}>{item.emoji}</span>
                          )}
                        </div>

                        {/* Name */}
                        <div style={{ padding: '0 10px 4px', textAlign: 'center', position: 'relative', zIndex: 2 }}>
                          <div style={{ color: '#f1f5f9', fontSize: 11, fontWeight: 800, fontFamily: "'Quicksand',sans-serif", lineHeight: 1.25, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{item.name}</div>
                          <div style={{ color: 'rgba(255,255,255,0.4)', fontSize: 9, fontFamily: 'monospace', marginTop: 1 }}>{item.chemicalFormula}</div>
                        </div>

                        {/* Rarity footer */}
                        <div style={{
                          position: 'absolute', bottom: 8, left: 10, right: 10,
                          background: cfg.badgeColor, borderRadius: 4, padding: '2px 0',
                          textAlign: 'center', fontSize: 8, fontWeight: 800,
                          color: cfg.badgeText, fontFamily: "'Quicksand',sans-serif",
                          textTransform: 'uppercase', letterSpacing: '0.06em', zIndex: 2,
                        }}>{item.rarity}</div>

                        {/* Owned overlay */}
                        {isOwned && (
                          <div className="owned-overlay" style={{ zIndex: 4, borderRadius: 12 }}>
                            <div style={{
                              background: 'rgba(52,211,153,0.9)', borderRadius: 8,
                              padding: '6px 14px', fontWeight: 800, fontSize: 12,
                              color: '#052e16', fontFamily: "'Quicksand',sans-serif",
                            }}>✓ Owned</div>
                          </div>
                        )}
                      </button>

                      {/* Price below card */}
                      <div style={{ textAlign: 'center', width: '100%' }}>
                        {effCoin != null && (
                          <div>
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4 }}>
                              <Coins size={12} color="#fbbf24" />
                              <span style={{ color: '#fbbf24', fontWeight: 800, fontSize: 13, fontFamily: "'Quicksand',sans-serif" }}>
                                {effCoin.toLocaleString()}
                              </span>
                            </div>
                            {coinSaved > 0 && (
                              <div style={{ color: 'rgba(255,255,255,0.3)', fontSize: 10, textDecoration: 'line-through', fontFamily: "'Quicksand',sans-serif" }}>
                                {rawCoin!.toLocaleString()}
                              </div>
                            )}
                          </div>
                        )}
                        {item.shopData?.diamondCost != null && (
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4 }}>
                            <Gem size={11} color="#67e8f9" />
                            <span style={{ color: '#67e8f9', fontWeight: 800, fontSize: 13, fontFamily: "'Quicksand',sans-serif" }}>
                              {item.shopData.diamondCost.toLocaleString()}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>

              {/* ── Unlock More Slots ── */}
              {canUnlockMore && (
                <div style={{ marginTop: 8 }}>
                  <p style={{ color: 'rgba(255,255,255,0.3)', fontSize: 11, fontWeight: 600, textAlign: 'center', marginBottom: 10 }}>
                    Unlock more slots to see more cards daily
                  </p>
                  <button
                    onClick={handleUnlockSlot}
                    disabled={!canAffordNext || unlockingSlot}
                    style={{
                      width: '100%', padding: '14px',
                      borderRadius: 14, border: '2px dashed',
                      borderColor: canAffordNext && !unlockingSlot ? 'rgba(118,168,165,0.5)' : 'rgba(255,255,255,0.1)',
                      background: canAffordNext && !unlockingSlot ? 'rgba(118,168,165,0.08)' : 'rgba(255,255,255,0.02)',
                      cursor: canAffordNext && !unlockingSlot ? 'pointer' : 'not-allowed',
                      display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 10,
                      transition: 'all 0.2s',
                    }}
                  >
                    <div style={{
                      width: 32, height: 32,
                      background: canAffordNext ? 'rgba(118,168,165,0.2)' : 'rgba(255,255,255,0.05)',
                      borderRadius: 8, display: 'flex', alignItems: 'center', justifyContent: 'center',
                    }}>
                      {unlockingSlot ? (
                        <div style={{ width:14, height:14, border:'2px solid rgba(255,255,255,0.2)', borderTopColor:'#76A8A5', borderRadius:'50%', animation:'spin 0.8s linear infinite' }} />
                      ) : (
                        <Lock size={14} color={canAffordNext ? '#76A8A5' : '#64748b'} />
                      )}
                    </div>
                    <div style={{ textAlign: 'left' }}>
                      <div style={{ color: canAffordNext ? '#fff' : '#64748b', fontWeight: 800, fontSize: 13, fontFamily: "'Quicksand',sans-serif" }}>
                        Unlock Slot #{nextSlotNum}
                      </div>
                      {nextSlotCost != null && (
                        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                          <Coins size={11} color={canAffordNext ? '#fbbf24' : '#64748b'} />
                          <span style={{ color: canAffordNext ? '#fbbf24' : '#64748b', fontSize: 12, fontWeight: 800, fontFamily: "'Quicksand',sans-serif" }}>
                            {nextSlotCost.toLocaleString()}
                          </span>
                          {!canAffordNext && (
                            <span style={{ color: '#64748b', fontSize: 10, fontFamily: "'Quicksand',sans-serif" }}>
                              (need {(nextSlotCost - coins).toLocaleString()} more)
                            </span>
                          )}
                        </div>
                      )}
                    </div>
                    <Plus size={16} color={canAffordNext ? '#76A8A5' : '#64748b'} style={{ marginLeft: 'auto' }} />
                  </button>
                  {unlockError && <p style={{ color: '#f87171', fontSize: 11, textAlign: 'center', marginTop: 6, fontFamily: "'Quicksand',sans-serif" }}>{unlockError}</p>}
                </div>
              )}

              {storeSlotCount === STORE_MAX_SLOTS && (
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6, padding: '12px 0' }}>
                  <div style={{ height: 1, flex: 1, background: 'rgba(255,255,255,0.06)' }} />
                  <span style={{ color: 'rgba(255,255,255,0.2)', fontSize: 11, fontWeight: 700, fontFamily: "'Quicksand',sans-serif" }}>All slots unlocked</span>
                  <div style={{ height: 1, flex: 1, background: 'rgba(255,255,255,0.06)' }} />
                </div>
              )}
            </div>
          )}
        </div>
      </div>
      <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>
    </>
  );
};

===== FILE: src/components/chemcity/PurchaseConfirmModal.tsx =====

import React, { useEffect, useState } from 'react';
import { X, Coins, Gem, CheckCircle, FlaskConical, Star, BookOpen, Zap } from 'lucide-react';
import { useChemCityStore } from '../../store/chemcityStore';
import { getEffectiveCoinPrice } from '../../lib/chemcity/shop';

function needsAnonymousCrossOrigin(url?: string | null): boolean {
  if (!url) return false;
  const u = url.toLowerCase();
  return u.includes('drive.google.com') || u.includes('googleusercontent.com');
}

const RARITY_CONFIG: Record<string, {
  borderColor: string; glowColor: string; bgGradient: string; artBg: string;
  badgeColor: string; badgeText: string;
}> = {
  common:    { borderColor: '#94a3b8', glowColor: 'rgba(148,163,184,0.3)', bgGradient: 'linear-gradient(165deg,#1e293b,#0f172a)', artBg: 'rgba(255,255,255,0.04)', badgeColor: 'rgba(148,163,184,0.2)', badgeText: '#94a3b8' },
  uncommon:  { borderColor: '#34d399', glowColor: 'rgba(52,211,153,0.35)',  bgGradient: 'linear-gradient(165deg,#0f3d33,#071a16)', artBg: 'rgba(52,211,153,0.06)',  badgeColor: 'rgba(52,211,153,0.18)', badgeText: '#34d399' },
  rare:      { borderColor: '#60a5fa', glowColor: 'rgba(96,165,250,0.4)',  bgGradient: 'linear-gradient(165deg,#1e3a5f,#0f172a)', artBg: 'rgba(96,165,250,0.07)',  badgeColor: 'rgba(96,165,250,0.2)',  badgeText: '#60a5fa' },
  epic:      { borderColor: '#a855f7', glowColor: 'rgba(168,85,247,0.4)',  bgGradient: 'linear-gradient(165deg,#2d1b4e,#0f0a1e)', artBg: 'rgba(168,85,247,0.07)',  badgeColor: 'rgba(168,85,247,0.2)',  badgeText: '#a855f7' },
  legendary: { borderColor: '#fbbf24', glowColor: 'rgba(251,191,36,0.5)',  bgGradient: 'linear-gradient(165deg,#3d2800,#1a0f00)', artBg: 'rgba(251,191,36,0.09)',  badgeColor: 'rgba(251,191,36,0.2)',  badgeText: '#fbbf24' },
};

type PurchaseCurrency = 'coins' | 'diamonds';

export const PurchaseConfirmModal: React.FC = () => {
  const user                  = useChemCityStore(s => s.user);
  const slimItems             = useChemCityStore(s => s.slimItems);
  const storePurchaseItemId   = useChemCityStore(s => s.storePurchaseItemId);
  const storePurchaseData     = useChemCityStore(s => s.storePurchaseData);
  const storePurchaseLoading  = useChemCityStore(s => s.storePurchaseLoading);
  const closePurchaseConfirm  = useChemCityStore(s => s.closePurchaseConfirm);
  const purchaseCard          = useChemCityStore(s => s.purchaseCard);

  const [purchasing, setPurchasing]         = useState(false);
  const [purchaseCurrency, setPurchaseCurrency] = useState<PurchaseCurrency>('coins');
  const [purchaseError, setPurchaseError]   = useState<string | null>(null);
  const [purchaseSuccess, setPurchaseSuccess] = useState(false);

  const isOpen = !!storePurchaseItemId;
  const slim   = slimItems.find(i => i.id === storePurchaseItemId);
  const full   = storePurchaseData;

  const isOwned  = !!user?.ownedItems?.includes(storePurchaseItemId ?? '');
  const rarity   = slim?.rarity ?? 'common';
  const cfg      = RARITY_CONFIG[rarity] ?? RARITY_CONFIG.common;
  const rarityStars = { common:1, uncommon:2, rare:2, epic:3, legendary:4 }[rarity] ?? 1;
  const discount = user?.activeBonuses.shopDiscountPercent ?? 0;
  const rawCoin  = slim?.shopData?.coinCost;
  const rawDiamond = slim?.shopData?.diamondCost;
  const effCoin  = rawCoin != null ? getEffectiveCoinPrice(rawCoin, user?.activeBonuses ?? null) : null;
  const coins    = user?.currencies.coins ?? 0;
  const diamonds = user?.currencies.diamonds ?? 0;
  const canAffordCoins    = effCoin != null && coins >= effCoin;
  const canAffordDiamonds = rawDiamond != null && diamonds >= rawDiamond;

  useEffect(() => {
    if (isOpen) {
      setPurchaseError(null);
      setPurchaseSuccess(false);
      setPurchasing(false);
      if (rawCoin != null) setPurchaseCurrency('coins');
      else if (rawDiamond != null) setPurchaseCurrency('diamonds');
    }
  }, [isOpen, storePurchaseItemId, rawCoin, rawDiamond]);

  if (!isOpen || !slim) return null;

  const handlePurchase = async () => {
    if (purchasing || isOwned) return;
    const canAfford = purchaseCurrency === 'coins' ? canAffordCoins : canAffordDiamonds;
    if (!canAfford) return;
    setPurchasing(true);
    setPurchaseError(null);
    try {
      await purchaseCard(slim.id, purchaseCurrency);
      setPurchaseSuccess(true);
      setTimeout(() => closePurchaseConfirm(), 1800);
    } catch (err: any) {
      setPurchaseError(err?.message ?? 'Purchase failed. Please try again.');
    } finally {
      setPurchasing(false);
    }
  };

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@500;600;700;800&display=swap');
        @keyframes purchaseIn { from{opacity:0;transform:scale(0.9) translateY(20px)} to{opacity:1;transform:scale(1) translateY(0)} }
        @keyframes shimmerSlide { 0%,100%{transform:translateX(-200%)} 50%{transform:translateX(200%)} }
        @keyframes legendGlow { 0%,100%{box-shadow:0 0 24px rgba(251,191,36,0.4)} 50%{box-shadow:0 0 44px rgba(251,191,36,0.7)} }
        @keyframes successPop { 0%{transform:scale(0.7);opacity:0} 60%{transform:scale(1.12)} 100%{transform:scale(1);opacity:1} }
        .purchase-panel { animation: purchaseIn 0.3s cubic-bezier(0.34,1.56,0.64,1) forwards; }
        .curr-tab { font-family:'Quicksand',sans-serif; font-weight:800; font-size:12px; padding:8px 16px; border-radius:10px; border:1.5px solid; cursor:pointer; transition:all 0.2s; display:flex; align-items:center; gap:6px; }
      `}</style>

      {/* Backdrop */}
      <div onClick={closePurchaseConfirm} style={{
        position: 'fixed', inset: 0, zIndex: 80,
        background: 'rgba(4,10,9,0.9)',
        backdropFilter: 'blur(14px)', WebkitBackdropFilter: 'blur(14px)',
        display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 16,
      }}>
        <div className="purchase-panel" onClick={e => e.stopPropagation()} style={{
          width: 'min(620px, 94vw)', maxHeight: '90vh',
          background: 'rgba(8,20,19,0.97)',
          backdropFilter: 'blur(24px)', WebkitBackdropFilter: 'blur(24px)',
          border: '1.5px solid rgba(197,215,181,0.18)',
          borderRadius: 24,
          boxShadow: '0 40px 100px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.05)',
          overflow: 'hidden', display: 'flex', flexDirection: 'column',
          fontFamily: "'Quicksand',sans-serif",
        }}>
          {/* Close */}
          <button onClick={closePurchaseConfirm} style={{
            position: 'absolute', top: 14, right: 14, zIndex: 10,
            background: 'rgba(255,255,255,0.08)', border: '1px solid rgba(255,255,255,0.12)',
            borderRadius: 8, width: 30, height: 30, cursor: 'pointer',
            display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#94a3b8',
          }}><X size={14} /></button>

          <div style={{ display: 'flex', gap: 0, flex: 1, minHeight: 0, overflow: 'hidden' }}>
            {/* ── Left: Vertical RPG Card ── */}
            <div style={{
              width: 200, flexShrink: 0, padding: '24px 0 24px 24px',
              display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 12,
            }}>
              {/* Card */}
              <div style={{
                width: 155, height: 220, borderRadius: 16,
                border: `2.5px solid ${cfg.borderColor}`,
                background: cfg.bgGradient,
                boxShadow: rarity === 'legendary'
                  ? `0 0 40px ${cfg.glowColor}, 0 8px 24px rgba(0,0,0,0.7)`
                  : `0 0 20px ${cfg.glowColor}, 0 6px 16px rgba(0,0,0,0.6)`,
                overflow: 'hidden', position: 'relative', flexShrink: 0,
                animation: rarity === 'legendary' ? 'legendGlow 2.5s ease-in-out infinite' : 'none',
              }}>
                {rarity === 'legendary' && (
                  <div style={{
                    position: 'absolute', inset: 0, zIndex: 1, pointerEvents: 'none',
                    background: 'linear-gradient(105deg,transparent 30%,rgba(255,215,0,0.13) 50%,transparent 70%)',
                    animation: 'shimmerSlide 3s ease-in-out infinite',
                  }} />
                )}
                {/* Stars */}
                <div style={{ position:'absolute', top:6, right:8, zIndex:3, color:cfg.badgeText, fontSize:10, letterSpacing:1 }}>
                  {'✦'.repeat(rarityStars)}
                </div>
                {/* Art */}
                <div style={{
                  height: 140, margin: '14px 10px 6px',
                  background: cfg.artBg, border: `1px solid ${cfg.borderColor}`,
                  borderRadius: 10, display: 'flex', alignItems: 'center', justifyContent: 'center',
                  overflow: 'hidden', position: 'relative', zIndex: 2,
                }}>
                  {(full?.imageUrl || slim.imageUrl) ? (
                    <img
                      src={full?.imageUrl || slim.imageUrl}
                      alt={slim.name}
                      style={{ width:'100%', height:'100%', objectFit:'cover' }}
                      {...(needsAnonymousCrossOrigin(full?.imageUrl || slim.imageUrl)
                        ? { crossOrigin: 'anonymous' as const, referrerPolicy: 'no-referrer' as const }
                        : {})}
                      onError={e => { (e.target as HTMLImageElement).style.display='none'; }}
                    />
                  ) : (
                    <span style={{ fontSize: 52 }}>{slim.emoji}</span>
                  )}
                </div>
                {/* Name / formula */}
                <div style={{ padding:'0 10px 4px', textAlign:'center', position:'relative', zIndex:2 }}>
                  <div style={{ color:'#f1f5f9', fontSize:11, fontWeight:800, overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap' }}>
                    {full?.displayName || slim.name}
                  </div>
                  <div style={{ color:'rgba(255,255,255,0.4)', fontSize:9, fontFamily:'monospace', marginTop:1 }}>
                    {slim.chemicalFormula}
                  </div>
                </div>
                {/* Rarity footer */}
                <div style={{
                  position:'absolute', bottom:8, left:10, right:10,
                  background:cfg.badgeColor, borderRadius:4, padding:'2px 0',
                  textAlign:'center', fontSize:8, fontWeight:800, color:cfg.badgeText,
                  textTransform:'uppercase', letterSpacing:'0.06em', zIndex:2,
                }}>{rarity}</div>

                {/* Owned stamp */}
                {isOwned && (
                  <div style={{
                    position:'absolute', inset:0, background:'rgba(0,0,0,0.55)', zIndex:4, borderRadius:14,
                    display:'flex', alignItems:'center', justifyContent:'center',
                  }}>
                    <div style={{ background:'rgba(74,222,128,0.9)', borderRadius:8, padding:'6px 14px', fontWeight:800, fontSize:12, color:'#052e16' }}>✓ Owned</div>
                  </div>
                )}
              </div>

              {/* Skill contribution */}
              {slim.skillContribution > 0 && (
                <div style={{
                  display:'flex', alignItems:'center', gap:6,
                  background:'rgba(118,168,165,0.12)', border:'1px solid rgba(118,168,165,0.3)',
                  borderRadius:8, padding:'6px 12px',
                }}>
                  <Zap size={12} color="#76A8A5" />
                  <span style={{ color:'rgba(197,215,181,0.8)', fontSize:11, fontWeight:700 }}>+{slim.skillContribution} Power</span>
                </div>
              )}
            </div>

            {/* ── Right: Info + Purchase ── */}
            <div style={{ flex:1, display:'flex', flexDirection:'column', minWidth:0, overflow:'hidden' }}>
              {/* Scrollable info */}
              <div style={{ flex:1, overflowY:'auto', padding:'24px 24px 12px' }}>
                <div style={{ color:'#fff', fontWeight:800, fontSize:17, marginBottom:4 }}>
                  {full?.displayName || slim.name}
                </div>
                <div style={{ color:'rgba(255,255,255,0.35)', fontFamily:'monospace', fontSize:12, marginBottom:12 }}>
                  {slim.chemicalFormula}
                </div>

                {storePurchaseLoading && (
                  <div style={{ display:'flex', flexDirection:'column', gap:8 }}>
                    {[1,2,3].map(i => <div key={i} style={{ height:14, background:'rgba(255,255,255,0.06)', borderRadius:6, animation:'pulse 1.5s infinite' }} />)}
                    <style>{`@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}`}</style>
                  </div>
                )}

                {full?.description && (
                  <p style={{ color:'rgba(255,255,255,0.6)', fontSize:12, lineHeight:1.7, margin:'0 0 12px', fontFamily:"'Quicksand',sans-serif" }}>
                    {full.description}
                  </p>
                )}

                {full?.educational?.funFact && (
                  <div style={{ background:'rgba(96,165,250,0.07)', border:'1px solid rgba(96,165,250,0.2)', borderRadius:10, padding:'10px 12px', marginBottom:10 }}>
                    <div style={{ display:'flex', alignItems:'center', gap:6, marginBottom:5 }}>
                      <FlaskConical size={11} color="#60a5fa" />
                      <span style={{ color:'#60a5fa', fontSize:10, fontWeight:800, textTransform:'uppercase', letterSpacing:'0.07em' }}>Fun Fact</span>
                    </div>
                    <p style={{ color:'rgba(255,255,255,0.65)', fontSize:11, lineHeight:1.6, margin:0 }}>{full.educational.funFact}</p>
                  </div>
                )}

                {full?.educational?.everydayUses && full.educational.everydayUses.length > 0 && (
                  <div style={{ marginBottom:10 }}>
                    <div style={{ display:'flex', alignItems:'center', gap:6, marginBottom:6 }}>
                      <Star size={10} color="#c5d7b5" />
                      <span style={{ color:'rgba(197,215,181,0.7)', fontSize:10, fontWeight:800, textTransform:'uppercase', letterSpacing:'0.07em' }}>Uses</span>
                    </div>
                    <div style={{ display:'flex', flexWrap:'wrap', gap:4 }}>
                      {full.educational.everydayUses.slice(0,5).map(use => (
                        <span key={use} style={{ background:'rgba(255,255,255,0.06)', border:'1px solid rgba(255,255,255,0.1)', borderRadius:6, padding:'3px 8px', fontSize:10, color:'rgba(255,255,255,0.6)', fontFamily:"'Quicksand',sans-serif", fontWeight:600 }}>{use}</span>
                      ))}
                    </div>
                  </div>
                )}

                {full?.topicConnections && full.topicConnections.length > 0 && (
                  <div>
                    <div style={{ display:'flex', alignItems:'center', gap:6, marginBottom:6 }}>
                      <BookOpen size={10} color="#86efac" />
                      <span style={{ color:'rgba(134,239,172,0.7)', fontSize:10, fontWeight:800, textTransform:'uppercase', letterSpacing:'0.07em' }}>DSE Topics</span>
                    </div>
                    <div style={{ display:'flex', flexWrap:'wrap', gap:4 }}>
                      {full.topicConnections.map(tid => (
                        <span key={tid} style={{ background:'rgba(134,239,172,0.08)', border:'1px solid rgba(134,239,172,0.25)', borderRadius:6, padding:'3px 8px', fontSize:10, color:'#86efac', fontFamily:"'Quicksand',sans-serif", fontWeight:600 }}>{tid}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>

              {/* ── Purchase Footer ── */}
              <div style={{ borderTop:'1px solid rgba(255,255,255,0.08)', padding:'14px 24px 20px', background:'rgba(0,0,0,0.2)', flexShrink:0 }}>
                {purchaseSuccess ? (
                  <div style={{ display:'flex', flexDirection:'column', alignItems:'center', gap:8, padding:'10px 0', animation:'successPop 0.4s ease forwards' }}>
                    <CheckCircle size={32} color="#4ade80" />
                    <span style={{ color:'#4ade80', fontWeight:800, fontSize:14 }}>Added to your collection!</span>
                  </div>
                ) : isOwned ? (
                  <div style={{ display:'flex', alignItems:'center', justifyContent:'center', gap:8, padding:'12px', background:'rgba(255,255,255,0.04)', border:'1px solid rgba(255,255,255,0.08)', borderRadius:12 }}>
                    <CheckCircle size={16} color="rgba(255,255,255,0.3)" />
                    <span style={{ color:'rgba(255,255,255,0.35)', fontWeight:700, fontSize:13 }}>Already in your collection</span>
                  </div>
                ) : (
                  <>
                    {/* Currency toggle */}
                    {effCoin != null && rawDiamond != null && (
                      <div style={{ display:'flex', gap:8, marginBottom:12 }}>
                        <button className="curr-tab" onClick={() => setPurchaseCurrency('coins')} style={{
                          flex:1, background: purchaseCurrency==='coins' ? 'rgba(251,191,36,0.15)' : 'rgba(255,255,255,0.05)',
                          borderColor: purchaseCurrency==='coins' ? 'rgba(251,191,36,0.5)' : 'rgba(255,255,255,0.1)',
                          color: purchaseCurrency==='coins' ? '#fbbf24' : 'rgba(255,255,255,0.4)',
                          justifyContent:'center',
                        }}>
                          <Coins size={14} /> Coins
                        </button>
                        <button className="curr-tab" onClick={() => setPurchaseCurrency('diamonds')} style={{
                          flex:1, background: purchaseCurrency==='diamonds' ? 'rgba(103,232,249,0.12)' : 'rgba(255,255,255,0.05)',
                          borderColor: purchaseCurrency==='diamonds' ? 'rgba(103,232,249,0.5)' : 'rgba(255,255,255,0.1)',
                          color: purchaseCurrency==='diamonds' ? '#67e8f9' : 'rgba(255,255,255,0.4)',
                          justifyContent:'center',
                        }}>
                          <Gem size={13} /> Diamonds
                        </button>
                      </div>
                    )}

                    {/* Price + balance */}
                    <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', marginBottom:10, padding:'10px 12px', background:'rgba(255,255,255,0.03)', borderRadius:10 }}>
                      <div>
                        {purchaseCurrency === 'coins' && effCoin != null && (
                          <div style={{ display:'flex', alignItems:'center', gap:8 }}>
                            <div style={{ display:'flex', alignItems:'center', gap:5 }}>
                              <Coins size={15} color="#fbbf24" />
                              <span style={{ color:'#fbbf24', fontWeight:800, fontSize:16 }}>{effCoin.toLocaleString()}</span>
                            </div>
                            {rawCoin != null && rawCoin !== effCoin && (
                              <span style={{ color:'rgba(255,255,255,0.25)', fontSize:12, textDecoration:'line-through' }}>{rawCoin.toLocaleString()}</span>
                            )}
                            {discount > 0 && (
                              <span style={{ background:'rgba(52,211,153,0.2)', border:'1px solid rgba(52,211,153,0.4)', borderRadius:20, padding:'1px 7px', fontSize:10, color:'#34d399', fontWeight:800 }}>{discount}% OFF</span>
                            )}
                          </div>
                        )}
                        {purchaseCurrency === 'diamonds' && rawDiamond != null && (
                          <div style={{ display:'flex', alignItems:'center', gap:5 }}>
                            <Gem size={14} color="#67e8f9" />
                            <span style={{ color:'#67e8f9', fontWeight:800, fontSize:16 }}>{rawDiamond.toLocaleString()}</span>
                          </div>
                        )}
                      </div>
                      <span style={{ color:'rgba(255,255,255,0.3)', fontSize:11, fontWeight:600 }}>
                        You have: {purchaseCurrency === 'coins' ? `${coins.toLocaleString()} 🪙` : `${diamonds.toLocaleString()} 💎`}
                      </span>
                    </div>

                    {purchaseError && <p style={{ color:'#f87171', fontSize:11, textAlign:'center', marginBottom:8 }}>{purchaseError}</p>}

                    {/* Shortfall notice */}
                    {purchaseCurrency === 'coins' && effCoin != null && !canAffordCoins && (
                      <p style={{ color:'rgba(251,191,36,0.7)', fontSize:11, textAlign:'center', marginBottom:8 }}>
                        Need {(effCoin - coins).toLocaleString()} more coins
                      </p>
                    )}
                    {purchaseCurrency === 'diamonds' && rawDiamond != null && !canAffordDiamonds && (
                      <p style={{ color:'rgba(103,232,249,0.7)', fontSize:11, textAlign:'center', marginBottom:8 }}>
                        Need {(rawDiamond - diamonds).toLocaleString()} more diamonds
                      </p>
                    )}

                    <button onClick={handlePurchase} disabled={
                      purchasing ||
                      (purchaseCurrency==='coins' && (!canAffordCoins || effCoin==null)) ||
                      (purchaseCurrency==='diamonds' && (!canAffordDiamonds || rawDiamond==null))
                    } style={{
                      width:'100%', padding:'13px',
                      borderRadius:12, border:'none',
                      background: purchasing ? 'rgba(255,255,255,0.08)'
                        : purchaseCurrency==='coins' && canAffordCoins ? 'linear-gradient(135deg, #b45309, #92400e)'
                        : purchaseCurrency==='diamonds' && canAffordDiamonds ? 'linear-gradient(135deg, #0e7490, #164e63)'
                        : 'rgba(255,255,255,0.06)',
                      color: (purchaseCurrency==='coins' && canAffordCoins) || (purchaseCurrency==='diamonds' && canAffordDiamonds) ? '#fff' : 'rgba(255,255,255,0.3)',
                      fontWeight:800, fontSize:14, cursor: purchasing ? 'not-allowed' : 'pointer',
                      fontFamily:"'Quicksand',sans-serif",
                      boxShadow: (purchaseCurrency==='coins' && canAffordCoins) ? '0 4px 20px rgba(180,83,9,0.4)' : 'none',
                      transition:'all 0.2s',
                      display:'flex', alignItems:'center', justifyContent:'center', gap:8,
                    }}>
                      {purchasing ? (
                        <div style={{ width:16, height:16, border:'2px solid rgba(255,255,255,0.2)', borderTopColor:'#fff', borderRadius:'50%', animation:'spin 0.8s linear infinite' }} />
                      ) : purchaseCurrency==='coins' && effCoin != null ? (
                        <><Coins size={16} />Buy for {effCoin.toLocaleString()} coins</>
                      ) : rawDiamond != null ? (
                        <><Gem size={15} />Buy for {rawDiamond.toLocaleString()} diamonds</>
                      ) : 'Not for sale'}
                    </button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
      <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>
    </>
  );
};

===== FILE: src/components/chemcity/ChemCityRoot.tsx =====

import React, { useEffect } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useChemCityStore } from '../../store/chemcityStore';
import { CurrencyBar } from './CurrencyBar';
import { ChemCityMap } from './ChemCityMap';
import { PlaceView } from './PlaceView';
import { CardInventory } from './CardInventory';
import { CardPicker } from './CardPicker';
import { CardDetail } from './CardDetail';
import { DailyLoginModal } from './DailyLoginModal';
import { QuizRewardModal } from './QuizRewardModal';
import { ChemStore } from './ChemStore';
import { PurchaseConfirmModal } from './PurchaseConfirmModal';
import { PlaceUnlockModal } from './PlaceUnlockModal';
import { GasStationDistributor } from './GasStationDistributor';
import { CollectionsAlbum } from './CollectionsAlbum';
import { OnboardingOverlay } from './OnboardingOverlay';
import { GachaScreen } from './gacha/GachaScreen';
import { CosmeticsInventory } from './gacha/CosmeticsInventory';

export const ChemCityRoot: React.FC = () => {
  const { currentUser } = useAuth();

  const view = useChemCityStore((s) => s.view);
  const isLoading = useChemCityStore((s) => s.isLoading);
  const error = useChemCityStore((s) => s.error);
  const loadAll = useChemCityStore((s) => s.loadAll);
  const teardown = useChemCityStore((s) => s.teardown);
  const dailyLoginOpen = useChemCityStore((s) => s.dailyLogin.showModal);
  const showOnboarding = useChemCityStore((s) => s.showOnboarding);

  useEffect(() => {
    if (!currentUser?.uid) return;
    loadAll(currentUser.uid);
    return () => {
      teardown();
    };
  }, [currentUser?.uid, loadAll, teardown]);

  if (!currentUser) {
    return (
      <div className="flex flex-col min-h-screen bg-slate-950 items-center justify-center gap-4 px-8">
        <span className="text-5xl">🧪</span>
        <p className="text-slate-400 text-sm text-center">Please sign in to access ChemCity.</p>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex flex-col min-h-screen bg-slate-950 items-center justify-center gap-4">
        <span className="text-5xl animate-pulse">🧪</span>
        <p className="text-slate-400 text-sm">Loading ChemCity...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col min-h-screen bg-slate-950 items-center justify-center gap-4 px-8">
        <span className="text-4xl">⚠️</span>
        <p className="text-red-400 text-sm text-center">{error}</p>
        <button
          onClick={() => window.location.reload()}
          className="bg-slate-700 hover:bg-slate-600 text-white rounded-lg px-4 py-2 text-sm"
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div className="relative flex flex-col min-h-screen bg-slate-950 text-white overflow-hidden">
      <CurrencyBar />

      <main className="flex-1 overflow-hidden flex flex-col">
        {view === 'map' && <ChemCityMap />}
        {view === 'place' && <PlaceView />}
        {view === 'inventory' && <CardInventory />}
        {view === 'store' && <ChemStore />}
        {view === 'gas_station_distributor' && <GasStationDistributor />}
        {view === 'collections' && <CollectionsAlbum />}
        {view === 'gacha' && <GachaScreen />}
        {view === 'cosmetics' && <CosmeticsInventory />}
      </main>

      <CardPicker />
      <CardDetail />

      <DailyLoginModal />
      {!dailyLoginOpen && <QuizRewardModal />}

      <PlaceUnlockModal />
      <PurchaseConfirmModal />

      {showOnboarding && <OnboardingOverlay />}
    </div>
  );
};


===== FILE: src/components/chemcity/CurrencyBar.tsx =====

import React, { useMemo, useState } from 'react';
import { Coins, Gem, ChevronLeft, Sparkles, BookOpen, ShoppingBag, Archive, Fuel, X, Zap, Ticket } from 'lucide-react';
import { useChemCityStore } from '../../store/chemcityStore';

export const CurrencyBar: React.FC = () => {
  const user               = useChemCityStore(s => s.user);
  const places             = useChemCityStore(s => s.places);
  const view               = useChemCityStore(s => s.view);
  const selectedPlaceId    = useChemCityStore(s => s.selectedPlaceId);
  const navigateToMap      = useChemCityStore(s => s.navigateToMap);
  const navigateToInventory = useChemCityStore(s => s.navigateToInventory);
  const navigateToStore    = useChemCityStore(s => s.navigateToStore);
  const navigateToCollections = useChemCityStore(s => s.navigateToCollections);
  const navigateToGasStationDistributor = useChemCityStore(s => s.navigateToGasStationDistributor);
  const navigateToGacha    = useChemCityStore(s => (s as any).navigateToGacha);
  const navigateToCosmetics = useChemCityStore(s => (s as any).navigateToCosmetics);

  const [skillsOpen, setSkillsOpen] = useState(false);

  const coins    = user?.currencies.coins ?? 0;
  const diamonds = user?.currencies.diamonds ?? 0;
  const tickets  = (user?.currencies as any)?.tickets ?? 0;

  const showGasDistributorButton = view === 'place' && selectedPlaceId === 'gas_station' && (user?.extraSlotsBudget ?? 0) > 0;

  const skillSummaryByPlaceId = useMemo(() => {
    const b = user?.activeBonuses;
    if (!b) return {} as Record<string, string>;
    return {
      garden:             `${b.passiveBaseCoinsPerHour.toLocaleString()} coins/hr`,
      lab:                `${b.passiveMultiplier.toFixed(1)}× multiplier`,
      kitchen:            `+${b.quizFlatDiamondBonus} diamond bonus`,
      school:             `${b.quizDiamondMultiplier.toFixed(1)}× quiz diamonds`,
      beach:              `${b.quizDoubleChancePercent}% double chance`,
      toilet:             `${b.dailyLoginDiamonds} daily diamonds`,
      gas_station:        `${b.extraSlotsTotal} bonus slots`,
      lifestyle_boutique: `${b.shopDiscountPercent}% store discount`,
    };
  }, [user?.activeBonuses]);

  const NavBtn: React.FC<{
    onClick: () => void; active: boolean; label: string; children: React.ReactNode; accent?: boolean;
  }> = ({ onClick, active, label, children, accent }) => (
    <button onClick={onClick} title={label} aria-label={label} style={{
      width: 36, height: 36, borderRadius: 10,
      border: `1.5px solid ${active ? 'rgba(118,168,165,0.6)' : accent ? 'rgba(251,191,36,0.4)' : 'rgba(255,255,255,0.12)'}`,
      background: active
        ? 'rgba(118,168,165,0.25)'
        : accent ? 'rgba(251,191,36,0.12)' : 'rgba(8,20,19,0.9)',
      backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
      color: active ? '#C5D7B5' : accent ? '#fbbf24' : '#94a3b8',
      cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center',
      transition: 'all 0.2s ease',
      boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
    }}>
      {children}
    </button>
  );

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@500;600;700;800&display=swap');
        .skills-row:hover { background: rgba(255,255,255,0.06) !important; }
      `}</style>

      <div style={{
        position: 'fixed', top: 84, left: 12, right: 12, zIndex: 50,
        display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8,
        pointerEvents: 'none',
        fontFamily: "'Quicksand',sans-serif",
      }}>
        {/* Left: Back button */}
        <div style={{ pointerEvents: 'auto' }}>
          {view !== 'map' && (
            <button onClick={navigateToMap} title="Back to map" aria-label="Back to map" style={{
              width: 36, height: 36, borderRadius: 10,
              border: '1.5px solid rgba(255,255,255,0.12)',
              background: 'rgba(8,20,19,0.9)',
              backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
              color: '#94a3b8', cursor: 'pointer',
              display: 'flex', alignItems: 'center', justifyContent: 'center',
              boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
              transition: 'all 0.2s',
            }}>
              <ChevronLeft size={18} />
            </button>
          )}
        </div>

        {/* Right: Currency pills + nav buttons */}
        <div style={{ display: 'flex', alignItems: 'center', gap: 7, pointerEvents: 'auto' }}>
          {/* Coins pill */}
          <div style={{
            display: 'flex', alignItems: 'center', gap: 6,
            background: 'rgba(8,20,19,0.9)',
            border: '1.5px solid rgba(251,191,36,0.25)',
            backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
            borderRadius: 20, padding: '5px 10px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
          }}>
            <Coins size={13} color="#fbbf24" />
            <span style={{ color: '#fff', fontSize: 13, fontWeight: 800, fontVariantNumeric: 'tabular-nums' }}>
              {coins.toLocaleString()}
            </span>
          </div>

          {/* Diamonds pill */}
          <div style={{
            display: 'flex', alignItems: 'center', gap: 6,
            background: 'rgba(8,20,19,0.9)',
            border: '1.5px solid rgba(103,232,249,0.25)',
            backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
            borderRadius: 20, padding: '5px 10px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
          }}>
            <Gem size={12} color="#67e8f9" />
            <span style={{ color: '#fff', fontSize: 13, fontWeight: 800, fontVariantNumeric: 'tabular-nums' }}>
              {diamonds.toLocaleString()}
            </span>
          </div>

          {/* Tickets pill */}
          <div style={{
            display: 'flex', alignItems: 'center', gap: 6,
            background: 'rgba(8,20,19,0.9)',
            border: '1.5px solid rgba(167,139,250,0.25)',
            backdropFilter: 'blur(12px)', WebkitBackdropFilter: 'blur(12px)',
            borderRadius: 20, padding: '5px 10px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
          }}>
            <Ticket size={12} color="#a78bfa" />
            <span style={{ color: '#fff', fontSize: 13, fontWeight: 800, fontVariantNumeric: 'tabular-nums' }}>
              {Number(tickets || 0).toLocaleString()}
            </span>
          </div>

          <NavBtn onClick={() => setSkillsOpen(true)} active={false} label="Skill Boosts">
            <Sparkles size={15} />
          </NavBtn>
          <NavBtn onClick={navigateToCollections} active={view === 'collections'} label="Collections Album">
            <BookOpen size={15} />
          </NavBtn>
          <NavBtn onClick={navigateToStore} active={view === 'store'} label="ChemStore">
            <ShoppingBag size={15} />
          </NavBtn>
          <NavBtn onClick={() => navigateToGacha?.()} active={view === 'gacha'} label="Gacha Machine" accent>
            <Ticket size={15} />
          </NavBtn>
          <NavBtn onClick={() => navigateToCosmetics?.()} active={view === 'cosmetics'} label="Cosmetics" accent>
            <Sparkles size={15} />
          </NavBtn>
          <NavBtn onClick={navigateToInventory} active={view === 'inventory'} label="Card Inventory">
            <Archive size={15} />
          </NavBtn>
          {showGasDistributorButton && (
            <NavBtn onClick={navigateToGasStationDistributor} active={false} label="Distribute Bonus Slots" accent>
              <Fuel size={15} />
            </NavBtn>
          )}
        </div>
      </div>

      {/* ── Skills Modal ── */}
      {skillsOpen && (
        <div
          onClick={() => setSkillsOpen(false)}
          style={{
            position: 'fixed', inset: 0, zIndex: 60,
            background: 'rgba(4,10,9,0.88)',
            backdropFilter: 'blur(14px)', WebkitBackdropFilter: 'blur(14px)',
            display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 16,
          }}
        >
          <div onClick={e => e.stopPropagation()} style={{
            width: 'min(420px, 94vw)',
            background: 'rgba(8,20,19,0.97)',
            border: '1.5px solid rgba(197,215,181,0.18)',
            borderRadius: 20,
            boxShadow: '0 32px 80px rgba(0,0,0,0.7)',
            overflow: 'hidden',
            fontFamily: "'Quicksand',sans-serif",
          }}>
            {/* Header */}
            <div style={{
              padding: '16px 18px', borderBottom: '1px solid rgba(197,215,181,0.1)',
              display: 'flex', alignItems: 'center', justifyContent: 'space-between',
              background: 'linear-gradient(135deg, rgba(118,168,165,0.12) 0%, transparent)',
            }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                <div style={{ background:'rgba(118,168,165,0.2)', border:'1.5px solid rgba(118,168,165,0.4)', borderRadius:10, width:36, height:36, display:'flex', alignItems:'center', justifyContent:'center' }}>
                  <Sparkles size={16} color="#76A8A5" />
                </div>
                <div>
                  <div style={{ color: '#fff', fontWeight: 800, fontSize: 15 }}>Skill Boosts</div>
                  <div style={{ color: 'rgba(197,215,181,0.5)', fontSize: 11, fontWeight: 600 }}>Active card bonuses</div>
                </div>
              </div>
              <button onClick={() => setSkillsOpen(false)} style={{
                background: 'rgba(255,255,255,0.07)', border: '1.5px solid rgba(255,255,255,0.12)',
                borderRadius: 8, width: 30, height: 30, cursor: 'pointer',
                display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#94a3b8',
              }}><X size={14} /></button>
            </div>

            {/* Skills list */}
            <div style={{ padding: '12px', display: 'flex', flexDirection: 'column', gap: 6, maxHeight: '65vh', overflowY: 'auto' }}>
              {places.map(p => (
                <div key={p.id} className="skills-row" style={{
                  display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 12,
                  background: 'rgba(255,255,255,0.03)', border: '1px solid rgba(255,255,255,0.07)',
                  borderRadius: 12, padding: '10px 14px',
                  transition: 'background 0.2s',
                }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 10, minWidth: 0 }}>
                    <div style={{ fontSize: 20, flexShrink: 0 }}>{p.emoji}</div>
                    <div style={{ minWidth: 0 }}>
                      <div style={{ color: '#fff', fontWeight: 800, fontSize: 12 }}>{p.displayName}</div>
                      <div style={{ color: 'rgba(197,215,181,0.4)', fontSize: 10, fontWeight: 600, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {p.skill.description}
                      </div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 5, flexShrink: 0 }}>
                    <Zap size={10} color="#76A8A5" />
                    <span style={{ color: '#76A8A5', fontWeight: 800, fontSize: 12 }}>
                      {skillSummaryByPlaceId[p.id] ?? '—'}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </>
  );
};

===== FILE: src/store/chemcityStore.ts =====

import { create } from 'zustand';
import { doc, getDoc, onSnapshot, type Unsubscribe } from 'firebase/firestore';
import { db } from '../firebase/config';
import { fetchSlimItems, fetchPlaces, fetchFullItem, fetchCollections } from '../lib/cache';
import type {
  UserChemCityData,
  UserProgressData,
  SlimItemDocument,
  PlaceDocument,
  FullItemDocument,
  CollectionDocument,
  Cosmetic,
  GachaBanner,
} from '../lib/chemcity/types';
import {
  callChemCityInitUser,
  callChemCityMigrateSlotIds,
  callChemCityEquipCard,
  callChemCityUnequipCard,
  callChemCityCollectPassiveIncome,
  callChemCityUnlockPlace,
  callChemCityUnlockSlot,
  callChemCityGetDailyLoginBonus,
  callChemCityQuizReward,
  callChemCityPurchaseCard,
  callChemCityUnlockStoreSlot,
  callChemCityClaimCollectionReward,
  callChemCityDevGrantCoins,
} from '../lib/chemcity/cloudFunctions';
import { estimateUnclaimedCoins } from '../lib/chemcity/income';
import { getDailyStoreItems, STORE_MIN_SLOTS } from '../lib/chemcity/dailyStore';
import type { QuizRewardRequest, QuizRewardResult } from '../lib/chemcity/types';
import { getActiveBanners, getCosmeticsMap } from '../lib/chemcity/gachaStaticCache';
import { getServerCacheVersion } from '../lib/cache';

const ONBOARDING_STORAGE_KEY = 'chemcity_onboarding_done_v1';
const DISABLE_FIRESTORE_LISTENERS =
  String((import.meta as any).env?.VITE_DISABLE_FIRESTORE_LISTENERS ?? '').trim() === '1';
const USER_POLL_INTERVAL_MS = 15_000;

function hasSeenOnboarding(): boolean {
  try {
    return localStorage.getItem(ONBOARDING_STORAGE_KEY) === '1';
  } catch {
    return false;
  }
}

function markOnboardingDone(): void {
  try {
    localStorage.setItem(ONBOARDING_STORAGE_KEY, '1');
  } catch {
    // ignore
  }
}

type View = 'map' | 'place' | 'inventory' | 'store' | 'gas_station_distributor' | 'collections';

type GachaView = 'gacha' | 'cosmetics';

type ExtendedView = View | GachaView;

type RootUserDoc = {
  chemcity?: UserChemCityData;
} & Record<string, unknown>;

interface ChemCityStore {
  user: UserChemCityData | null;
  userGender: 'boy' | 'girl' | null;
  progress: UserProgressData | null;
  slimItems: SlimItemDocument[];
  places: PlaceDocument[];
  collections: CollectionDocument[];

  cosmeticsMap: Map<string, Cosmetic>;
  activeBanners: GachaBanner[];
  gachaStaticLoaded: boolean;
  gachaStaticVersion: number | null;

  isLoading: boolean;
  error: string | null;

  view: ExtendedView;
  selectedPlaceId: string | null;

  cardPickerSlotId: string | null;

  cardDetailItemId: string | null;
  cardDetailData: FullItemDocument | null;
  cardDetailLoading: boolean;

  passiveDisplayCoins: number;

  // Phase 4: store + unlock modals
  dailyStoreItems: SlimItemDocument[];
  storeSlotCount: number;
  storePurchaseItemId: string | null;
  storePurchaseData: FullItemDocument | null;
  storePurchaseLoading: boolean;
  placeUnlockModalId: string | null;

  quizReward: {
    result: QuizRewardResult | null;
    correctAnswers: number;
    totalQuestions: number;
    isAwarding: boolean;
  };

  dailyLogin: {
    diamonds: number;
    coins: number;
    streak: number;
    showModal: boolean;
    checked: boolean;
  };

  showOnboarding: boolean;

  _unsubUser: Unsubscribe | null;
  _userPollTimer: number | null;

  loadAll: (userId: string) => Promise<void>;
  teardown: () => void;

  navigateToMap: () => void;
  navigateToPlace: (placeId: string) => void;
  navigateToInventory: () => void;
  navigateToStore: () => void;
  navigateToGasStationDistributor: () => void;
  navigateToCollections: () => void;
  navigateToGacha: () => void;
  navigateToCosmetics: () => void;

  openCardPicker: (slotId: string) => void;
  closeCardPicker: () => void;

  openCardDetail: (itemId: string) => Promise<void>;
  closeCardDetail: () => void;

  equipCard: (slotId: string, itemId: string) => Promise<void>;
  unequipCard: (slotId: string) => Promise<void>;

  collectIncome: () => Promise<{ coinsAwarded: number }>;

  unlockPlace: (placeId: string) => Promise<void>;
  unlockSlot: (placeId: string, slotId: string, useExtraSlotBudget?: boolean) => Promise<void>;

  tickPassiveDisplay: () => void;

  awardQuizReward: (request: QuizRewardRequest) => Promise<void>;
  clearQuizReward: () => void;

  checkDailyLogin: () => Promise<void>;
  dismissDailyLogin: () => void;

  computeDailyStore: (userId: string) => void;
  unlockStoreSlot: () => Promise<void>;

  devRefreshStaticData: () => Promise<void>;
  devGrantCoins: (amount: number) => Promise<void>;
  devRerollStore: () => void;

  loadGachaStatic: () => Promise<void>;

  openPurchaseConfirm: (itemId: string) => void;
  closePurchaseConfirm: () => void;
  purchaseCard: (itemId: string, currency: 'coins' | 'diamonds') => Promise<void>;

  openPlaceUnlockModal: (placeId: string) => void;
  closePlaceUnlockModal: () => void;

  claimCollectionReward: (collectionId: string) => Promise<void>;
  dismissOnboarding: () => void;
}

export const useChemCityStore = create<ChemCityStore>((set, get) => ({
  user: null,
  userGender: null,
  progress: null,
  slimItems: [],
  places: [],
  collections: [],

  cosmeticsMap: new Map(),
  activeBanners: [],
  gachaStaticLoaded: false,
  gachaStaticVersion: null,

  isLoading: false,
  error: null,

  view: 'map',
  selectedPlaceId: null,

  cardPickerSlotId: null,

  cardDetailItemId: null,
  cardDetailData: null,
  cardDetailLoading: false,

  passiveDisplayCoins: 0,

  dailyStoreItems: [],
  storeSlotCount: STORE_MIN_SLOTS,
  storePurchaseItemId: null,
  storePurchaseData: null,
  storePurchaseLoading: false,
  placeUnlockModalId: null,

  quizReward: {
    result: null,
    correctAnswers: 0,
    totalQuestions: 0,
    isAwarding: false,
  },

  dailyLogin: {
    diamonds: 0,
    coins: 0,
    streak: 0,
    showModal: false,
    checked: false,
  },

  showOnboarding: false,

  _unsubUser: null,
  _userPollTimer: null,

  loadAll: async (userId: string) => {
    set({ isLoading: true, error: null });
    try {
      const [slimItems, places, collections] = await Promise.all([
        fetchSlimItems(),
        fetchPlaces(),
        fetchCollections(),
      ]);

      await callChemCityInitUser();
      await callChemCityMigrateSlotIds();

      const userRef = doc(db, 'users', userId);
      const userSnap = await getDoc(userRef);
      const root = (userSnap.data() || {}) as RootUserDoc;
      const chemcity = (root.chemcity || null) as UserChemCityData | null;

      const progressRef = doc(db, 'users', userId, 'chemcity_progress', 'data');
      const progressSnap = await getDoc(progressRef);
      const progress = (progressSnap.data() || null) as UserProgressData | null;

      const existing = get()._unsubUser;
      if (existing) existing();
      const existingTimer = get()._userPollTimer;
      if (existingTimer) window.clearInterval(existingTimer);

      if (!DISABLE_FIRESTORE_LISTENERS) {
        const unsub = onSnapshot(userRef, (snap) => {
          if (!snap.exists()) return;
          const freshRoot = (snap.data() || {}) as RootUserDoc;
          const fresh = (freshRoot.chemcity || null) as UserChemCityData | null;
          const genderRaw = (freshRoot as any)?.gender;
          const userGender: 'boy' | 'girl' | null =
            genderRaw === 'girl' ? 'girl' : genderRaw === 'boy' ? 'boy' : null;

          // Phase 4: mirror storeSlotCount (default 3) + compute daily store items
          const slotCount = (fresh as any)?.storeSlotCount ?? STORE_MIN_SLOTS;
          const pool = get().slimItems;
          const dailyStoreItems = fresh ? getDailyStoreItems(userId, pool, slotCount) : [];

          set({ user: fresh, userGender, storeSlotCount: slotCount, dailyStoreItems });
        });

        const progressUnsub = onSnapshot(progressRef, (snap) => {
          if (!snap.exists()) return;
          set({ progress: (snap.data() || null) as any });
        });

        set({ _unsubUser: () => { unsub(); progressUnsub(); }, _userPollTimer: null });
      } else {
        // Fallback: polling to avoid Listen/channel transport issues in some environments.
        const poll = async () => {
          try {
            const snap = await getDoc(userRef);
            if (!snap.exists()) return;
            const freshRoot = (snap.data() || {}) as RootUserDoc;
            const fresh = (freshRoot.chemcity || null) as UserChemCityData | null;
            const genderRaw = (freshRoot as any)?.gender;
            const userGender: 'boy' | 'girl' | null =
              genderRaw === 'girl' ? 'girl' : genderRaw === 'boy' ? 'boy' : null;
            const slotCount = (fresh as any)?.storeSlotCount ?? STORE_MIN_SLOTS;
            const pool = get().slimItems;
            const dailyStoreItems = fresh ? getDailyStoreItems(userId, pool, slotCount) : [];
            set({ user: fresh, userGender, storeSlotCount: slotCount, dailyStoreItems });
          } catch {
            // ignore
          }
        };

        // Immediate poll then interval
        poll();
        const timer = window.setInterval(poll, USER_POLL_INTERVAL_MS);
        set({ _unsubUser: null, _userPollTimer: timer });
      }

      const showOnboarding = (() => {
        if (hasSeenOnboarding()) return false;
        const createdAt = (chemcity as any)?.createdAt;
        if (!createdAt) return true;
        const createdMs =
          typeof createdAt?.toMillis === 'function'
            ? createdAt.toMillis()
            : typeof createdAt === 'number'
              ? createdAt
              : Date.now();
        return Date.now() - createdMs < 90_000;
      })();

      set({
        user: chemcity,
        progress,
        slimItems,
        places,
        collections,
        isLoading: false,
        passiveDisplayCoins: 0,
        storeSlotCount: (chemcity as any)?.storeSlotCount ?? STORE_MIN_SLOTS,
        dailyStoreItems: chemcity
          ? getDailyStoreItems(userId, slimItems, (chemcity as any)?.storeSlotCount ?? STORE_MIN_SLOTS)
          : [],
        showOnboarding,
      });

      // Phase 3: check daily login bonus (non-blocking)
      get().checkDailyLogin();

      // Phase 4: compute store (non-blocking)
      setTimeout(() => get().computeDailyStore(userId), 200);

      // Gacha: load static catalog (non-blocking)
      setTimeout(() => get().loadGachaStatic(), 250);
    } catch (err: any) {
      set({ isLoading: false, error: err?.message || 'Failed to load ChemCity' });
    }
  },

  devGrantCoins: async (amount: number) => {
    if (!Number.isFinite(amount) || amount === 0) return;
    await callChemCityDevGrantCoins(amount);
  },

  devRerollStore: () => {
    const userId = get().user?.userId;
    if (!userId) return;
    const pool = get().slimItems;
    const slotCount = get().storeSlotCount ?? STORE_MIN_SLOTS;
    const salt = Math.random().toString(36).slice(2, 10);
    const dailyStoreItems = getDailyStoreItems(`${userId}:dev:${salt}`, pool, slotCount);
    set({ dailyStoreItems });
  },

  loadGachaStatic: async () => {
    try {
      const serverVersion = await getServerCacheVersion();
      const prevVersion = get().gachaStaticVersion;
      if (get().gachaStaticLoaded && prevVersion === serverVersion) return;

      const [cosmeticsMap, activeBanners] = await Promise.all([
        getCosmeticsMap(),
        getActiveBanners(),
      ]);
      set({ cosmeticsMap, activeBanners, gachaStaticLoaded: true, gachaStaticVersion: serverVersion });
    } catch (err: any) {
      console.error('[Gacha] Failed to load static data:', err);
      // Still mark as loaded so UI shows (with empty data if needed)
      set({ gachaStaticLoaded: true });
    }
  },

  teardown: () => {
    const unsub = get()._unsubUser;
    if (unsub) unsub();
    const t = get()._userPollTimer;
    if (t) window.clearInterval(t);
    set({ _unsubUser: null, _userPollTimer: null, userGender: null });
  },

  navigateToMap: () => set({ view: 'map', selectedPlaceId: null }),
  navigateToPlace: (placeId) => set({ view: 'place', selectedPlaceId: placeId }),
  navigateToInventory: () => set({ view: 'inventory' }),
  navigateToStore: () => set({ view: 'store' }),
  navigateToGasStationDistributor: () => set({ view: 'gas_station_distributor' }),
  navigateToCollections: () => set({ view: 'collections' }),
  navigateToGacha: () => set({ view: 'gacha' }),
  navigateToCosmetics: () => set({ view: 'cosmetics' }),

  openCardPicker: (slotId) => set({ cardPickerSlotId: slotId }),
  closeCardPicker: () => set({ cardPickerSlotId: null }),

  openCardDetail: async (itemId: string) => {
    set({ cardDetailItemId: itemId, cardDetailData: null, cardDetailLoading: true });
    try {
      const full = await fetchFullItem(itemId);
      set({ cardDetailData: full ?? null, cardDetailLoading: false });
    } catch {
      set({ cardDetailLoading: false });
    }
  },
  closeCardDetail: () => set({ cardDetailItemId: null, cardDetailData: null, cardDetailLoading: false }),

  equipCard: async (slotId, itemId) => {
    const { user } = get();
    if (!user) return;

    // Optimistic update - show equipped immediately
    const previousEquipped = user.equipped?.[slotId];
    set({
      user: {
        ...user,
        equipped: { ...user.equipped, [slotId]: itemId },
      },
    });

    try {
      await callChemCityEquipCard(slotId, itemId);
    } catch (err) {
      // Revert on error
      set({
        user: {
          ...user,
          equipped: { ...user.equipped, [slotId]: previousEquipped },
        },
      });
      throw err;
    }
  },

  unequipCard: async (slotId) => {
    const { user } = get();
    if (!user) return;

    // Optimistic update - show unequipped immediately
    const previousEquipped = user.equipped?.[slotId];
    const newEquipped = { ...user.equipped };
    delete newEquipped[slotId];

    set({
      user: {
        ...user,
        equipped: newEquipped,
      },
    });

    try {
      await callChemCityUnequipCard(slotId);
    } catch (err) {
      // Revert on error
      set({
        user: {
          ...user,
          equipped: { ...user.equipped, [slotId]: previousEquipped },
        },
      });
      throw err;
    }
  },

  collectIncome: async () => {
    const result = await callChemCityCollectPassiveIncome();
    set({ passiveDisplayCoins: 0 });
    return { coinsAwarded: Number(result.coinsAwarded || 0) };
  },

  unlockPlace: async (placeId) => {
    await callChemCityUnlockPlace(placeId);
  },

  unlockSlot: async (placeId, slotId, useExtraSlotBudget) => {
    await callChemCityUnlockSlot(placeId, slotId, useExtraSlotBudget);
  },

  computeDailyStore: (userId: string) => {
    const state = get();
    if (!state.user) return;
    const slotCount = state.storeSlotCount ?? STORE_MIN_SLOTS;
    const dailyStoreItems = getDailyStoreItems(userId, state.slimItems, slotCount);
    set({ dailyStoreItems });
  },

  devRefreshStaticData: async () => {
    try {
      localStorage.removeItem('cc_manifest');
      localStorage.removeItem('cc_slim_items');
      localStorage.removeItem('cc_places');
      localStorage.removeItem('cc_collections');
      localStorage.removeItem('cc_topics');
    } catch {
      // ignore
    }

    set({ gachaStaticLoaded: false, gachaStaticVersion: null });

    const userId = get().user?.userId;
    if (!userId) return;

    set({ isLoading: true, error: null });
    try {
      const [slimItems, places, collections] = await Promise.all([
        fetchSlimItems(),
        fetchPlaces(),
        fetchCollections(),
      ]);

      const slotCount = get().storeSlotCount ?? STORE_MIN_SLOTS;
      const dailyStoreItems = getDailyStoreItems(userId, slimItems, slotCount);

      set({ slimItems, places, collections, dailyStoreItems, isLoading: false });
    } catch (err: any) {
      set({ isLoading: false, error: err?.message || 'Failed to refresh ChemCity data' });
    }
  },

  unlockStoreSlot: async () => {
    await callChemCityUnlockStoreSlot();
  },

  openPurchaseConfirm: (itemId: string) => {
    set({ storePurchaseItemId: itemId, storePurchaseData: null, storePurchaseLoading: true });
    fetchFullItem(itemId)
      .then((data) => set({ storePurchaseData: data ?? null, storePurchaseLoading: false }))
      .catch(() => set({ storePurchaseLoading: false }));
  },

  closePurchaseConfirm: () =>
    set({ storePurchaseItemId: null, storePurchaseData: null, storePurchaseLoading: false }),

  purchaseCard: async (itemId: string, currency: 'coins' | 'diamonds') => {
    await callChemCityPurchaseCard(itemId, currency);
  },

  openPlaceUnlockModal: (placeId: string) => set({ placeUnlockModalId: placeId }),
  closePlaceUnlockModal: () => set({ placeUnlockModalId: null }),

  tickPassiveDisplay: () => {
    const user = get().user;
    if (!user) return;

    const lastCollected = (user.passiveIncome?.lastCollected ?? null) as any;
    const coins = estimateUnclaimedCoins(user.activeBonuses, lastCollected);
    set({ passiveDisplayCoins: coins });
  },

  awardQuizReward: async (request) => {
    set((s) => ({
      quizReward: {
        ...s.quizReward,
        isAwarding: true,
        result: null,
      },
    }));

    try {
      const result = await callChemCityQuizReward(request);
      set({
        quizReward: {
          result,
          correctAnswers: request.correctAnswers ?? 0,
          totalQuestions: request.totalQuestions ?? 0,
          isAwarding: false,
        },
      });
    } catch {
      set((s) => ({
        quizReward: { ...s.quizReward, isAwarding: false },
      }));
    }
  },

  clearQuizReward: () => {
    set({
      quizReward: {
        result: null,
        correctAnswers: 0,
        totalQuestions: 0,
        isAwarding: false,
      },
    });
  },

  checkDailyLogin: async () => {
    const { dailyLogin } = get();
    if (dailyLogin.checked) return;

    try {
      const result = await callChemCityGetDailyLoginBonus();
      const alreadyClaimed = Boolean((result as any)?.alreadyClaimed);
      if (alreadyClaimed) {
        set((s) => ({ dailyLogin: { ...s.dailyLogin, checked: true } }));
        return;
      }

      set({
        dailyLogin: {
          diamonds: Number((result as any)?.diamondsAwarded || 0),
          coins: Number((result as any)?.coinsAwarded || 0),
          streak: Number((result as any)?.currentStreak || 0),
          showModal: true,
          checked: true,
        },
      });
    } catch {
      set((s) => ({ dailyLogin: { ...s.dailyLogin, checked: true } }));
    }
  },

  dismissDailyLogin: () => {
    set((s) => ({ dailyLogin: { ...s.dailyLogin, showModal: false } }));
  },

  claimCollectionReward: async (collectionId: string) => {
    await callChemCityClaimCollectionReward(collectionId);
  },

  dismissOnboarding: () => {
    markOnboardingDone();
    set({ showOnboarding: false });
  },
}));


===== FILE: src/components/chemcity/gacha/GachaScreen.tsx =====

import { useEffect, useState } from 'react';
import { useChemCityStore } from '../../../store/chemcityStore';
import { GachaResultsModal } from './GachaResultsModal';
import { PityBar } from './PityBar';
import type { GachaBanner } from '../../../lib/chemcity/types';
import { callChemCityGachaDraw } from '../../../lib/chemcity/cloudFunctions';

export function GachaScreen() {
  const user = useChemCityStore((s) => s.user);

  const loadGachaStatic = useChemCityStore((s) => s.loadGachaStatic);

  const activeBanners = useChemCityStore((s) => s.activeBanners);

  const [selectedBannerId, setSelectedBannerId] = useState<string | null>(null);
  const [showResults, setShowResults] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [lastResults, setLastResults] = useState<any[] | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [showAnimation, setShowAnimation] = useState(false);
  const [pendingDraw, setPendingDraw] = useState<{ count: 1 | 10 } | null>(null);
  const [animationDone, setAnimationDone] = useState(false);

  // Fallback default banner if none exist in database
  const defaultBanner: GachaBanner = {
    id: 'banner_standard',
    name: 'Standard Banner',
    active: true,
    cacheVersion: 1,
    rarityRates: { common: 0.6, uncommon: 0.25, rare: 0.1, epic: 0.04, legendary: 0.01 },
    pityRules: { epicEvery: 50, legendaryEvery: 100 },
    duplicateRefundCoinsByRarity: { common: 10, uncommon: 25, rare: 50, epic: 100, legendary: 500 },
  };

  // Use activeBanners if available, otherwise use default
  const effectiveBanners = activeBanners.length > 0 ? activeBanners : [defaultBanner];
  
  const selectedBanner: GachaBanner | undefined =
    effectiveBanners.find((b) => b.id === selectedBannerId) ?? effectiveBanners[0];

  useEffect(() => {
    if (effectiveBanners.length && !selectedBannerId) {
      setSelectedBannerId(effectiveBanners[0].id);
    }
  }, [effectiveBanners, selectedBannerId]);

  useEffect(() => {
    loadGachaStatic();
  }, [loadGachaStatic]);

  useEffect(() => {
    if (pendingDraw) {
      setShowAnimation(true);
      setAnimationDone(false);
      setError(null);
      setIsDrawing(true);
      callChemCityGachaDraw({ bannerId: (selectedBanner as any).id, count: pendingDraw.count, payWith: 'tickets' })
        .then((res) => {
          setLastResults(res.results);
        })
        .catch((err: any) => {
          setError(err?.message ?? 'Draw failed');
        })
        .finally(() => {
          setIsDrawing(false);
        });
    }
  }, [pendingDraw, selectedBanner]);

  useEffect(() => {
    if (!showAnimation && animationDone && lastResults && !isDrawing) {
      setShowResults(true);
    }
  }, [animationDone, isDrawing, lastResults, showAnimation]);

  const currencies = user?.currencies ?? { coins: 0, diamonds: 0, tickets: 0 };

  const gachaState = (user as any)?.gachaState ?? {};
  const pity = selectedBanner ? gachaState[selectedBanner.id] ?? { sinceEpic: 0, sinceLegendary: 0, lifetimePulls: 0 } : null;

  const canPayTickets1x = (currencies as any).tickets >= 1;
  const canPayTickets10x = (currencies as any).tickets >= 10;

  function handleStartDraw(count: 1 | 10) {
    if (!selectedBanner) return;
    if (showAnimation || isDrawing) return;
    setLastResults(null);
    setShowResults(false);
    setPendingDraw({ count });
  }

  function handleCloseResults() {
    setShowResults(false);
    setLastResults(null);
  }

  function handleAnimationEnded() {
    setShowAnimation(false);
    setPendingDraw(null);
    setAnimationDone(true);
  }

  if (!user) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-900 text-white">
        <span className="animate-pulse text-lg">Loading...</span>
      </div>
    );
  }

  // Show gacha machine even while loading static data
  const hasBanner = selectedBanner && pity;

  return (
    <div className="relative min-h-screen bg-black text-white overflow-hidden flex flex-col">
      {/* Background image */}
      <img
        src="/GachaMachine.png"
        alt=""
        className="absolute inset-0 w-full h-full object-cover"
        draggable={false}
      />

      {/* Gradient overlay */}
      <div className="absolute inset-0 bg-gradient-to-b from-black/20 via-black/20 to-black/60 pointer-events-none" />

      {/* Animation overlay */}
      {showAnimation ? (
        <div className="absolute inset-0 z-20 flex items-center justify-center">
          <video
            src="/Gacha animation.mp4"
            className="w-full h-full object-cover"
            autoPlay
            muted
            playsInline
            onEnded={handleAnimationEnded}
          />
        </div>
      ) : null}

      {/* Top bar with tickets/coins */}
      <div className="relative z-30 flex items-center justify-between gap-3 px-4 py-4">
        <div className="flex gap-3">
          <CurrencyBadge emoji="🎟️" label="Tickets" value={(currencies as any).tickets ?? 0} />
          <CurrencyBadge emoji="🪙" label="Coins" value={currencies.coins} />
        </div>
        {effectiveBanners.length > 1 && hasBanner ? (
          <select
            value={selectedBanner.id}
            onChange={(e) => setSelectedBannerId(e.target.value)}
            className="bg-black/40 border border-white/10 rounded-xl px-3 py-2 text-sm"
            disabled={showAnimation || isDrawing}
          >
            {effectiveBanners.map((b) => (
              <option key={b.id} value={b.id}>
                {b.name}
              </option>
            ))}
          </select>
        ) : null}
      </div>

      {/* Middle spacer */}
      <div className="flex-1" />

      {/* Bottom controls */}
      <div className="relative z-30 flex flex-col items-center gap-3 px-4 pb-8">
        {error ? (
          <div className="w-full max-w-md bg-red-900/40 border border-red-700 rounded-xl px-4 py-3 text-sm text-red-200">
            {error}
          </div>
        ) : null}

        <div className="w-full max-w-md grid grid-cols-2 gap-3">
          <DrawButton
            label="Draw × 1"
            sublabel="1 Ticket"
            emoji="🎟️"
            disabled={!canPayTickets1x || isDrawing || showAnimation || !hasBanner}
            loading={isDrawing && pendingDraw?.count === 1}
            onClick={() => handleStartDraw(1)}
            variant="primary"
          />
          <DrawButton
            label="Draw × 10"
            sublabel="10 Tickets (Rare+)"
            emoji="🎟️"
            disabled={!canPayTickets10x || isDrawing || showAnimation || !hasBanner}
            loading={isDrawing && pendingDraw?.count === 10}
            onClick={() => handleStartDraw(10)}
            variant="secondary"
          />
        </div>

        <div className="w-full max-w-md space-y-2">
          {hasBanner ? (
            <>
              <PityBar label="Epic Pity" current={pity.sinceEpic} max={selectedBanner.pityRules.epicEvery} color="purple" />
              <PityBar label="Legendary Pity" current={pity.sinceLegendary} max={selectedBanner.pityRules.legendaryEvery} color="yellow" />
            </>
          ) : (
            <div className="text-center text-gray-400 text-sm">No active banners available</div>
          )}
        </div>
      </div>

      {showResults && lastResults ? (
        <GachaResultsModal results={lastResults as any} onClose={handleCloseResults} />
      ) : null}
    </div>
  );
}

function CurrencyBadge({ emoji, label, value }: { emoji: string; label: string; value: number }) {
  return (
    <div className="flex items-center gap-1.5 bg-gray-800 rounded-xl px-3 py-2">
      <span className="text-lg">{emoji}</span>
      <div>
        <p className="text-[10px] text-gray-500 leading-none">{label}</p>
        <p className="text-sm font-bold leading-tight">{value.toLocaleString()}</p>
      </div>
    </div>
  );
}

function DrawButton({
  label,
  sublabel,
  emoji,
  disabled,
  loading,
  onClick,
  variant,
}: {
  label: string;
  sublabel: string;
  emoji: string;
  disabled: boolean;
  loading: boolean;
  onClick: () => void;
  variant: 'primary' | 'secondary';
}) {
  const base =
    'flex flex-col items-center justify-center rounded-2xl py-4 transition-all active:scale-95 disabled:opacity-40 disabled:cursor-not-allowed';
  const styles = {
    primary: 'bg-indigo-600 hover:bg-indigo-500 text-white shadow-lg shadow-indigo-900/40',
    secondary: 'bg-gray-700 hover:bg-gray-600 text-white',
  };

  return (
    <button onClick={onClick} disabled={disabled} className={`${base} ${styles[variant]}`}>
      {loading ? (
        <span className="animate-spin text-xl">⟳</span>
      ) : (
        <>
          <span className="text-base font-bold">{label}</span>
          <span className="text-xs text-gray-200/70">
            {emoji} {sublabel}
          </span>
        </>
      )}
    </button>
  );
}

function RateTable({ rates }: { rates: Record<string, number> }) {
  const order = ['legendary', 'epic', 'rare', 'uncommon', 'common'];
  const colors: Record<string, string> = {
    legendary: 'text-yellow-400',
    epic: 'text-purple-400',
    rare: 'text-blue-400',
    uncommon: 'text-green-400',
    common: 'text-gray-400',
  };

  return (
    <div className="mt-4 bg-gray-800/60 rounded-xl px-4 py-3">
      <p className="text-xs text-gray-500 mb-2 uppercase tracking-wide">Drop Rates</p>
      <div className="grid grid-cols-5 gap-1 text-center">
        {order.map((r) => (
          <div key={r} className="flex flex-col items-center">
            <span className={`text-xs font-bold capitalize ${colors[r]}`}>{r}</span>
            <span className="text-[10px] text-gray-400">{((rates[r] ?? 0) * 100).toFixed(0)}%</span>
          </div>
        ))}
      </div>
    </div>
  );
}

function BannerCountdown({ endAt }: { endAt: any }) {
  const end = typeof endAt === 'string' ? new Date(endAt) : typeof endAt?.toDate === 'function' ? endAt.toDate() : new Date(endAt);
  const diff = end.getTime() - Date.now();
  if (diff < 0) return null;

  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

  return (
    <div className="absolute bottom-3 right-3 bg-black/60 backdrop-blur-sm text-white text-xs rounded-full px-3 py-1">
      ⏳ {days}d {hours}h left
    </div>
  );
}


===== FILE: src/components/chemcity/gacha/GachaResultsModal.tsx =====

import { useEffect, useMemo, useState, type CSSProperties } from 'react';
import { useChemCityStore } from '../../../store/chemcityStore';
import type { Cosmetic, GachaDrawResult, Rarity } from '../../../lib/chemcity/types';
import { getAvatarTuning, shouldForceNoSplit, avatarNumberFromId } from './AvatarTuner';

interface Props {
  results: GachaDrawResult[];
  onClose: () => void;
}

function buildAvatarStyle(url: string): CSSProperties {
  return {
    backgroundImage: `url(${url})`,
    backgroundSize: 'contain',
    backgroundPosition: '50% 100%',
    backgroundRepeat: 'no-repeat',
  };
}

// ── Brand palette (matches landing page) ─────────────────────────────────────
const BRAND = {
  bg: '#071412',
  bgCard: '#0d2320',
  teal: '#76A8A5',
  sage: '#C5D7B5',
};

const RARITY_CONFIG: Record<
  Rarity,
  {
    label: string;
    border: string;
    glow: string;
    bg: string;
    badgeBg: string;
    badgeText: string;
    headerGradient: string;
  }
> = {
  common: {
    label: 'Common',
    border: 'rgba(118,168,165,0.3)',
    glow: 'none',
    bg: 'rgba(118,168,165,0.06)',
    badgeBg: 'rgba(118,168,165,0.18)',
    badgeText: '#C5D7B5',
    headerGradient: 'linear-gradient(135deg, rgba(118,168,165,0.25), rgba(118,168,165,0.05))',
  },
  uncommon: {
    label: 'Uncommon',
    border: 'rgba(110,200,120,0.45)',
    glow: '0 0 16px 2px rgba(110,200,120,0.2)',
    bg: 'rgba(30,80,40,0.25)',
    badgeBg: 'rgba(110,200,120,0.2)',
    badgeText: '#90efb0',
    headerGradient: 'linear-gradient(135deg, rgba(60,140,70,0.3), rgba(30,80,40,0.1))',
  },
  rare: {
    label: 'Rare',
    border: 'rgba(100,170,240,0.55)',
    glow: '0 0 20px 4px rgba(100,170,240,0.25)',
    bg: 'rgba(20,50,100,0.3)',
    badgeBg: 'rgba(100,170,240,0.2)',
    badgeText: '#93c5fd',
    headerGradient: 'linear-gradient(135deg, rgba(40,100,200,0.3), rgba(20,50,100,0.1))',
  },
  epic: {
    label: 'Epic',
    border: 'rgba(170,100,230,0.6)',
    glow: '0 0 24px 6px rgba(170,100,230,0.3)',
    bg: 'rgba(50,20,80,0.35)',
    badgeBg: 'rgba(170,100,230,0.2)',
    badgeText: '#d8b4fe',
    headerGradient: 'linear-gradient(135deg, rgba(120,50,180,0.35), rgba(50,20,80,0.1))',
  },
  legendary: {
    label: 'Legendary',
    border: 'rgba(245,185,60,0.7)',
    glow: '0 0 32px 8px rgba(245,185,60,0.35)',
    bg: 'rgba(70,40,0,0.4)',
    badgeBg: 'rgba(245,185,60,0.25)',
    badgeText: '#fde68a',
    headerGradient: 'linear-gradient(135deg, rgba(180,100,10,0.4), rgba(70,40,0,0.1))',
  },
};

// ── Main modal ────────────────────────────────────────────────────────────────

export function GachaResultsModal({ results, onClose }: Props) {
  const cosmeticsMap = useChemCityStore((s) => (s as any).cosmeticsMap as Map<string, Cosmetic> | undefined);
  const userGender = useChemCityStore((s) => (s as any).userGender as 'boy' | 'girl' | null);
  const [revealedCount, setRevealedCount] = useState(0);
  const [allRevealed, setAllRevealed] = useState(false);

  useEffect(() => {
    if (allRevealed) return;
    if (revealedCount >= results.length) {
      setAllRevealed(true);
      return;
    }
    const delay = revealedCount === 0 ? 400 : 350;
    const t = setTimeout(() => setRevealedCount((n) => n + 1), delay);
    return () => clearTimeout(t);
  }, [revealedCount, results.length, allRevealed]);

  function revealAll() {
    setRevealedCount(results.length);
    setAllRevealed(true);
  }

  const totalRefund = results.reduce((acc, r) => acc + r.refundCoins, 0);
  const newCount = results.filter((r) => r.isNew).length;
  const isSingle = results.length === 1;

  return (
    <div
      className="fixed inset-0 z-50 flex flex-col"
      style={{ background: BRAND.bg, fontFamily: "'Quicksand', sans-serif" }}
    >
      {/* Ambient glow overlay */}
      <div className="absolute inset-0 pointer-events-none" style={{
        background: 'radial-gradient(ellipse 70% 50% at 50% 30%, rgba(118,168,165,0.08) 0%, transparent 70%)',
      }} />

      {/* Header */}
      <div className="relative z-10 flex items-center justify-between px-5 pt-6 pb-3 shrink-0">
        <div>
          <h2 className="text-2xl font-black" style={{ color: BRAND.sage }}>
            {isSingle ? 'Draw Result' : `${results.length}× Draw`}
          </h2>
          <div className="flex items-center gap-3 mt-1">
            {newCount > 0 && (
              <span className="text-sm font-bold" style={{ color: '#86efac' }}>
                ✦ {newCount} new
              </span>
            )}
            {totalRefund > 0 && (
              <span className="text-sm font-bold" style={{ color: '#fde68a' }}>
                🪙 +{totalRefund} refunded
              </span>
            )}
          </div>
        </div>
        {!allRevealed ? (
          <button
            onClick={revealAll}
            className="px-4 py-2 rounded-xl text-sm font-bold transition-all active:scale-95"
            style={{ background: 'rgba(118,168,165,0.15)', color: BRAND.teal, border: `1px solid rgba(118,168,165,0.3)` }}
          >
            Reveal All
          </button>
        ) : (
          <div style={{ width: 80 }} />
        )}
      </div>

      {/* Cards grid */}
      <div className="relative z-10 flex-1 overflow-y-auto px-4 pb-4">
        <div
          className={`grid gap-3 py-2 ${
            isSingle
              ? 'grid-cols-1 max-w-xs mx-auto'
              : results.length <= 4
                ? 'grid-cols-2'
                : 'grid-cols-3 sm:grid-cols-5'
          }`}
        >
          {results.map((r, idx) => (
            <ResultCard
              key={`${idx}_${r.cosmeticId}`}
              result={r}
              cosmetic={cosmeticsMap?.get(r.cosmeticId)}
              cosmeticsMap={cosmeticsMap}
              userGender={userGender}
              revealed={idx < revealedCount}
              isSingle={isSingle}
            />
          ))}
        </div>
      </div>

      {/* Done button */}
      {allRevealed && (
        <div className="relative z-10 px-4 pb-8 pt-2 shrink-0">
          <button
            onClick={onClose}
            className="w-full py-4 rounded-2xl text-lg font-black transition-all active:scale-95"
            style={{
              background: `linear-gradient(135deg, ${BRAND.teal}, #5d9190)`,
              color: '#0a1a18',
              boxShadow: `0 4px 24px rgba(118,168,165,0.4)`,
            }}
          >
            Done
          </button>
        </div>
      )}
    </div>
  );
}

// ── Individual result card ─────────────────────────────────────────────────────

function ResultCard({
  result,
  cosmetic,
  cosmeticsMap,
  userGender,
  revealed,
  isSingle,
}: {
  result: GachaDrawResult;
  cosmetic: Cosmetic | undefined;
  cosmeticsMap: Map<string, Cosmetic> | undefined;
  userGender: 'boy' | 'girl' | null;
  revealed: boolean;
  isSingle: boolean;
}) {
  const cfg = RARITY_CONFIG[result.rarity];
  const num = cosmetic ? avatarNumberFromId(cosmetic.id) : null;

  const avatarUrl = useMemo(() => {
    if (!cosmetic) return null;
    if (cosmetic.type !== 'avatar') return null;
    const resolvedGender: 'boy' | 'girl' = userGender === 'girl' ? 'girl' : 'boy';
    const key = resolvedGender === 'girl' ? 'imageUrlGirl' : 'imageUrlBoy';
    if (!shouldForceNoSplit(cosmetic.id)) {
      const gendered = (cosmetic as any)?.[key] as string | undefined;
      if (gendered) return gendered;
    }
    const plain = cosmeticsMap?.get('avatar_1_plain') as any;
    const plainGendered = plain?.[key] as string | undefined;
    return plainGendered ?? null;
  }, [cosmetic, userGender, cosmeticsMap]);

  const avatarStyle = useMemo<CSSProperties | null>(() => {
    if (!cosmetic || cosmetic.type !== 'avatar') return null;
    if (!avatarUrl) return null;
    return buildAvatarStyle(avatarUrl);
  }, [cosmetic, avatarUrl]);

  const avatarTransform = useMemo(() => {
    if (!cosmetic || cosmetic.type !== 'avatar') return '';
    if (!userGender) return '';
    const tune = getAvatarTuning(cosmetic.id, 'gacha_result', userGender);
    const ox = tune?.offsetXPercent ?? 0;
    const oy = tune?.offsetYPercent ?? 0;
    const sc = tune?.scale ?? 1;
    if (ox === 0 && oy === 0 && sc === 1) return '';
    return `translate(${ox}%, ${oy}%) scale(${sc})`;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cosmetic?.id, userGender]);

  return (
    <div
      className={`relative rounded-2xl overflow-hidden transition-all duration-500 ${
        isSingle ? 'aspect-[3/4]' : 'aspect-square'
      }`}
      style={
        revealed
          ? {
              border: `2px solid ${cfg.border}`,
              boxShadow: cfg.glow,
              background: cfg.bg,
              opacity: 1,
              transform: 'scale(1)',
            }
          : {
              border: '2px solid rgba(118,168,165,0.1)',
              background: 'rgba(118,168,165,0.04)',
              opacity: 0,
              transform: 'scale(0.9)',
            }
      }
    >
      {revealed ? (
        <>
          {/* Avatar image */}
          {cosmetic?.imageUrl ? (
            cosmetic.type === 'avatar' ? (
              <div className="absolute inset-0 overflow-hidden">
                {avatarStyle && avatarUrl ? (
                  <div
                    className="absolute inset-0"
                    style={{
                      transform: avatarTransform || undefined,
                      transformOrigin: 'center center',
                    }}
                  >
                    <div className="absolute inset-0" style={avatarStyle} />
                  </div>
                ) : avatarUrl ? (
                  <img
                    src={avatarUrl}
                    alt={cosmetic.name}
                    className="absolute bottom-0 left-1/2 h-full w-auto max-w-none"
                    style={{ transform: `translateX(-50%) ${avatarTransform || ''}`.trim() }}
                    draggable={false}
                  />
                ) : null}
              </div>
            ) : (
              /* Background image */
              <img
                src={cosmetic.imageUrl}
                alt={cosmetic.name}
                className="w-full h-full object-cover"
                draggable={false}
              />
            )
          ) : (
            <div className="w-full h-full flex items-center justify-center text-5xl">
              {result.rarity === 'legendary' ? '⭐' : result.rarity === 'epic' ? '💜' : '🎁'}
            </div>
          )}

          {/* Header gradient overlay */}
          <div className="absolute inset-x-0 top-0 h-16 pointer-events-none"
            style={{ background: cfg.headerGradient }} />

          {/* Avatar number badge — top right */}
          {num !== null && (
            <div
              className="absolute top-2 right-2 rounded-md px-1.5 py-0.5"
              style={{ background: 'rgba(0,0,0,0.55)', backdropFilter: 'blur(4px)' }}
            >
              <span className="text-[11px] font-bold" style={{ color: 'rgba(255,255,255,0.65)' }}>
                #{num}
              </span>
            </div>
          )}

          {/* Status badges — top left */}
          <div className="absolute top-2 left-2 flex flex-col gap-1">
            {result.pitied && (
              <span
                className="text-[10px] font-bold px-2 py-0.5 rounded-full"
                style={{ background: 'rgba(100,170,240,0.25)', color: '#93c5fd', border: '1px solid rgba(100,170,240,0.4)' }}
              >
                Pity
              </span>
            )}
            {result.isNew && (
              <span
                className="text-[10px] font-bold px-2 py-0.5 rounded-full"
                style={{ background: 'rgba(110,200,120,0.25)', color: '#86efac', border: '1px solid rgba(110,200,120,0.4)' }}
              >
                New!
              </span>
            )}
          </div>

          {/* Bottom info bar */}
          <div
            className="absolute inset-x-0 bottom-0 px-3 py-3"
            style={{ background: 'linear-gradient(to top, rgba(0,0,0,0.85) 60%, transparent)' }}
          >
            <p className="text-white font-black text-base leading-tight truncate mb-1.5">
              {cosmetic?.name ?? result.cosmeticId}
            </p>
            <div className="flex items-center gap-2 flex-wrap">
              <span
                className="text-xs font-bold px-2 py-0.5 rounded-full"
                style={{
                  background: cfg.badgeBg,
                  color: cfg.badgeText,
                  border: `1px solid ${cfg.border}`,
                }}
              >
                {cfg.label}
              </span>
              {!result.isNew && result.refundCoins > 0 && (
                <span
                  className="text-xs font-bold px-2 py-0.5 rounded-full"
                  style={{ background: 'rgba(245,185,60,0.2)', color: '#fde68a', border: '1px solid rgba(245,185,60,0.35)' }}
                >
                  +{result.refundCoins} 🪙
                </span>
              )}
            </div>
          </div>

          {/* Legendary shimmer */}
          {result.rarity === 'legendary' && (
            <div
              className="absolute inset-0 pointer-events-none animate-pulse"
              style={{ background: 'linear-gradient(135deg, rgba(245,185,60,0.08) 0%, transparent 50%, rgba(245,185,60,0.08) 100%)' }}
            />
          )}
        </>
      ) : (
        /* Unrevealed state */
        <div
          className="absolute inset-0 flex flex-col items-center justify-center gap-3"
          style={{ background: 'rgba(118,168,165,0.06)' }}
        >
          <span className="text-4xl">❓</span>
          <p className="text-xs font-bold" style={{ color: 'rgba(118,168,165,0.5)' }}>Tap reveal all</p>
        </div>
      )}
    </div>
  );
}

===== FILE: src/components/chemcity/gacha/CosmeticsInventory.tsx =====

import { useMemo, useState, useEffect } from 'react';
import React from 'react';
import { useChemCityStore } from '../../../store/chemcityStore';
import type { CosmeticType, Rarity, Cosmetic } from '../../../lib/chemcity/types';
import { ProfileCard } from './ProfileCard';
import { callChemCityEquipCosmetics } from '../../../lib/chemcity/cloudFunctions';
import {
  shouldForceNoSplit,
  getGlobalFaceCrop,
  getAvatarFaceCrop,
  getAvatarTuning,
  avatarNumberFromId,
  TUNER_UPDATED_EVENT,
  AvatarTunerButton,
} from './AvatarTuner';
import type { FaceCropMeta } from '../../../lib/chemcity/types';

// ── Hook: re-render when AvatarTuner saves new config to localStorage ────────
function useTunerVersion(): number {
  const [v, setV] = useState(0);
  useEffect(() => {
    const handler = () => setV((n) => n + 1);
    window.addEventListener(TUNER_UPDATED_EVENT, handler);
    return () => window.removeEventListener(TUNER_UPDATED_EVENT, handler);
  }, []);
  return v;
}

// ── Brand palette ─────────────────────────────────────────────────────────────
const BRAND = {
  bg: '#0a1a18',
  bgPanel: '#0f2825',
  teal: '#76A8A5',
  sage: '#C5D7B5',
  border: 'rgba(118,168,165,0.25)',
};

const RARITY_ORDER: Rarity[] = ['legendary', 'epic', 'rare', 'uncommon', 'common'];

const RARITY_BAR: Record<Rarity, string> = {
  legendary: 'rgba(245,185,60,0.85)',
  epic:      'rgba(170,100,230,0.85)',
  rare:      'rgba(100,170,240,0.85)',
  uncommon:  'rgba(110,200,120,0.75)',
  common:    'rgba(118,168,165,0.45)',
};

const RARITY_BADGE: Record<Rarity, React.CSSProperties> = {
  legendary: { background: 'rgba(245,185,60,0.18)',  color: '#fde68a', border: '1px solid rgba(245,185,60,0.4)' },
  epic:      { background: 'rgba(170,100,230,0.18)', color: '#d8b4fe', border: '1px solid rgba(170,100,230,0.4)' },
  rare:      { background: 'rgba(100,170,240,0.18)', color: '#93c5fd', border: '1px solid rgba(100,170,240,0.4)' },
  uncommon:  { background: 'rgba(110,200,120,0.18)', color: '#86efac', border: '1px solid rgba(110,200,120,0.4)' },
  common:    { background: 'rgba(118,168,165,0.15)', color: '#C5D7B5', border: '1px solid rgba(118,168,165,0.3)' },
};

type ActiveTab = 'avatars' | 'backgrounds';

// ── CSS background-position math ──────────────────────────────────────────────
function buildCropStyle(crop: FaceCropMeta, url: string): React.CSSProperties {
  const { x, y, w, h } = crop;
  const scale = Math.max(1 / w, 1 / h);
  const px = ((0.5 - (x + w / 2) * scale) / (1 - scale)) * 100;
  const py = ((0.5 - (y + h / 2) * scale) / (1 - scale)) * 100;
  return {
    backgroundImage: `url(${url})`,
    backgroundSize: `${scale * 100}%`,
    backgroundPosition: `${px}% ${py}%`,
    backgroundRepeat: 'no-repeat',
  };
}

// ── AvatarFaceSquare ──────────────────────────────────────────────────────────

function AvatarFaceSquare({
  cosmetic, gender, isEquipped, onClick, disabled,
}: {
  cosmetic: Cosmetic;
  gender: 'boy' | 'girl' | null;
  isEquipped: boolean;
  onClick: () => void;
  disabled?: boolean;
}) {
  const cosmeticsMap = useChemCityStore((s) => (s as any).cosmeticsMap as Map<string, Cosmetic> | undefined);
  const avatarId = cosmetic.id;
  const num = avatarNumberFromId(avatarId);
  const tunerVersion = useTunerVersion();

  const resolvedGender: 'boy' | 'girl' = gender === 'girl' ? 'girl' : 'boy';

  const imageUrl = useMemo(() => {
    if (!shouldForceNoSplit(avatarId)) {
      const key = resolvedGender === 'girl' ? 'imageUrlGirl' : 'imageUrlBoy';
      const gendered = (cosmetic as any)[key] as string | undefined;
      if (gendered) return gendered;
      const plain = cosmeticsMap?.get('avatar_1_plain') as any;
      const plainGendered = plain?.[key] as string | undefined;
      return plainGendered;
    }
    // no-split avatars are not allowed to use the combined image fallback per project rule
    return undefined;
  }, [cosmetic, resolvedGender, avatarId, cosmeticsMap]);

  const cropStyle = useMemo<React.CSSProperties | undefined>(() => {
    if (!imageUrl) return undefined;
    return {
      backgroundImage: `url(${imageUrl})`,
      backgroundSize: 'contain',
      backgroundPosition: '50% 100%',
      backgroundRepeat: 'no-repeat',
    };
    // tunerVersion in deps ensures this re-runs whenever the tuner saves new config
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cosmetic, gender, imageUrl, tunerVersion]);

  // Per-avatar inventory context adjustments (offsetX, offsetY, scale).
  // These are applied as a CSS transform ON TOP of the face-crop background,
  // so you can nudge or zoom individual avatars without redefining the global crop.
  const inventoryTransform = useMemo<string>(() => {
    const tune = getAvatarTuning(avatarId, 'inventory', resolvedGender);
    if (!tune && !tunerVersion) return ''; // tunerVersion keeps memo reactive
    const ox = tune?.offsetXPercent ?? 0;
    const oy = tune?.offsetYPercent ?? 0;
    const sc = tune?.scale ?? 1;
    if (ox === 0 && oy === 0 && sc === 1) return '';
    return `translate(${ox}%, ${oy}%) scale(${sc})`;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [avatarId, resolvedGender, tunerVersion]);

  return (
    <div style={{ position: 'relative', width: '100%', paddingBottom: '100%' }}>
      <button
        onClick={onClick}
        disabled={disabled}
        style={{
          position: 'absolute',
          inset: 0,
          borderRadius: 12,
          overflow: 'hidden',
          border: `2px solid ${isEquipped ? BRAND.teal : 'rgba(118,168,165,0.22)'}`,
          background: 'rgba(13,35,32,0.85)',
          boxShadow: isEquipped
            ? `0 0 0 2px rgba(118,168,165,0.3), inset 0 0 0 1px rgba(118,168,165,0.15)`
            : 'none',
          cursor: disabled ? 'default' : 'pointer',
          transition: 'transform 0.1s, box-shadow 0.15s',
        }}
      >
        {/* Image — wrap in an extra div so transform applies to the image
            without affecting the overlaid badges/rarity bar */}
        <div
          style={{
            position: 'absolute',
            inset: 0,
            transform: inventoryTransform || undefined,
            transformOrigin: 'center center',
          }}
        >
          {cropStyle ? (
            <div style={{ position: 'absolute', inset: 0, ...cropStyle }} />
          ) : imageUrl ? (
            <div
              style={{
                position: 'absolute',
                inset: 0,
                backgroundImage: `url(${imageUrl})`,
                backgroundSize: '130%',
                backgroundPosition: '50% 5%',
                backgroundRepeat: 'no-repeat',
              }}
            />
          ) : (
            <div
              style={{
                position: 'absolute',
                inset: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: 24,
                background: 'rgba(118,168,165,0.08)',
              }}
            >
              🎴
            </div>
          )}
        </div>

        {/* Bottom scrim — outside the transform div so it stays anchored */}
        <div
          style={{
            position: 'absolute',
            inset: '65% 0 0 0',
            background: 'linear-gradient(to top, rgba(0,0,0,0.65), transparent)',
            pointerEvents: 'none',
          }}
        />

        {/* #N badge — top right */}
        {num !== null && (
          <span
            style={{
              position: 'absolute',
              top: 4,
              right: 4,
              fontSize: 9,
              fontWeight: 700,
              lineHeight: 1,
              padding: '2px 4px',
              borderRadius: 4,
              background: 'rgba(0,0,0,0.6)',
              color: 'rgba(255,255,255,0.55)',
            }}
          >
            #{num}
          </span>
        )}

        {/* Equipped ✓ — top left */}
        {isEquipped && (
          <div
            style={{
              position: 'absolute',
              top: 4,
              left: 4,
              width: 16,
              height: 16,
              borderRadius: '50%',
              background: BRAND.teal,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <span style={{ fontSize: 9, color: '#fff', fontWeight: 700 }}>✓</span>
          </div>
        )}

        {/* Rarity bar */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            right: 0,
            height: 3,
            background: RARITY_BAR[cosmetic.rarity],
          }}
        />
      </button>
    </div>
  );
}

// ── BackgroundSquare ──────────────────────────────────────────────────────────

function BackgroundSquare({
  cosmetic, isEquipped, onClick, disabled,
}: {
  cosmetic: Cosmetic;
  isEquipped: boolean;
  onClick: () => void;
  disabled?: boolean;
}) {
  const numMatch = cosmetic.id.match(/_(\d+)/);
  const num = numMatch?.[1];

  return (
    <div style={{ position: 'relative', width: '100%', paddingBottom: '100%' }}>
      <button
        onClick={onClick}
        disabled={disabled}
        style={{
          position: 'absolute',
          inset: 0,
          borderRadius: 12,
          overflow: 'hidden',
          border: `2px solid ${isEquipped ? BRAND.teal : 'rgba(118,168,165,0.22)'}`,
          background: 'rgba(13,35,32,0.85)',
          boxShadow: isEquipped ? `0 0 0 2px rgba(118,168,165,0.3)` : 'none',
          cursor: disabled ? 'default' : 'pointer',
          transition: 'transform 0.1s',
        }}
      >
        {cosmetic.imageUrl ? (
          <img
            src={cosmetic.imageUrl}
            alt={cosmetic.name}
            style={{ position: 'absolute', inset: 0, width: '100%', height: '100%', objectFit: 'cover' }}
            draggable={false}
          />
        ) : (
          <div style={{ position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 24 }}>
            🖼
          </div>
        )}

        <div style={{ position: 'absolute', inset: '55% 0 0 0', background: 'linear-gradient(to top, rgba(0,0,0,0.75), transparent)', pointerEvents: 'none' }} />

        {num && (
          <span style={{ position: 'absolute', top: 4, right: 4, fontSize: 9, fontWeight: 700, padding: '2px 4px', borderRadius: 4, background: 'rgba(0,0,0,0.6)', color: 'rgba(255,255,255,0.6)' }}>
            #{num}
          </span>
        )}

        {isEquipped && (
          <div style={{ position: 'absolute', top: 4, left: 4, width: 16, height: 16, borderRadius: '50%', background: BRAND.teal, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <span style={{ fontSize: 9, color: '#fff', fontWeight: 700 }}>✓</span>
          </div>
        )}

        <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, padding: '0 6px 6px' }}>
          <p style={{ color: '#fff', fontSize: 10, fontWeight: 700, lineHeight: 1.2, overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis', margin: '0 0 2px' }}>
            {cosmetic.name}
          </p>
          <span style={{ fontSize: 8, fontWeight: 700, padding: '2px 5px', borderRadius: 999, ...RARITY_BADGE[cosmetic.rarity] }}>
            {cosmetic.rarity}
          </span>
        </div>

        <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, height: 3, background: RARITY_BAR[cosmetic.rarity] }} />
      </button>
    </div>
  );
}

// ── InfoRow ───────────────────────────────────────────────────────────────────

function InfoRow({ label, value, rarity }: { label: string; value: string; rarity?: Rarity }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, padding: '8px 12px', borderRadius: 8, background: 'rgba(118,168,165,0.08)', border: '1px solid rgba(118,168,165,0.15)' }}>
      <span style={{ fontSize: 11, fontWeight: 700, color: 'rgba(118,168,165,0.7)', flexShrink: 0 }}>{label}</span>
      <div style={{ display: 'flex', alignItems: 'center', gap: 6, minWidth: 0 }}>
        <span style={{ fontSize: 11, fontWeight: 600, color: '#e6f5e6', overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis' }}>{value}</span>
        {rarity && (
          <span style={{ flexShrink: 0, fontSize: 9, fontWeight: 700, padding: '2px 5px', borderRadius: 999, ...RARITY_BADGE[rarity] }}>
            {rarity}
          </span>
        )}
      </div>
    </div>
  );
}

// ── Main Component ────────────────────────────────────────────────────────────

export function CosmeticsInventory() {
  const user = useChemCityStore((s) => s.user);
  const userGender = useChemCityStore((s) => (s as any).userGender as 'boy' | 'girl' | null);
  const cosmeticsMap = useChemCityStore((s) => (s as any).cosmeticsMap as Map<string, Cosmetic> | undefined);
  const navigateToGacha = useChemCityStore((s) => s.navigateToGacha);

  const ownedSet = new Set<string>((user as any)?.ownedCosmetics ?? []);
  const equippedCosmetics = (user as any)?.equippedCosmetics ?? {};

  const [activeTab, setActiveTab] = useState<ActiveTab>('avatars');
  const [activeRarity, setActiveRarity] = useState<Rarity | 'all'>('all');
  const [equipping, setEquipping] = useState(false);
  const [equippingId, setEquippingId] = useState<string | null>(null);

  const allOwned = useMemo(
    () => Array.from(cosmeticsMap?.values?.() ?? []).filter((c) => ownedSet.has(c.id)),
    [cosmeticsMap, ownedSet.size],
  );

  const ownedAvatars = useMemo(() =>
    allOwned
      .filter((c) => c.type === 'avatar' && (activeRarity === 'all' || c.rarity === activeRarity))
      .sort((a, b) => {
        const ri = RARITY_ORDER.indexOf(a.rarity) - RARITY_ORDER.indexOf(b.rarity);
        return ri !== 0 ? ri : (avatarNumberFromId(a.id) ?? 999) - (avatarNumberFromId(b.id) ?? 999);
      }),
    [allOwned, activeRarity],
  );

  const ownedBgs = useMemo(() =>
    allOwned
      .filter((c) => c.type === 'background' && (activeRarity === 'all' || c.rarity === activeRarity))
      .sort((a, b) => {
        const ri = RARITY_ORDER.indexOf(a.rarity) - RARITY_ORDER.indexOf(b.rarity);
        return ri !== 0 ? ri : a.name.localeCompare(b.name);
      }),
    [allOwned, activeRarity],
  );

  const activeList = activeTab === 'avatars' ? ownedAvatars : ownedBgs;
  const equippedAvatar = equippedCosmetics.avatarId ? cosmeticsMap?.get(equippedCosmetics.avatarId) : undefined;
  const equippedBg = equippedCosmetics.backgroundId ? cosmeticsMap?.get(equippedCosmetics.backgroundId) : undefined;

  const tunerAvatar = equippedAvatar;

  async function handleEquip(cosmetic: Cosmetic) {
    if (equipping) return;
    setEquipping(true);
    setEquippingId(cosmetic.id);
    try {
      const patch: Record<string, string> = {};
      if (cosmetic.type === 'avatar') patch.avatarId = cosmetic.id;
      else if (cosmetic.type === 'background') patch.backgroundId = cosmetic.id;
      else if (cosmetic.type === 'icon') patch.iconId = cosmetic.id;
      await callChemCityEquipCosmetics(patch);
    } finally {
      setEquipping(false);
      setEquippingId(null);
    }
  }

  const isEquipped = (c: Cosmetic) =>
    c.type === 'avatar' ? equippedCosmetics.avatarId === c.id :
    c.type === 'background' ? equippedCosmetics.backgroundId === c.id :
    c.type === 'icon' ? equippedCosmetics.iconId === c.id : false;

  return (
    <div style={{ width: '100%', minHeight: '100%', background: BRAND.bg, color: '#e6f5e6', display: 'flex', flexDirection: 'column', fontFamily: "'Quicksand', sans-serif" }}>

      {/* Header */}
      <div style={{ padding: '20px 16px 12px', borderBottom: `1px solid ${BRAND.border}`, flexShrink: 0 }}>
        <h1 style={{ fontSize: 20, fontWeight: 900, color: BRAND.sage, margin: 0 }}>My Cosmetics</h1>
        <p style={{ fontSize: 12, color: BRAND.teal, margin: '2px 0 0' }}>{allOwned.length} owned · Tap to equip</p>
      </div>

      {/* Two-column */}
      <div style={{ display: 'flex', flex: 1, minHeight: 0 }}>

        {/* LEFT — profile card */}
        <div style={{
          width: '42%', maxWidth: 260, flexShrink: 0,
          borderRight: `1px solid ${BRAND.border}`,
          background: `linear-gradient(180deg, ${BRAND.bgPanel} 0%, ${BRAND.bg} 100%)`,
          display: 'flex', flexDirection: 'column', alignItems: 'center',
          gap: 12, padding: 16, overflowY: 'auto',
        }}>
          <ProfileCard size="xl" className="w-full rounded-2xl shadow-2xl" />
          <div style={{ width: '100%', display: 'flex', flexDirection: 'column', gap: 8 }}>
            <InfoRow label="Avatar" value={equippedAvatar?.name ?? 'None'} rarity={equippedAvatar?.rarity} />
            <InfoRow label="Background" value={equippedBg?.name ?? 'None'} rarity={equippedBg?.rarity} />
          </div>
          <button
            onClick={navigateToGacha}
            style={{ width: '100%', padding: '10px', borderRadius: 12, fontSize: 13, fontWeight: 700, background: 'rgba(118,168,165,0.12)', border: `1.5px solid ${BRAND.border}`, color: BRAND.teal, cursor: 'pointer' }}
          >
            🎟 Get More in Gacha
          </button>
          <AvatarTunerButton
            avatarId={tunerAvatar?.id}
            avatarImageUrl={tunerAvatar?.imageUrl}
            avatarImageUrlBoy={(tunerAvatar as any)?.imageUrlBoy}
            avatarImageUrlGirl={(tunerAvatar as any)?.imageUrlGirl}
            className="w-full py-2.5 rounded-xl text-xs font-bold transition-all active:scale-95"
            style={{
              background: 'rgba(118,168,165,0.06)',
              border: '1px dashed rgba(118,168,165,0.35)',
              color: 'rgba(118,168,165,0.6)',
              cursor: 'pointer',
              width: '100%',
            } as any}
          />
        </div>

        {/* RIGHT — grid */}
        <div style={{ flex: 1, minWidth: 0, display: 'flex', flexDirection: 'column' }}>

          {/* Tabs */}
          <div style={{ display: 'flex', gap: 8, padding: '12px 12px 8px', flexShrink: 0 }}>
            {(['avatars', 'backgrounds'] as ActiveTab[]).map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                style={{
                  padding: '8px 14px', borderRadius: 12, fontSize: 13, fontWeight: 700, cursor: 'pointer', transition: 'all 0.15s',
                  background: activeTab === tab ? BRAND.teal : 'rgba(118,168,165,0.1)',
                  color: activeTab === tab ? '#0a1a18' : BRAND.teal,
                  border: activeTab === tab ? 'none' : `1px solid ${BRAND.border}`,
                }}
              >
                {tab === 'avatars' ? `👤 Avatars (${ownedAvatars.length})` : `🖼 Backgrounds (${ownedBgs.length})`}
              </button>
            ))}
          </div>

          {/* Rarity chips */}
          <div style={{ display: 'flex', gap: 6, padding: '0 12px 8px', overflowX: 'auto', flexShrink: 0 }}>
            {(['all', ...RARITY_ORDER] as const).map((r) => (
              <button
                key={r}
                onClick={() => setActiveRarity(r)}
                style={{
                  flexShrink: 0, padding: '4px 10px', borderRadius: 999, fontSize: 11, fontWeight: 700, textTransform: 'capitalize', cursor: 'pointer', transition: 'all 0.15s',
                  background: activeRarity === r ? BRAND.sage : 'rgba(118,168,165,0.08)',
                  color: activeRarity === r ? '#0a1a18' : 'rgba(197,215,181,0.7)',
                  border: activeRarity === r ? 'none' : `1px solid ${BRAND.border}`,
                }}
              >
                {r}
              </button>
            ))}
          </div>

          {/* Grid */}
          <div style={{ flex: 1, overflowY: 'auto', padding: '0 12px 24px' }}>
            {activeList.length === 0 ? (
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '64px 0', gap: 12 }}>
                <span style={{ fontSize: 40 }}>🎁</span>
                <p style={{ fontWeight: 700, fontSize: 14, color: BRAND.teal, margin: 0 }}>No {activeTab} yet</p>
                <p style={{ fontSize: 12, color: 'rgba(118,168,165,0.6)', margin: 0, textAlign: 'center' }}>Pull in the Gacha or browse the Shop!</p>
                <button onClick={navigateToGacha} style={{ marginTop: 4, padding: '10px 20px', borderRadius: 12, fontSize: 13, fontWeight: 700, background: BRAND.teal, color: '#0a1a18', cursor: 'pointer', border: 'none' }}>
                  Go to Gacha
                </button>
              </div>
            ) : (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(5, minmax(0, 1fr))', gap: 8 }}>
                {activeList.map((cosmetic) => {
                  const equipped = isEquipped(cosmetic);
                  const loading = equippingId === cosmetic.id;
                  return (
                    <div key={cosmetic.id} style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                      <div style={{ position: 'relative' }}>
                        {activeTab === 'avatars' ? (
                          <AvatarFaceSquare cosmetic={cosmetic} gender={userGender} isEquipped={equipped} onClick={() => handleEquip(cosmetic)} disabled={equipping || equipped} />
                        ) : (
                          <BackgroundSquare cosmetic={cosmetic} isEquipped={equipped} onClick={() => handleEquip(cosmetic)} disabled={equipping || equipped} />
                        )}
                        {loading && (
                          <div style={{ position: 'absolute', inset: 0, borderRadius: 12, background: 'rgba(0,0,0,0.55)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                            <span style={{ fontSize: 20, color: BRAND.teal, animation: 'spin 0.8s linear infinite' }}>⟳</span>
                          </div>
                        )}
                      </div>
                      <p style={{ margin: 0, textAlign: 'center', fontSize: 10, lineHeight: 1.3, overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis', color: 'rgba(197,215,181,0.75)', padding: '0 2px' }}>
                        {cosmetic.name}
                      </p>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

===== FILE: src/components/chemcity/gacha/ProfileCard.tsx =====

import React, { useEffect, useMemo, useState } from 'react';
import { useChemCityStore } from '../../../store/chemcityStore';
import type { Cosmetic, FaceCropMeta } from '../../../lib/chemcity/types';
import { getAvatarTuning, getGlobalFaceCrop, getAvatarFaceCrop, shouldForceNoSplit, TUNER_UPDATED_EVENT } from './AvatarTuner';

const EMPTY_EQUIPPED: { avatarId?: string; backgroundId?: string; iconId?: string } = {};
const EMPTY_MAP: Map<string, any> = new Map();

type CardSize = 'sm' | 'md' | 'lg' | 'xl';

const CARD_DIMS: Record<CardSize, { w: number; h: number; textSize: string }> = {
  sm: { w: 80, h: 110, textSize: 'text-[10px]' },
  md: { w: 120, h: 165, textSize: 'text-xs' },
  lg: { w: 180, h: 248, textSize: 'text-sm' },
  xl: { w: 280, h: 385, textSize: 'text-base' },
};

// ── Hook: re-render when AvatarTuner saves new config ────────────────────────
// Used by ProfileCard and ProfileIcon so live tuner adjustments are reflected
// immediately without a page reload.
function useTunerVersion(): number {
  const [v, setV] = useState(0);
  useEffect(() => {
    const handler = () => setV((n) => n + 1);
    window.addEventListener(TUNER_UPDATED_EVENT, handler);
    return () => window.removeEventListener(TUNER_UPDATED_EVENT, handler);
  }, []);
  return v;
}

// ─── Shared face-crop style helper ───────────────────────────────────────────
function faceCropStyle(
  faceCrop: FaceCropMeta,
  imageUrl: string,
): React.CSSProperties {
  const { x, y, w, h } = faceCrop;
  const scale = Math.max(1 / w, 1 / h);
  const posX = (0.5 - (x + w / 2) * scale) / (1 - scale) * 100;
  const posY = (0.5 - (y + h / 2) * scale) / (1 - scale) * 100;
  return {
    backgroundImage: `url(${imageUrl})`,
    backgroundSize: `${scale * 100}%`,
    backgroundPosition: `${posX}% ${posY}%`,
  };
}

interface ProfileCardProps {
  displayName?: string;
  avatarId?: string;
  backgroundId?: string;
  gender?: 'boy' | 'girl' | null;
  cosmeticsMap?: Map<string, Cosmetic>;
  size?: CardSize;
  className?: string;
  style?: React.CSSProperties;
}

export function ProfileCard({
  displayName,
  avatarId: propAvatarId,
  backgroundId: propBgId,
  gender: genderOverride,
  cosmeticsMap: cosmeticsMapOverride,
  size = 'md',
  className = '',
  style,
}: ProfileCardProps) {
  // Re-render whenever the tuner saves so live adjustments are visible immediately.
  const tunerVersion = useTunerVersion();

  const equippedCosmetics = useChemCityStore(
    (s) => ((s.user as any)?.equippedCosmetics as typeof EMPTY_EQUIPPED) || EMPTY_EQUIPPED,
  );
  const userGender = useChemCityStore((s) => (s as any).userGender as 'boy' | 'girl' | null);
  const cosmeticsMapFromStore = useChemCityStore(
    (s) => ((s as any).cosmeticsMap as Map<string, Cosmetic>) || EMPTY_MAP,
  );

  const cosmeticsMap = cosmeticsMapOverride ?? cosmeticsMapFromStore;
  const effectiveGender = genderOverride ?? userGender;
  const resolvedGender: 'boy' | 'girl' = effectiveGender === 'girl' ? 'girl' : 'boy';

  const avatarId = propAvatarId ?? equippedCosmetics.avatarId;
  const backgroundId = propBgId ?? equippedCosmetics.backgroundId;

  const avatar = avatarId ? cosmeticsMap?.get(avatarId) : undefined;
  const background = backgroundId ? cosmeticsMap?.get(backgroundId) : undefined;

  const dims = CARD_DIMS[size];

  // Compute transform from tuner config — re-derives when tunerVersion changes.
  const avatarTransform = useMemo(() => {
    if (!effectiveGender) return 'translateX(-50%)';
    const tune = getAvatarTuning(avatarId, 'profile_card', effectiveGender);
    const ox = tune?.offsetXPercent ?? 0;
    const oy = tune?.offsetYPercent ?? 0;
    const sc = tune?.scale ?? 1;
    return `translateX(calc(-50% + ${ox}%)) translateY(${oy}%) scale(${sc})`;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [avatarId, effectiveGender, tunerVersion]);

  const avatarTransformNoSplit = useMemo(() => {
    if (!effectiveGender) return 'translateX(-50%)';
    const tune = getAvatarTuning(avatarId, 'profile_card', effectiveGender);
    if (!tune) return 'translateX(-50%)';
    const ox = tune.offsetXPercent ?? 0;
    const oy = tune.offsetYPercent ?? 0;
    const sc = tune.scale ?? 1;
    return `translateX(calc(-50% + ${ox}%)) translateY(${oy}%) scale(${sc})`;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [avatarId, effectiveGender, tunerVersion]);

  return (
    <div
      className={`relative overflow-hidden rounded-2xl select-none ${className}`}
      style={{ width: dims.w, height: dims.h, ...style }}
    >
      {/* Background layer */}
      {background?.imageUrl ? (
        <img
          src={background.imageUrl}
          alt=""
          className="absolute inset-0 w-full h-full object-cover"
          draggable={false}
        />
      ) : (
        <div className="absolute inset-0 bg-gradient-to-b from-indigo-900 to-gray-900" />
      )}

      {/* Avatar layer */}
      {avatar?.imageUrl ? (
        <div className="absolute bottom-0 left-0 right-0 h-[85%] overflow-hidden">
          {(() => {
            const key = resolvedGender === 'girl' ? 'imageUrlGirl' : 'imageUrlBoy';
            const gendered = !shouldForceNoSplit(avatarId)
              ? ((avatar as any)?.[key] as string | undefined)
              : undefined;
            const plain = cosmeticsMap?.get('avatar_1_plain');
            const plainGendered = plain && !shouldForceNoSplit('avatar_1_plain')
              ? ((plain as any)?.[key] as string | undefined)
              : undefined;
            const src = gendered || plainGendered;
            if (!src) return null;
            return (
              <img
                src={src}
                alt={displayName ?? 'Avatar'}
                draggable={false}
                className="absolute bottom-0 left-1/2 h-full w-auto max-w-none"
                style={{
                  transform: shouldForceNoSplit(avatarId)
                    ? avatarTransformNoSplit
                    : avatarTransform,
                }}
              />
            );
          })()}
        </div>
      ) : (
        <div className="absolute bottom-0 left-1/2 -translate-x-1/2 h-[70%] w-[60%] flex items-end justify-center">
          <span className="text-6xl">🧑</span>
        </div>
      )}

      {/* Name bar */}
      {displayName && (
        <div className="absolute bottom-0 inset-x-0 bg-gradient-to-t from-black/70 to-transparent px-2 py-1">
          <p className={`text-white font-semibold text-center truncate ${dims.textSize}`}>
            {displayName}
          </p>
        </div>
      )}
    </div>
  );
}

// ─── ProfileIcon ──────────────────────────────────────────────────────────────

interface ProfileIconProps {
  size?: number;
  avatarId?: string;
  iconId?: string;
  backgroundId?: string;
  gender?: 'boy' | 'girl' | null;
  cosmeticsMap?: Map<string, Cosmetic>;
  className?: string;
}

export function ProfileIcon({
  size = 40,
  avatarId: propAvatarId,
  iconId: propIconId,
  backgroundId: propBackgroundId,
  gender: genderOverride,
  cosmeticsMap: cosmeticsMapOverride,
  className = '',
}: ProfileIconProps) {
  // Re-render whenever the tuner saves.
  const tunerVersion = useTunerVersion();

  const equippedCosmetics = useChemCityStore(
    (s) => ((s.user as any)?.equippedCosmetics as typeof EMPTY_EQUIPPED) || EMPTY_EQUIPPED,
  );
  const userGender = useChemCityStore((s) => (s as any).userGender as 'boy' | 'girl' | null);
  const cosmeticsMapFromStore = useChemCityStore(
    (s) => ((s as any).cosmeticsMap as Map<string, Cosmetic>) || EMPTY_MAP,
  );

  const cosmeticsMap = cosmeticsMapOverride ?? cosmeticsMapFromStore;
  const effectiveGender = genderOverride ?? userGender;
  const resolvedGender: 'boy' | 'girl' = effectiveGender === 'girl' ? 'girl' : 'boy';

  const iconId = propIconId ?? equippedCosmetics.iconId;
  const avatarId = propAvatarId ?? equippedCosmetics.avatarId;
  const backgroundId = propBackgroundId ?? equippedCosmetics.backgroundId;

  const iconCosmetic = iconId ? cosmeticsMap?.get(iconId) : undefined;
  const avatarCosmetic = !iconCosmetic && avatarId ? cosmeticsMap?.get(avatarId) : undefined;
  const backgroundCosmetic = backgroundId ? cosmeticsMap?.get(backgroundId) : undefined;

  const isNoSplit = shouldForceNoSplit(avatarId);

  const globalFaceCrop =
    effectiveGender && avatarCosmetic?.type === 'avatar' && !isNoSplit
      ? getGlobalFaceCrop(effectiveGender)
      : null;

  // For no-split avatars, check the tuner's per-avatar faceCrop stored in localStorage.
  const tunerPerAvatarCrop =
    avatarCosmetic?.type === 'avatar' && isNoSplit
      ? getAvatarFaceCrop(avatarId)
      : null;

  const faceCrop: FaceCropMeta | undefined =
    iconCosmetic?.faceCrop ??
    avatarCosmetic?.faceCrop ??
    (tunerPerAvatarCrop as FaceCropMeta | null) ??
    (globalFaceCrop as FaceCropMeta | null) ??
    undefined;

  const imageUrl = useMemo(() => {
    if (iconCosmetic?.imageUrl) return iconCosmetic.imageUrl;
    const key = resolvedGender === 'girl' ? 'imageUrlGirl' : 'imageUrlBoy';
    const gendered = avatarCosmetic && !isNoSplit
      ? ((avatarCosmetic as any)?.[key] as string | undefined)
      : undefined;
    const plain = cosmeticsMap?.get('avatar_1_plain');
    const plainGendered = plain && !shouldForceNoSplit('avatar_1_plain')
      ? ((plain as any)?.[key] as string | undefined)
      : undefined;
    return gendered || plainGendered;
  }, [iconCosmetic?.imageUrl, avatarCosmetic, isNoSplit, resolvedGender, cosmeticsMap]);

  const avatarTransform = useMemo(() => {
    if (!effectiveGender) return 'translateX(-50%)';
    const tune = getAvatarTuning(avatarId, 'profile_icon', effectiveGender);
    const ox = tune?.offsetXPercent ?? 0;
    const oy = tune?.offsetYPercent ?? 0;
    const sc = tune?.scale ?? 1;
    return `translateX(calc(-50% + ${ox}%)) translateY(${oy}%) scale(${sc})`;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [avatarId, effectiveGender, tunerVersion]);

  const avatarTransformNoSplit = useMemo(() => {
    if (!effectiveGender) return 'translateX(-50%)';
    const tune = getAvatarTuning(avatarId, 'profile_icon', effectiveGender);
    if (!tune) return 'translateX(-50%)';
    const ox = tune.offsetXPercent ?? 0;
    const oy = tune.offsetYPercent ?? 0;
    const sc = tune.scale ?? 1;
    return `translateX(calc(-50% + ${ox}%)) translateY(${oy}%) scale(${sc})`;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [avatarId, effectiveGender, tunerVersion]);

  // Build crop style — tunerVersion in deps ensures it re-runs on tuner save,
  // including changes to per-avatar crops for no-split avatars.
  const cropStyle = useMemo<React.CSSProperties | undefined>(() => {
    if (!faceCrop || !imageUrl) return undefined;
    return faceCropStyle(faceCrop, imageUrl);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [faceCrop, imageUrl, tunerVersion, tunerPerAvatarCrop]);

  return (
    <div
      className={`rounded-full overflow-hidden shrink-0 ${className}`}
      style={{ width: size, height: size, aspectRatio: '1 / 1', background: 'transparent' }}
    >
      <div className="relative w-full h-full">
        {backgroundCosmetic?.imageUrl ? (
          <img
            src={backgroundCosmetic.imageUrl}
            alt=""
            className="absolute inset-0 w-full h-full object-cover"
            draggable={false}
          />
        ) : null}

        {avatarCosmetic?.type === 'avatar' && imageUrl ? (
          <div
            className="absolute overflow-hidden"
            style={{
              bottom: 0,
              left: 0,
              right: 0,
              height: '130%',
              top: '-30%',
            }}
          >
            <img
              src={imageUrl}
              alt=""
              draggable={false}
              className="absolute bottom-0 left-1/2 h-full w-auto max-w-none"
              style={{ transform: isNoSplit ? avatarTransformNoSplit : avatarTransform }}
            />
          </div>
        ) : cropStyle ? (
          <div className="absolute inset-0" style={cropStyle} />
        ) : imageUrl ? (
          <img
            src={imageUrl}
            alt=""
            className="absolute inset-0 w-full h-full max-w-none object-cover object-top"
            draggable={false}
            style={
              iconCosmetic?.type === 'avatar'
                ? {
                    width: '200%',
                    maxWidth: '200%',
                    transform: effectiveGender === 'girl' ? 'translateX(-50%)' : 'translateX(0%)',
                  }
                : undefined
            }
          />
        ) : (
          <div className="absolute inset-0 w-full h-full flex items-center justify-center" style={{ background: 'transparent' }}>
            <span style={{ fontSize: size * 0.5 }}>👤</span>
          </div>
        )}
      </div>
    </div>
  );
}

===== FILE: src/components/chemcity/gacha/PityBar.tsx =====

interface PityBarProps {
  label: string;
  current: number;
  max: number;
  color: 'purple' | 'yellow';
}

const colorMap = {
  purple: {
    track: 'bg-purple-900/40',
    fill: 'bg-purple-500',
    text: 'text-purple-300',
    glow: 'shadow-purple-500/60',
  },
  yellow: {
    track: 'bg-yellow-900/40',
    fill: 'bg-yellow-400',
    text: 'text-yellow-300',
    glow: 'shadow-yellow-500/60',
  },
};

export function PityBar({ label, current, max, color }: PityBarProps) {
  const pct = Math.min((current / max) * 100, 100);
  const c = colorMap[color];
  const isClose = pct >= 75;

  return (
    <div className="flex items-center gap-3">
      <span className={`text-xs w-28 shrink-0 ${c.text}`}>{label}</span>
      <div className={`flex-1 h-2 rounded-full ${c.track} overflow-hidden`}>
        <div
          className={`h-full rounded-full transition-all duration-500 ${c.fill} ${
            isClose ? `shadow-[0_0_6px_1px] ${c.glow}` : ''
          }`}
          style={{ width: `${pct}%` }}
        />
      </div>
      <span className={`text-xs w-14 text-right ${c.text}`}>
        {current} / {max}
      </span>
    </div>
  );
}


===== FILE: src/components/chemcity/gacha/AvatarTuner.tsx =====

import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';

type Gender = 'boy' | 'girl';
export type AvatarTunerContext = 'profile_card' | 'gacha_result' | 'inventory' | 'profile_icon';

type FaceCrop = {
  x: number;
  y: number;
  w: number;
  h: number;
};

type BodyFrame = {
  offsetXPercent?: number;
  offsetYPercent?: number;
  scale?: number;
};

export type AvatarTuning = {
  offsetXPercent?: number;
  offsetYPercent?: number;
  scale?: number;
};

type AvatarTunerEntry = {
  faceCrop?: FaceCrop;
} & Partial<Record<AvatarTunerContext, Partial<Record<Gender, AvatarTuning>>>>;

export type AvatarTunerConfig = {
  version: 1;
  noSplitAvatarNumbers?: number[];
  globalDefaults?: {
    faceCropByGender?: Partial<Record<Gender, FaceCrop>>;
    noSplitFaceCropDefault?: FaceCrop;
    bodyFrameByGender?: Partial<Record<Gender, BodyFrame>>;
    tuningByContext?: Partial<Record<AvatarTunerContext, Partial<Record<Gender, AvatarTuning>>>>;
  };
  byAvatarId?: Record<string, AvatarTunerEntry>;
};

const STORAGE_KEY = 'cc_avatar_tuner_config_v4';

const FALLBACK_FACE_CROPS: Record<Gender, FaceCrop> = {
  boy:  { x: 0.5327, y: 0.1179, w: 0.2449, h: 0.2357 },
  girl: { x: 0.1980, y: 0.1214, w: 0.2857, h: 0.2393 },
};

const FALLBACK_NO_SPLIT_NUMBERS: number[] = [31, 32];

const FALLBACK_NO_SPLIT_FACE_CROP: FaceCrop = { x: 0.30, y: 0.04, w: 0.38, h: 0.26 };

function normalizeAvatarTunerConfig(cfg: AvatarTunerConfig): { normalized: AvatarTunerConfig; changed: boolean } {
  let changed = false;

  const normalized: AvatarTunerConfig = {
    ...DEFAULT_CFG,
    ...cfg,
    globalDefaults: {
      ...(DEFAULT_CFG.globalDefaults || {}),
      ...(cfg.globalDefaults || {}),
      faceCropByGender: {
        ...(DEFAULT_CFG.globalDefaults?.faceCropByGender || {}),
        ...(cfg.globalDefaults?.faceCropByGender || {}),
      },
      bodyFrameByGender: {
        ...(DEFAULT_CFG.globalDefaults?.bodyFrameByGender || {}),
        ...(cfg.globalDefaults?.bodyFrameByGender || {}),
      },
      tuningByContext: {
        ...(DEFAULT_CFG.globalDefaults?.tuningByContext || {}),
        ...(cfg.globalDefaults?.tuningByContext || {}),
      },
    },
    byAvatarId: cfg.byAvatarId || DEFAULT_CFG.byAvatarId,
  };

  const a = JSON.stringify(cfg);
  const b = JSON.stringify(normalized);
  if (a !== b) changed = true;

  return { normalized, changed };
}

export function loadAvatarTunerConfig(): AvatarTunerConfig | null {
  try {
    // Hard cutover: stop using stale v1/v2/v3 data.
    try {
      localStorage.removeItem('cc_avatar_tuner_config_v1');
    } catch {
      // ignore
    }
    try {
      localStorage.removeItem('cc_avatar_tuner_config_v2');
    } catch {
      // ignore
    }
    try {
      localStorage.removeItem('cc_avatar_tuner_config_v3');
    } catch {
      // ignore
    }
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const cfg = JSON.parse(raw) as AvatarTunerConfig;
    const { normalized, changed } = normalizeAvatarTunerConfig(cfg);
    if (changed) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
        window.dispatchEvent(new CustomEvent(TUNER_UPDATED_EVENT, { detail: normalized }));
      } catch {
        // ignore
      }
    }

    return normalized;
  } catch {
    return null;
  }
}

export function getGlobalFaceCrop(gender: Gender): FaceCrop | null {
  const cfg = loadAvatarTunerConfig() ?? DEFAULT_CFG;
  const crop = cfg?.globalDefaults?.faceCropByGender?.[gender] ?? FALLBACK_FACE_CROPS[gender];
  if (!crop) return null;
  const { x, y, w, h } = crop as any;
  if (![x, y, w, h].every((n) => typeof n === 'number' && Number.isFinite(n))) return null;
  return { x, y, w, h };
}

export function getGlobalBodyFrame(gender: Gender): BodyFrame | null {
  const cfg = loadAvatarTunerConfig() ?? DEFAULT_CFG;
  const raw = cfg?.globalDefaults?.bodyFrameByGender?.[gender];
  if (!raw) return null;
  const { offsetXPercent, offsetYPercent, scale } = raw as any;
  const ok = (v: any) => v === undefined || (typeof v === 'number' && Number.isFinite(v));
  if (!ok(offsetXPercent) || !ok(offsetYPercent) || !ok(scale)) return null;
  return { offsetXPercent, offsetYPercent, scale };
}

export const TUNER_UPDATED_EVENT = 'cc-avatar-tuner-updated';

export function saveAvatarTunerConfig(cfg: AvatarTunerConfig): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg));
    window.dispatchEvent(new CustomEvent(TUNER_UPDATED_EVENT, { detail: cfg }));
  } catch {
    // ignore
  }
}

export function shouldForceNoSplit(avatarId: string | undefined | null): boolean {
  const n = avatarNumberFromId(avatarId);
  if (!n) return false;
  const cfg = loadAvatarTunerConfig() ?? DEFAULT_CFG;
  const list = cfg?.noSplitAvatarNumbers ?? FALLBACK_NO_SPLIT_NUMBERS;
  if (Array.isArray(list) && list.includes(n)) return true;
  return false;
}

export function getAvatarTuning(
  avatarId: string | undefined | null,
  ctx: AvatarTunerContext,
  gender: Gender,
): AvatarTuning | null {
  if (!avatarId) return null;

  const cfg = loadAvatarTunerConfig() ?? DEFAULT_CFG;

  // Single-person avatars:
  // - do NOT apply global gender defaults (they assume split halves)
  // - still allow per-avatar per-context tuning
  if (shouldForceNoSplit(avatarId)) {
    const entry =
      cfg?.byAvatarId?.[avatarId]?.[ctx]?.[gender] ??
      cfg?.byAvatarId?.[avatarId]?.[ctx]?.boy ??
      null;
    if (!entry) return { offsetXPercent: 0, offsetYPercent: 0, scale: 1 };
    return {
      offsetXPercent: 0,
      offsetYPercent: 0,
      scale: 1,
      ...(entry || {}),
    };
  }

  const defaults = DEFAULT_OFFSETS[ctx](gender);
  const globalCtx = cfg?.globalDefaults?.tuningByContext?.[ctx];
  const global = (gender === 'boy' ? globalCtx?.boy ?? globalCtx?.girl : globalCtx?.girl) ?? null;

  const entryCtx = cfg?.byAvatarId?.[avatarId]?.[ctx];
  const entry = (gender === 'boy' ? entryCtx?.boy ?? entryCtx?.girl : entryCtx?.girl) ?? null;

  // Always return context defaults for split avatars so call sites can rely on
  // a consistent tuning object (with global defaults + per-avatar overrides layered on top).
  return {
    offsetXPercent: defaults.ox,
    offsetYPercent: defaults.oy,
    scale: defaults.sc,
    ...(global || {}),
    ...(entry || {}),
  };
}

function removePerAvatarTuningOverride(
  prev: AvatarTunerConfig,
  avatarId: string,
  ctx: AvatarTunerContext,
  gender: Gender,
): AvatarTunerConfig {
  const byAvatarId = { ...(prev.byAvatarId || {}) } as any;
  const byId = { ...(byAvatarId[avatarId] || {}) } as any;
  const byCtx = { ...(byId[ctx] || {}) } as any;
  if (byCtx[gender]) delete byCtx[gender];

  const hasAnyGender = Object.keys(byCtx).some((k) => k === 'boy' || k === 'girl');
  if (!hasAnyGender) delete byId[ctx];
  else byId[ctx] = byCtx;

  if (Object.keys(byId).length === 0) delete byAvatarId[avatarId];
  else byAvatarId[avatarId] = byId;

  return {
    ...prev,
    byAvatarId,
  } as AvatarTunerConfig;
}

export function getAvatarFaceCrop(avatarId: string | undefined | null): FaceCrop | null {
  if (!avatarId) return null;
  const cfg = loadAvatarTunerConfig() ?? DEFAULT_CFG;

  const perAvatar = cfg?.byAvatarId?.[avatarId]?.faceCrop;
  if (perAvatar) {
    const { x, y, w, h } = perAvatar;
    if ([x, y, w, h].every((n) => typeof n === 'number' && Number.isFinite(n) && n > 0)) {
      return { x, y, w, h };
    }
  }

  const cfgDefault = cfg?.globalDefaults?.noSplitFaceCropDefault;
  if (cfgDefault) {
    const { x, y, w, h } = cfgDefault;
    if ([x, y, w, h].every((n) => typeof n === 'number' && Number.isFinite(n) && n > 0)) {
      return { x, y, w, h };
    }
  }

  return FALLBACK_NO_SPLIT_FACE_CROP;
}

export function avatarNumberFromId(avatarId: string | undefined | null): number | null {
  if (!avatarId) return null;
  const m = String(avatarId).match(/^avatar_(\d+)_/i);
  if (!m?.[1]) return null;
  const n = Number(m[1]);
  return Number.isFinite(n) ? n : null;
}

function shouldForceNoSplitFromConfig(cfg: AvatarTunerConfig, avatarId: string | undefined | null): boolean {
  const n = avatarNumberFromId(avatarId);
  if (!n) return false;
  const list = cfg?.noSplitAvatarNumbers ?? FALLBACK_NO_SPLIT_NUMBERS;
  return Array.isArray(list) && list.includes(n);
}

function resolveAvatarTuningFromConfig(
  cfg: AvatarTunerConfig,
  avatarId: string | undefined | null,
  ctx: AvatarTunerContext,
  gender: Gender,
): AvatarTuning | null {
  if (!avatarId) return null;

  if (shouldForceNoSplitFromConfig(cfg, avatarId)) {
    const entry =
      (cfg?.byAvatarId as any)?.[avatarId]?.[ctx]?.[gender] ??
      (cfg?.byAvatarId as any)?.[avatarId]?.[ctx]?.boy ??
      null;
    if (!entry) return { offsetXPercent: 0, offsetYPercent: 0, scale: 1 };
    return {
      offsetXPercent: 0,
      offsetYPercent: 0,
      scale: 1,
      ...(entry || {}),
    };
  }

  const defaults = DEFAULT_OFFSETS[ctx](gender);
  const globalCtx = (cfg?.globalDefaults as any)?.tuningByContext?.[ctx];
  const global = (gender === 'boy' ? globalCtx?.boy ?? globalCtx?.girl : globalCtx?.girl) ?? null;
  const entryCtx = (cfg?.byAvatarId as any)?.[avatarId]?.[ctx];
  const entry = (gender === 'boy' ? entryCtx?.boy ?? entryCtx?.girl : entryCtx?.girl) ?? null;

  return {
    offsetXPercent: defaults.ox,
    offsetYPercent: defaults.oy,
    scale: defaults.sc,
    ...(global || {}),
    ...(entry || {}),
  };
}

// ─── AI Alignment Prompt Generator ──────────────────────────────────────────

export function generateAvatarAlignmentPrompt(
  avatarId: string,
  config?: AvatarTunerConfig,
): string {
  const cfg = config ?? loadAvatarTunerConfig() ?? DEFAULT_CFG;
  const num = avatarNumberFromId(avatarId);
  const noSplit = num
    ? (Array.isArray(cfg.noSplitAvatarNumbers) && cfg.noSplitAvatarNumbers.includes(num))
    : false;

  const globalCrops = (cfg.globalDefaults?.faceCropByGender ?? {}) as Partial<Record<Gender, FaceCrop>>;
  const perAvatar = cfg.byAvatarId?.[avatarId] ?? {};
  const contexts: AvatarTunerContext[] = ['profile_card', 'gacha_result', 'inventory', 'profile_icon'];
  const genders: Gender[] = ['boy', 'girl'];

  const lines: string[] = [];

  lines.push('═══════════════════════════════════════════════════════════');
  lines.push(`AVATAR ALIGNMENT DATA  ·  avatarId: "${avatarId}"`);
  lines.push('═══════════════════════════════════════════════════════════');
  lines.push('');
  lines.push(`Avatar number   : ${num ?? '(none — id format not avatar_N_name)'}`)
  lines.push(`No-split mode   : ${noSplit} ${noSplit ? '← entire image is ONE person, do not split' : '← split: left=boy, right=girl'}`);
  lines.push('');

  lines.push('── FACE CROP  (used for ProfileIcon round head thumbnail) ─────────');
  lines.push('   Coordinates are NORMALIZED (0–1) within the gendered half-image.');
  lines.push('   (x,y) = top-left corner of face box; (w,h) = width/height of box');
  lines.push('');

  for (const g of genders) {
    const crop = globalCrops[g];
    if (crop) {
      const { x, y, w, h } = crop;
      const cx = Math.round((x + w / 2) * 100);
      const cy = Math.round((y + h / 2) * 100);
      const scale = Math.max(1 / w, 1 / h);
      const posX = ((0.5 - (x + w / 2) * scale) / (1 - scale)) * 100;
      const posY = ((0.5 - (y + h / 2) * scale) / (1 - scale)) * 100;
      lines.push(`  ${g.toUpperCase()} face:`);
      lines.push(`    x=${x.toFixed(4)}, y=${y.toFixed(4)}, w=${w.toFixed(4)}, h=${h.toFixed(4)}`);
      lines.push(`    Face CENTER is at ~(${cx}%, ${cy}%) of the gendered image`);
      lines.push(`    Face occupies ~${Math.round(w * 100)}% width, ~${Math.round(h * 100)}% height of image`);
      lines.push(`    CSS backgroundSize: ${(scale * 100).toFixed(1)}%`);
      lines.push(`    CSS backgroundPosition: ${posX.toFixed(1)}% ${posY.toFixed(1)}%`);
    } else {
      lines.push(`  ${g.toUpperCase()} face: ⚠️  NOT SET — using fallback (x=0.3, y=0.05, w=0.4, h=0.3)`);
      lines.push(`    → Open Avatar Tuner → Global defaults → Tap-to-crop to set this.`);
    }
    lines.push('');
  }

  lines.push('── BODY FRAME TUNING  (used for full-body avatar display) ─────────');
  lines.push('   offsetXPercent: horizontal shift (negative=left, positive=right)');
  lines.push('   offsetYPercent: vertical shift (negative=up, positive=down)');
  lines.push('   scale: zoom multiplier (1.0=normal, 1.2=20% bigger)');
  lines.push('   All values are % of the container width/height.');
  lines.push('');

  for (const ctx of contexts) {
    lines.push(`  [${ctx}]`);
    const contextDescriptions: Record<AvatarTunerContext, string> = {
      profile_card:  'ProfileCard component — tall card (aspect ~1:1.4), avatar fills bottom 85%',
      gacha_result:  'GachaResultsModal — square card, avatar fills full height bottom-anchored',
      inventory:     'CosmeticsInventory face square — square tile, avatar fills full height',
      profile_icon:  'ProfileIcon circle — small round avatar icon, drag/wheel tuned transform',
    };
    lines.push(`  ${contextDescriptions[ctx]}`);
    for (const g of genders) {
      const tune = (perAvatar as any)?.[ctx]?.[g] as AvatarTuning | undefined;
      const ox = tune?.offsetXPercent ?? (g === 'girl' ? -6 : 6);
      const oy = tune?.offsetYPercent ?? 0;
      const sc = tune?.scale ?? 1;
      const isTuned = tune && (
        tune.offsetXPercent !== undefined ||
        tune.offsetYPercent !== undefined ||
        tune.scale !== undefined
      );
      lines.push(`    ${g}: offsetX=${ox}%, offsetY=${oy}%, scale=${sc}  ${isTuned ? '✓ custom' : '(default)'}`);
      lines.push(`    → CSS: translateX(calc(-50% + ${ox}%)) translateY(${oy}%) scale(${sc})`);
    }
    lines.push('');
  }

  lines.push('── HOW TO ADJUST (instructions for AI coder) ──────────────────────');
  lines.push('');
  lines.push('SPLIT LOGIC:');
  if (noSplit) {
    lines.push('  This avatar is a SINGLE person — do NOT split.');
    lines.push('  Use: imageUrl (full image), no gendered variants.');
    lines.push('  Center the image normally with translateX(-50%).');
  } else {
    lines.push('  This avatar has BOY (left half) and GIRL (right half) variants.');
    lines.push('  The seeder split the original image down the middle with sharp.');
    lines.push('  imageUrlBoy  = left half, transparent-padded, may need trimming offset.');
    lines.push('  imageUrlGirl = right half, transparent-padded, may need trimming offset.');
    lines.push('  Both halves start at translateX(-50%) and offsetX shifts them left/right.');
  }
  lines.push('');
  lines.push('COMMON FIXES:');
  lines.push('  Avatar appears too far LEFT  → increase offsetXPercent (e.g. 0 → 4)');
  lines.push('  Avatar appears too far RIGHT → decrease offsetXPercent (e.g. 6 → 2)');
  lines.push('  Avatar appears too HIGH      → increase offsetYPercent (e.g. 0 → 5)');
  lines.push('  Avatar appears too LOW       → decrease offsetYPercent (e.g. 0 → -5)');
  lines.push('  Avatar appears too SMALL     → increase scale (e.g. 1.0 → 1.15)');
  lines.push('  Avatar appears too BIG       → decrease scale (e.g. 1.0 → 0.9)');
  lines.push('');
  lines.push('FACE CROP FIXES (ProfileIcon round thumbnail):');
  lines.push('  Face too far RIGHT in circle → increase faceCrop.x');
  lines.push('  Face too far LEFT  in circle → decrease faceCrop.x');
  lines.push('  Face too far DOWN  in circle → increase faceCrop.y');
  lines.push('  Face too far UP    in circle → decrease faceCrop.y');
  lines.push('  Face too SMALL (too zoomed out) → decrease faceCrop.w and/or h');
  lines.push('  Face too BIG (too zoomed in)    → increase faceCrop.w and/or h');
  lines.push('');
  lines.push('TUNER TOOL USAGE:');
  lines.push('  • Open Avatar Tuner (Profile page, dev mode only)');
  lines.push('  • Switch to Playground tab for live drag/wheel adjustment');
  lines.push('  • Use "Tap to crop" on preview image to set face box with 2 clicks');
  lines.push('  • Adjust offsetX/Y/scale sliders per context/gender');
  lines.push('  • Export JSON → paste into AvatarTuner DEFAULT_CFG or localStorage');
  lines.push('  • localStorage key: cc_avatar_tuner_config_v4');
  lines.push('');
  lines.push('════════════════════════════════════════════════════════════════════');

  return lines.join('\n');
}

export async function copyAvatarAlignmentPrompt(avatarId: string): Promise<void> {
  const text = generateAvatarAlignmentPrompt(avatarId);
  try {
    await navigator.clipboard.writeText(text);
    console.log('[AvatarTuner] Alignment prompt copied to clipboard for:', avatarId);
    console.log(text);
  } catch {
    console.log('[AvatarTuner] Clipboard blocked. Here is the prompt:');
    console.log(text);
  }
}

export function logAllAvatarAlignmentPrompts(): void {
  const cfg = loadAvatarTunerConfig();
  const ids = Object.keys(cfg?.byAvatarId ?? {});
  if (ids.length === 0) {
    console.log('[AvatarTuner] No per-avatar tuning found. Try setting some values first.');
    console.log('[AvatarTuner] You can still generate a prompt for any avatar ID:');
    console.log('  copyAvatarAlignmentPrompt("avatar_20_yourname")');
    return;
  }
  for (const id of ids) {
    console.log(generateAvatarAlignmentPrompt(id, cfg ?? undefined));
    console.log('');
  }
}

if (typeof window !== 'undefined') {
  (window as any).copyAvatarAlignmentPrompt = copyAvatarAlignmentPrompt;
  (window as any).logAllAvatarAlignmentPrompts = logAllAvatarAlignmentPrompts;
  (window as any).generateAvatarAlignmentPrompt = generateAvatarAlignmentPrompt;
}

// ─── Default Config ───────────────────────────────────────────────────────────

const DEFAULT_CFG: AvatarTunerConfig = {
  version: 1,

  noSplitAvatarNumbers: [31, 32],

  globalDefaults: {
    faceCropByGender: {
      boy:  { x: 0.5327, y: 0.1179, w: 0.2449, h: 0.2357 },
      girl: { x: 0.1980, y: 0.1214, w: 0.2857, h: 0.2393 },
    },
    noSplitFaceCropDefault: { x: 0.30, y: 0.04, w: 0.38, h: 0.26 },
    bodyFrameByGender: {
      boy: { scale: 1 },
      girl: { scale: 1 },
    },
    tuningByContext: {
      profile_card: {
        boy: { offsetXPercent: 1, offsetYPercent: -14.1, scale: 1.16 },
        girl: { offsetXPercent: 1, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: 0, offsetYPercent: 0, scale: 0.88 },
        girl: { offsetXPercent: 0, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: 1, offsetYPercent: 45.2, scale: 3.12 },
        girl: { offsetXPercent: 1, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: 1, offsetYPercent: 42.1, scale: 2.42 },
        girl: { offsetXPercent: 1, offsetYPercent: 42.1, scale: 2.42 },
      },
    },
  },

  byAvatarId: {
    avatar_38_dino: {
      profile_card: {
        boy: { offsetXPercent: -3, offsetYPercent: -15.5, scale: 1 },
        girl: { offsetXPercent: 0.5, offsetYPercent: -16.4, scale: 1 },
      },
      gacha_result: {
        boy: { offsetXPercent: -3, offsetYPercent: -3, scale: 0.98 },
        girl: { offsetXPercent: 0, offsetYPercent: -4.2, scale: 0.98 },
      },
      inventory: {
        boy: { offsetXPercent: -14.5, offsetYPercent: 40.5, scale: 3.16 },
        girl: { offsetXPercent: -0.5, offsetYPercent: 39.6, scale: 3.08 },
      },
      profile_icon: {
        boy: { offsetXPercent: -15, offsetYPercent: 40.2, scale: 2.62 },
        girl: { offsetXPercent: 0.6, offsetYPercent: 38.4, scale: 2.62 },
      },
    },

    avatar_56_oil: {
      profile_card: {
        girl: { offsetXPercent: 2, offsetYPercent: -16.8, scale: 1.2 },
        boy: { offsetXPercent: 0.5, offsetYPercent: -16.5 },
      },
      inventory: {
        boy: { scale: 2.36, offsetXPercent: 3, offsetYPercent: 35.5 },
        girl: { scale: 3.12, offsetXPercent: 5.5, offsetYPercent: 45.2 },
      },
      profile_icon: {
        boy: { offsetXPercent: 3.6, offsetYPercent: 39, scale: 2.32 },
        girl: { offsetXPercent: 4.6, offsetYPercent: 42.1, scale: 2.42 },
      },
      gacha_result: {
        boy: { offsetXPercent: 1.5, offsetYPercent: -2.5 },
        girl: { offsetXPercent: 0.5, offsetYPercent: -1.5, scale: 0.88 },
      },
    },

    avatar_63_pikachu: {
      profile_card: {
        boy: { offsetXPercent: 5, offsetYPercent: -14.1, scale: 1.16 },
        girl: { offsetXPercent: 4.6, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: 4, offsetYPercent: 0, scale: 0.58 },
        girl: { offsetXPercent: 4.3, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: 13.9, offsetYPercent: 45.5, scale: 3.12 },
        girl: { offsetXPercent: 11.5, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: 12.4, offsetYPercent: 42.1, scale: 2.42 },
        girl: { offsetXPercent: 11.1, offsetYPercent: 42.1, scale: 2.42 },
      },
    },

    avatar_75_tempest: {
      profile_card: {
        boy: { offsetXPercent: 9, offsetYPercent: -14.1, scale: 1.16 },
        girl: { offsetXPercent: 10.8, offsetYPercent: -13.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: 5.7, offsetYPercent: 0, scale: 0.88 },
        girl: { offsetXPercent: 6.9, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: 16.4, offsetYPercent: 45.8, scale: 3.12 },
        girl: { offsetXPercent: 23.4, offsetYPercent: 46.9, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: 15.7, offsetYPercent: 42.1, scale: 2.42 },
        girl: { offsetXPercent: 20.9, offsetYPercent: 44.5, scale: 2.42 },
      },
    },

    avatar_62_wizard: {
      profile_card: {
        boy: { offsetXPercent: -5.3, offsetYPercent: -14.1, scale: 1.16 },
        girl: { offsetXPercent: -1.6, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: -5.1, offsetYPercent: 0, scale: 0.88 },
        girl: { offsetXPercent: -2.2, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: -11.5, offsetYPercent: 45.2, scale: 3.12 },
        girl: { offsetXPercent: -7.2, offsetYPercent: 45, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: -10.7, offsetYPercent: 41.9, scale: 2.42 },
        girl: { offsetXPercent: -7.2, offsetYPercent: 42.1, scale: 2.42 },
      },
    },

    avatar_16_forest: {
      profile_card: {
        boy: { offsetXPercent: -5.9, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: -4.3, offsetYPercent: 0.2, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: -14.2, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: -12.2, offsetYPercent: 42.1, scale: 2.42 },
      },
    },

    avatar_68_pajama: {
      profile_card: {
        boy: { offsetXPercent: -2.3, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: -2.7, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: -5.6, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: -5.3, offsetYPercent: 42.7, scale: 2.42 },
      },
    },

    avatar_71_stone_age: {
      profile_card: {
        boy: { offsetXPercent: -6.7, offsetYPercent: -13.9, scale: 1.16 },
        girl: { offsetXPercent: -3, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: -6.1, offsetYPercent: -0.2, scale: 0.88 },
        girl: { offsetXPercent: -3.1, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: -17.8, offsetYPercent: 45.2, scale: 3.12 },
        girl: { offsetXPercent: -10.6, offsetYPercent: 45.4, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: -15, offsetYPercent: 42.1, scale: 2.42 },
        girl: { offsetXPercent: -8.5, offsetYPercent: 42.3, scale: 2.42 },
      },
    },

    avatar_3_cat: {
      profile_card: {
        boy: { offsetXPercent: 9.6, offsetYPercent: -14.1, scale: 1.16 },
        girl: { offsetXPercent: 9, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: 6.8, offsetYPercent: -0.3, scale: 0.88 },
        girl: { offsetXPercent: 6.3, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: 23.5, offsetYPercent: 44.7, scale: 3.12 },
        girl: { offsetXPercent: 23.3, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: 21, offsetYPercent: 42.1, scale: 2.42 },
        girl: { offsetXPercent: 20.1, offsetYPercent: 42.3, scale: 2.42 },
      },
    },

    avatar_47_singer: {
      profile_card: {
        boy: { offsetXPercent: 2.3, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: 1.2, offsetYPercent: 0, scale: 0.6 },
      },
      inventory: {
        boy: { offsetXPercent: 6.1, offsetYPercent: 45.3, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: 5.4, offsetYPercent: 42.1, scale: 2.42 },
      },
    },

    avatar_21_robot: {
      profile_card: {
        boy: { offsetXPercent: -1, offsetYPercent: -14.1, scale: 1.16 },
      },
    },

    avatar_26_antman: {
      profile_card: {
        boy: { offsetXPercent: 5.9, offsetYPercent: 16.8, scale: 0.5 },
        girl: { offsetXPercent: 1.6, offsetYPercent: -13.8, scale: 0.5 },
      },
      gacha_result: {
        girl: { offsetXPercent: 1.8, offsetYPercent: 18.3, scale: 0.5 },
        boy: { offsetXPercent: 6.9, offsetYPercent: 15, scale: 0.5 },
      },
      inventory: {
        boy: { offsetXPercent: 16.8, offsetYPercent: 33.9, scale: 1.58 },
        girl: { offsetXPercent: 3.6, offsetYPercent: 29.3, scale: 1.36 },
      },
      profile_icon: {
        boy: { offsetXPercent: 9.8, offsetYPercent: 30, scale: 0.96 },
        girl: { offsetXPercent: 3.8, offsetYPercent: 28.5, scale: 1.4 },
      },
    },

    avatar_79_champion: {
      profile_card: {
        girl: { offsetXPercent: -7.5, offsetYPercent: -14, scale: 1.16 },
      },
      gacha_result: {
        girl: { offsetXPercent: -5.9, offsetYPercent: -0.3, scale: 0.88 },
      },
      inventory: {
        girl: { offsetXPercent: -19.9, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        girl: { offsetXPercent: -18, offsetYPercent: 42.1, scale: 2.42 },
      },
    },

    avatar_67_lego: {
      profile_card: {
        girl: { offsetXPercent: 3.7, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        girl: { offsetXPercent: 2.9, offsetYPercent: 0, scale: 0.88 },
      },
      inventory: {
        girl: { offsetXPercent: 8.6, offsetYPercent: 45.2, scale: 3.12 },
      },
      profile_icon: {
        girl: { offsetXPercent: 7.1, offsetYPercent: 42.3, scale: 2.42 },
      },
    },

    avatar_84_smurf: {
      profile_card: {
        boy: { offsetXPercent: 5.7, offsetYPercent: -14.1, scale: 1.16 },
        girl: { offsetXPercent: -5.7, offsetYPercent: -14.1, scale: 1.16 },
      },
      gacha_result: {
        boy: { offsetXPercent: 3.7, offsetYPercent: 0, scale: 0.88 },
        girl: { offsetXPercent: -5, offsetYPercent: 0.3, scale: 0.88 },
      },
      inventory: {
        boy: { offsetXPercent: 20.7, offsetYPercent: 31, scale: 3.12 },
        girl: { offsetXPercent: -14.5, offsetYPercent: 34.4, scale: 3.12 },
      },
      profile_icon: {
        boy: { offsetXPercent: 17.9, offsetYPercent: 32.4, scale: 2.42 },
        girl: { offsetXPercent: -14.1, offsetYPercent: 32, scale: 2.42 },
      },
    },
  },
};

// ─── Playground Preview Component ─────────────────────────────────────────────

const CONTEXT_META: Record<AvatarTunerContext, {
  label: string;
  aspect: string;
  shape: 'rect' | 'circle';
  avatarHeightPercent: number;
  bgColor: string;
  description: string;
}> = {
  profile_card: {
    label: 'Profile Card',
    aspect: 'aspect-[4/5.5]',
    shape: 'rect',
    avatarHeightPercent: 85,
    bgColor: 'from-indigo-900 to-gray-900',
    description: 'Tall card • avatar bottom 85%',
  },
  gacha_result: {
    label: 'Gacha Result',
    aspect: 'aspect-square',
    shape: 'rect',
    avatarHeightPercent: 100,
    bgColor: 'from-slate-800 to-slate-950',
    description: 'Square card • full height',
  },
  inventory: {
    label: 'Inventory Tile',
    aspect: 'aspect-square',
    shape: 'rect',
    avatarHeightPercent: 100,
    bgColor: 'from-teal-900 to-slate-900',
    description: 'Square tile • contain + bottom align',
  },
  profile_icon: {
    label: 'Profile Icon',
    aspect: 'aspect-square',
    shape: 'circle',
    avatarHeightPercent: 130,
    bgColor: 'from-slate-700 to-slate-900',
    description: 'Circle icon • head crop',
  },
};

const DEFAULT_OFFSETS: Record<AvatarTunerContext, (g: Gender) => { ox: number; oy: number; sc: number }> = {
  profile_card:  (_g) => ({ ox: 0, oy: 0, sc: 1.2 }),
  gacha_result:  (_g) => ({ ox: 0, oy: 0, sc: 0.88 }),
  inventory:     (_g) => ({ ox: 0, oy: 0, sc: 0.6 }),
  profile_icon:  (_g) => ({ ox: 0, oy: 0, sc: 1.8 }),
};

interface PlaygroundPreviewProps {
  ctx: AvatarTunerContext;
  gender: Gender;
  avatarId: string;
  imageUrl: string;
  noSplit: boolean;
  tuning: any;
  onDelta: (ctx: AvatarTunerContext, gender: Gender, dox: number, doy: number) => void;
  onWheel: (ctx: AvatarTunerContext, gender: Gender, delta: number) => void;
  onReset: (ctx: AvatarTunerContext, gender: Gender) => void;
}

function PlaygroundPreview({
  ctx,
  gender,
  avatarId,
  imageUrl,
  noSplit,
  tuning,
  onDelta,
  onWheel,
  onReset,
}: PlaygroundPreviewProps) {
  const meta = CONTEXT_META[ctx];
  const containerRef = useRef<HTMLDivElement>(null);
  const dragRef = useRef<{ startX: number; startY: number; active: boolean }>({
    startX: 0,
    startY: 0,
    active: false,
  });

  const defaults = DEFAULT_OFFSETS[ctx](gender);
  const ox = (tuning?.offsetXPercent ?? defaults.ox);
  const oy = (tuning?.offsetYPercent ?? defaults.oy);
  const sc = (tuning?.scale ?? defaults.sc);

  const transform = ctx === 'inventory'
    ? `translate(${ox}%, ${oy}%) scale(${sc})`
    : `translateX(calc(-50% + ${ox}%)) translateY(${oy}%) scale(${sc})`;

  const cropStyle = useMemo<React.CSSProperties | null>(() => {
    if (ctx !== 'inventory') return null;
    if (!imageUrl) return null;
    return {
      backgroundImage: `url(${imageUrl})`,
      backgroundSize: 'contain',
      backgroundPosition: '50% 100%',
      backgroundRepeat: 'no-repeat',
    };
  }, [ctx, imageUrl, noSplit, avatarId, gender]);

  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    e.currentTarget.setPointerCapture(e.pointerId);
    dragRef.current = { startX: e.clientX, startY: e.clientY, active: true };
  }, []);

  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!dragRef.current.active) return;
    const el = containerRef.current;
    if (!el) return;
    const rect = el.getBoundingClientRect();
    const dx = ((e.clientX - dragRef.current.startX) / rect.width) * 100;
    const dy = ((e.clientY - dragRef.current.startY) / rect.height) * 100;
    dragRef.current.startX = e.clientX;
    dragRef.current.startY = e.clientY;
    onDelta(ctx, gender, dx, dy);
  }, [ctx, gender, onDelta]);

  const handlePointerUp = useCallback(() => {
    dragRef.current.active = false;
  }, []);

  const handleWheel = useCallback((e: React.WheelEvent) => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.02 : 0.02;
    onWheel(ctx, gender, delta);
  }, [ctx, gender, onWheel]);

  const isCircle = meta.shape === 'circle';

  return (
    <div className="flex flex-col gap-2">
      {/* Label */}
      <div className="flex items-center justify-between">
        <div>
          <div className="text-xs font-bold text-slate-700">{meta.label}</div>
          <div className="text-[10px] text-slate-400">{meta.description}</div>
        </div>
        <button
          type="button"
          onClick={() => onReset(ctx, gender)}
          className="text-[10px] px-2 py-1 rounded-md border border-slate-200 text-slate-500 hover:border-slate-400 hover:text-slate-700 transition-colors"
          title="Reset to defaults"
        >
          ↺ Reset
        </button>
      </div>

      {/* Preview container */}
      <div
        ref={containerRef}
        className={`relative overflow-hidden cursor-grab active:cursor-grabbing select-none border-2 border-slate-200 hover:border-indigo-300 transition-colors ${
          isCircle ? 'rounded-full mx-auto' : 'rounded-xl w-full'
        } ${meta.aspect} bg-gradient-to-b ${meta.bgColor}`}
        style={isCircle ? { width: '80%', paddingBottom: '80%', height: 0, borderRadius: '50%' } : {}}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerLeave={handlePointerUp}
        onWheel={handleWheel}
      >
        <div className={`absolute inset-0 bg-gradient-to-b ${meta.bgColor}`} />

        {/* Avatar image */}
        {imageUrl ? (
          ctx === 'inventory' ? (
            <div
              className="absolute"
              style={{
                inset: 0,
                transform,
                transformOrigin: 'center center',
              }}
            >
              <div className="absolute inset-0" style={cropStyle || undefined} />
            </div>
          ) : (
            <div
              className="absolute overflow-hidden"
              style={{
                bottom: 0,
                left: 0,
                right: 0,
                height: `${meta.avatarHeightPercent}%`,
                top: meta.avatarHeightPercent > 100 ? `-${meta.avatarHeightPercent - 100}%` : 'auto',
              }}
            >
              <img
                src={imageUrl}
                alt="Avatar preview"
                draggable={false}
                className="absolute bottom-0 left-1/2 h-full w-auto max-w-none pointer-events-none"
                style={{ transform }}
              />
            </div>
          )
        ) : (
          <div className="absolute inset-0 flex items-center justify-center text-3xl opacity-40">
            🧑
          </div>
        )}

        {/* Drag hint overlay — shown briefly */}
        <div className="absolute inset-0 flex items-end justify-center pb-1 pointer-events-none">
          <span className="text-[9px] text-white/40 font-semibold tracking-wide">
            drag · scroll to zoom
          </span>
        </div>
      </div>

      {/* Live numeric readout */}
      <div className="grid grid-cols-3 gap-1">
        {[
          { label: 'X%', value: ox.toFixed(1) },
          { label: 'Y%', value: oy.toFixed(1) },
          { label: 'sc', value: sc.toFixed(2) },
        ].map(({ label, value }) => (
          <div key={label} className="bg-slate-50 rounded-md px-1.5 py-1 text-center border border-slate-200">
            <div className="text-[9px] text-slate-400 font-semibold">{label}</div>
            <div className="text-xs font-mono font-bold text-slate-700">{value}</div>
          </div>
        ))}
      </div>
    </div>
  );
}

// ─── Tuner Button ─────────────────────────────────────────────────────────────

export function AvatarTunerButton({
  avatarId,
  avatarImageUrl,
  avatarImageUrlBoy,
  avatarImageUrlGirl,
  className = '',
  style,
}: {
  avatarId?: string;
  avatarImageUrl?: string;
  avatarImageUrlBoy?: string;
  avatarImageUrlGirl?: string;
  className?: string;
  style?: React.CSSProperties;
}) {
  const [open, setOpen] = useState(false);

  const enable = useMemo(() => {
    try {
      const isDev = Boolean((import.meta as any)?.env?.DEV);
      const host = (typeof window !== 'undefined' ? window.location.hostname : '') || '';
      const isLocalhost = host === 'localhost' || host === '127.0.0.1';
      return isDev || isLocalhost || localStorage.getItem('cc_enable_avatar_tuner') === '1';
    } catch {
      return false;
    }
  }, []);

  if (!enable) return null;

  return (
    <>
      <button
        type="button"
        onClick={() => setOpen(true)}
        className={className}
        style={style}
      >
        🎛 Avatar Tuner
      </button>
      {open ? (
        <AvatarTunerModal
          avatarId={avatarId}
          avatarImageUrl={avatarImageUrl}
          avatarImageUrlBoy={avatarImageUrlBoy}
          avatarImageUrlGirl={avatarImageUrlGirl}
          onClose={() => setOpen(false)}
        />
      ) : null}
    </>
  );
}

// ─── Tuner Modal ──────────────────────────────────────────────────────────────

function AvatarTunerModal({
  avatarId,
  avatarImageUrl,
  avatarImageUrlBoy,
  avatarImageUrlGirl,
  onClose,
}: {
  avatarId?: string;
  avatarImageUrl?: string;
  avatarImageUrlBoy?: string;
  avatarImageUrlGirl?: string;
  onClose: () => void;
}) {
  const [cfg, setCfg] = useState<AvatarTunerConfig>(() => loadAvatarTunerConfig() ?? DEFAULT_CFG);
  const [tapGender, setTapGender] = useState<Gender>('boy');
  const [tapStart, setTapStart] = useState<{ x: number; y: number } | null>(null);
  const [copyStatus, setCopyStatus] = useState<string | null>(null);
  const [importText, setImportText] = useState<string>('');
  const [importStatus, setImportStatus] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'tuning' | 'playground' | 'prompt' | 'import'>('tuning');

  // Playground state
  const [playGender, setPlayGender] = useState<Gender>('boy');

  const didMountRef = useRef(false);

  useEffect(() => {
    if (!didMountRef.current) {
      didMountRef.current = true;
      return;
    }
    saveAvatarTunerConfig(cfg);
  }, [cfg]);

  const safeAvatarId = avatarId || '';

  const tuning = useMemo(() => {
    return cfg.byAvatarId?.[safeAvatarId] || {};
  }, [cfg.byAvatarId, safeAvatarId]);

  const resolvedTuningByContext = useMemo(() => {
    const out: Record<string, Record<string, AvatarTuning | null>> = {};
    const contexts: AvatarTunerContext[] = ['profile_card', 'gacha_result', 'inventory', 'profile_icon'];
    const genders: Gender[] = ['boy', 'girl'];
    for (const ctx of contexts) {
      out[ctx] = {};
      for (const g of genders) {
        out[ctx][g] = resolveAvatarTuningFromConfig(cfg, safeAvatarId, ctx, g);
      }
    }
    return out;
  }, [cfg, safeAvatarId]);

  const applyCurrentAsGlobalDefaults = useCallback(() => {
    if (!safeAvatarId) return;
    setCfg((prev) => {
      const next: AvatarTunerConfig = {
        ...prev,
        globalDefaults: {
          ...(prev.globalDefaults || {}),
          tuningByContext: { ...((prev.globalDefaults as any)?.tuningByContext || {}) },
        },
      };

      const contexts: AvatarTunerContext[] = ['profile_card', 'gacha_result', 'inventory', 'profile_icon'];
      const genders: Gender[] = ['boy', 'girl'];

      for (const ctx of contexts) {
        (next.globalDefaults as any).tuningByContext[ctx] = {
          ...(((next.globalDefaults as any).tuningByContext || {})[ctx] || {}),
        };
        for (const g of genders) {
          const resolved = resolveAvatarTuningFromConfig(prev, safeAvatarId, ctx, g) || {
            offsetXPercent: DEFAULT_OFFSETS[ctx](g).ox,
            offsetYPercent: DEFAULT_OFFSETS[ctx](g).oy,
            scale: DEFAULT_OFFSETS[ctx](g).sc,
          };
          (next.globalDefaults as any).tuningByContext[ctx][g] = {
            offsetXPercent: resolved.offsetXPercent,
            offsetYPercent: resolved.offsetYPercent,
            scale: resolved.scale,
          };
        }
      }
      return next;
    });
    setCopyStatus('✓ Applied current avatar tuning as GLOBAL defaults (all contexts, both genders).');
  }, [safeAvatarId]);

  const noSplitNum = avatarNumberFromId(safeAvatarId);
  const noSplitEnabled =
    !!noSplitNum && Array.isArray(cfg.noSplitAvatarNumbers) && cfg.noSplitAvatarNumbers.includes(noSplitNum);

  // Resolve gendered image URL for playground
  const playImageUrl = useMemo(() => {
    if (noSplitEnabled) return avatarImageUrl || '';
    if (playGender === 'boy') return avatarImageUrlBoy || avatarImageUrl || '';
    return avatarImageUrlGirl || avatarImageUrl || '';
  }, [avatarImageUrl, avatarImageUrlBoy, avatarImageUrlGirl, playGender, noSplitEnabled]);

  // ── Playground handlers ──────────────────────────────────────────────────

  const handlePlaygroundDelta = useCallback((
    ctx: AvatarTunerContext,
    gender: Gender,
    dox: number,
    doy: number,
  ) => {
    setCfg((prev) => {
      const resolved = resolveAvatarTuningFromConfig(prev, safeAvatarId, ctx, gender) || {
        offsetXPercent: DEFAULT_OFFSETS[ctx](gender).ox,
        offsetYPercent: DEFAULT_OFFSETS[ctx](gender).oy,
        scale: DEFAULT_OFFSETS[ctx](gender).sc,
      };
      const newOx = Math.round(((resolved.offsetXPercent ?? 0) + dox) * 10) / 10;
      const newOy = Math.round(((resolved.offsetYPercent ?? 0) + doy) * 10) / 10;
      return mergeTuning(prev, safeAvatarId, ctx, gender, {
        offsetXPercent: newOx,
        offsetYPercent: newOy,
        scale: resolved.scale,
      });
    });
  }, [safeAvatarId]);

  const handlePlaygroundWheel = useCallback((
    ctx: AvatarTunerContext,
    gender: Gender,
    delta: number,
  ) => {
    setCfg((prev) => {
      const resolved = resolveAvatarTuningFromConfig(prev, safeAvatarId, ctx, gender) || {
        offsetXPercent: DEFAULT_OFFSETS[ctx](gender).ox,
        offsetYPercent: DEFAULT_OFFSETS[ctx](gender).oy,
        scale: DEFAULT_OFFSETS[ctx](gender).sc,
      };

      const raw = (resolved.scale ?? 1) + delta;
      const newSc = Math.round(Math.min(5, Math.max(0.5, raw)) * 100) / 100;

      return mergeTuning(prev, safeAvatarId, ctx, gender, {
        offsetXPercent: resolved.offsetXPercent,
        offsetYPercent: resolved.offsetYPercent,
        scale: newSc,
      });
    });
  }, [safeAvatarId]);

  const handlePlaygroundReset = useCallback((ctx: AvatarTunerContext, gender: Gender) => {
    setCfg((prev) => {
      // Reset should revert to GLOBAL style (defaults + global tuning),
      // so we remove the per-avatar override for this ctx/gender.
      return removePerAvatarTuningOverride(prev, safeAvatarId, ctx, gender);
    });
  }, [safeAvatarId]);

  // ── Tuning tab helpers ───────────────────────────────────────────────────

  function setTuningValue(
    ctx: AvatarTunerContext,
    gender: Gender,
    key: keyof AvatarTuning,
    value: number,
  ) {
    setCfg((prev) => {
      const next: AvatarTunerConfig = {
        ...prev,
        byAvatarId: { ...(prev.byAvatarId || {}) },
      };
      const byId = { ...(next.byAvatarId?.[safeAvatarId] || {}) };
      const byCtx = { ...(byId[ctx] || {}) } as any;
      const byGender = { ...(byCtx[gender] || {}) };
      byGender[key] = value;
      byCtx[gender] = byGender;
      (byId as any)[ctx] = byCtx;
      next.byAvatarId![safeAvatarId] = byId as any;
      return next;
    });
  }

  function getValue(ctx: AvatarTunerContext, gender: Gender, key: keyof AvatarTuning, fallback: number) {
    const v = (resolvedTuningByContext as any)?.[ctx]?.[gender]?.[key];
    return typeof v === 'number' && Number.isFinite(v) ? v : fallback;
  }

  function toggleNoSplit() {
    if (!noSplitNum) return;
    setCfg((prev) => {
      const list = Array.isArray(prev.noSplitAvatarNumbers) ? [...prev.noSplitAvatarNumbers] : [];
      const idx = list.indexOf(noSplitNum);
      if (idx >= 0) list.splice(idx, 1);
      else list.push(noSplitNum);
      list.sort((a, b) => a - b);
      return { ...prev, noSplitAvatarNumbers: list };
    });
  }

  const jsonText = useMemo(() => JSON.stringify(cfg, null, 2), [cfg]);

  const promptText = useMemo(
    () => generateAvatarAlignmentPrompt(safeAvatarId, cfg),
    [safeAvatarId, cfg],
  );

  function copyText(text: string, label: string) {
    try {
      navigator.clipboard
        .writeText(text)
        .then(() => setCopyStatus(`✓ ${label} copied to clipboard`))
        .catch(() => setCopyStatus('Clipboard blocked — use Select All'));
    } catch {
      setCopyStatus('Clipboard blocked — use Select All');
    }
  }

  function selectTextarea(id: string) {
    const el = document.getElementById(id) as HTMLTextAreaElement | null;
    if (!el) return;
    el.focus();
    el.select();
    try { document.execCommand('copy'); } catch { /* ignore */ }
    setCopyStatus('Selected. Press Cmd+C / Ctrl+C to copy.');
  }

  function downloadJson() {
    try {
      const blob = new Blob([jsonText], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cc_avatar_tuner_config_v4.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setCopyStatus('Downloaded JSON file.');
    } catch {
      setCopyStatus('Download failed.');
    }
  }

  function applyImportedJson() {
    try {
      const parsed = JSON.parse(importText);
      if (!parsed || parsed.version !== 1) {
        setImportStatus('Invalid JSON: expected { version: 1, ... }.');
        return;
      }
      setCfg(parsed as AvatarTunerConfig);
      setActiveTab('tuning');
      setImportStatus('✓ Imported and applied — check the Tuning tab to verify values.');
    } catch {
      setImportStatus('Invalid JSON (parse failed). Make sure you copied the full JSON block.');
    }
  }

  function setPerAvatarFaceCrop(key: keyof FaceCrop, value: number) {
    if (!safeAvatarId) return;
    setCfg((prev) => {
      const next: AvatarTunerConfig = {
        ...prev,
        byAvatarId: { ...(prev.byAvatarId || {}) },
      };
      const byId = { ...(next.byAvatarId?.[safeAvatarId] || {}) };
      const existing: FaceCrop = (byId.faceCrop as FaceCrop | undefined) || { x: 0.3, y: 0.05, w: 0.35, h: 0.3 };
      (byId as any).faceCrop = { ...existing, [key]: value };
      next.byAvatarId![safeAvatarId] = byId as any;
      return next;
    });
  }

  function setGlobalFaceCrop(gender: Gender, key: keyof FaceCrop, value: number) {
    setCfg((prev) => {
      const next: AvatarTunerConfig = {
        ...prev,
        globalDefaults: {
          ...(prev.globalDefaults || {}),
          faceCropByGender: { ...(prev.globalDefaults?.faceCropByGender || {}) },
        },
      };
      const existing =
        (next.globalDefaults!.faceCropByGender?.[gender] || { x: 0.3, y: 0.05, w: 0.4, h: 0.3 }) as FaceCrop;
      next.globalDefaults!.faceCropByGender![gender] = { ...existing, [key]: value };
      return next;
    });
  }

  function getGlobalFaceCropValue(gender: Gender, key: keyof FaceCrop, fallback: number) {
    const v = (cfg.globalDefaults?.faceCropByGender as any)?.[gender]?.[key];
    return typeof v === 'number' && Number.isFinite(v) ? v : fallback;
  }

  function getPerAvatarFaceCropValue(key: keyof FaceCrop, fallback: number) {
    const v = (cfg.byAvatarId?.[safeAvatarId] as any)?.faceCrop?.[key];
    return typeof v === 'number' && Number.isFinite(v) ? v : fallback;
  }

  const previewUrl = useMemo(() => {
    if (noSplitEnabled) return avatarImageUrl || '';
    if (tapGender === 'boy') return avatarImageUrlBoy || avatarImageUrl || '';
    return avatarImageUrlGirl || avatarImageUrl || '';
  }, [avatarImageUrl, avatarImageUrlBoy, avatarImageUrlGirl, tapGender, noSplitEnabled]);

  function handlePreviewClick(e: React.MouseEvent<HTMLImageElement>) {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    const nx = Math.max(0, Math.min(1, x));
    const ny = Math.max(0, Math.min(1, y));

    if (!tapStart) {
      setTapStart({ x: nx, y: ny });
      return;
    }

    const x1 = Math.min(tapStart.x, nx);
    const y1 = Math.min(tapStart.y, ny);
    const x2 = Math.max(tapStart.x, nx);
    const y2 = Math.max(tapStart.y, ny);
    const w = Math.max(0.01, x2 - x1);
    const h = Math.max(0.01, y2 - y1);

    if (noSplitEnabled) {
      setPerAvatarFaceCrop('x', Number(x1.toFixed(4)));
      setPerAvatarFaceCrop('y', Number(y1.toFixed(4)));
      setPerAvatarFaceCrop('w', Number(w.toFixed(4)));
      setPerAvatarFaceCrop('h', Number(h.toFixed(4)));
    } else {
      setGlobalFaceCrop(tapGender, 'x', Number(x1.toFixed(4)));
      setGlobalFaceCrop(tapGender, 'y', Number(y1.toFixed(4)));
      setGlobalFaceCrop(tapGender, 'w', Number(w.toFixed(4)));
      setGlobalFaceCrop(tapGender, 'h', Number(h.toFixed(4)));
    }
    setTapStart(null);
  }

  const ALL_CONTEXTS: AvatarTunerContext[] = ['profile_card', 'gacha_result', 'inventory', 'profile_icon'];

  return (
    <div className="fixed inset-0 z-[9999]">
      <div className="absolute inset-0 bg-black/70" onClick={onClose} />
      <div className="absolute left-1/2 top-1/2 w-[min(900px,96vw)] max-h-[90vh] -translate-x-1/2 -translate-y-1/2 rounded-2xl bg-white text-slate-900 overflow-hidden shadow-2xl flex flex-col">

        {/* Header */}
        <div className="flex items-center justify-between px-4 py-3 border-b bg-slate-50 shrink-0 flex-wrap gap-2">
          <div className="font-bold text-slate-800">🎛 Avatar Tuner</div>
          <div className="flex items-center gap-2 flex-wrap">
            {([
              ['tuning',     '🎚 Tuning'],
              ['playground', '🕹 Playground'],
              ['prompt',     '📋 AI Prompt'],
              ['import',     '⬆ Import'],
            ] as const).map(([tab, label]) => (
              <button
                key={tab}
                type="button"
                onClick={() => setActiveTab(tab)}
                className={`px-3 py-1.5 rounded-lg text-sm font-semibold border transition-colors ${
                  activeTab === tab
                    ? 'bg-slate-900 text-white border-slate-900'
                    : 'bg-white border-slate-200 text-slate-700 hover:border-slate-400'
                }`}
              >
                {label}
              </button>
            ))}
            <button type="button" className="px-3 py-1.5 rounded-lg border text-sm" onClick={downloadJson}>
              ⬇ JSON
            </button>
            <button type="button" className="px-3 py-1.5 rounded-lg border text-sm" onClick={onClose}>
              ✕
            </button>
          </div>
        </div>

        {copyStatus && (
          <div className="bg-green-50 text-green-800 text-xs px-4 py-2 border-b border-green-200 shrink-0">
            {copyStatus}
          </div>
        )}

        <div className="overflow-auto flex-1 p-4 space-y-4">

          {/* ── PLAYGROUND TAB ── */}
          {activeTab === 'playground' && (
            <div className="space-y-4">
              {/* Avatar ID + info strip */}
              <div className="flex items-center gap-3 text-sm bg-slate-100 rounded-lg px-3 py-2">
                <span className="font-mono text-slate-600">
                  avatarId: <span className="text-slate-900 font-bold">{safeAvatarId || '(none)'}</span>
                </span>
                <span className="text-slate-400">·</span>
                <span className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                  noSplitEnabled
                    ? 'bg-amber-100 text-amber-700 border border-amber-200'
                    : 'bg-indigo-100 text-indigo-700 border border-indigo-200'
                }`}>
                  {noSplitEnabled ? 'single-person' : 'split (boy / girl)'}
                </span>
              </div>

              {/* Instructions */}
              <div className="bg-blue-50 border border-blue-200 rounded-lg px-3 py-2 text-xs text-blue-800">
                <strong>Drag</strong> inside any preview to shift the avatar (offsetX / offsetY) ·
                <strong> Scroll</strong> over a preview to zoom (scale 0.5 – 1.8) ·
                Changes persist to localStorage in real time.
              </div>

              {/* Gender toggle — only for split avatars */}
              {!noSplitEnabled && (
                <div className="flex items-center gap-2">
                  <span className="text-xs font-semibold text-slate-600">Editing gender:</span>
                  {(['boy', 'girl'] as Gender[]).map((g) => (
                    <button
                      key={g}
                      type="button"
                      onClick={() => setPlayGender(g)}
                      className={`px-3 py-1.5 rounded-lg border text-sm font-semibold capitalize transition-colors ${
                        playGender === g
                          ? 'bg-indigo-600 text-white border-indigo-600'
                          : 'bg-white text-slate-600 border-slate-300 hover:border-slate-400'
                      }`}
                    >
                      {g === 'boy' ? '👦' : '👧'} {g}
                    </button>
                  ))}
                  <span className="text-xs text-slate-400 ml-1">
                    Switch gender to tune each half independently
                  </span>
                </div>
              )}

              {!playImageUrl && (
                <div className="bg-amber-50 border border-amber-200 rounded-lg px-3 py-2 text-xs text-amber-800">
                  ⚠️ No avatar image URL available. Open the tuner from a profile card or inventory to see previews.
                </div>
              )}

              {/* 4-column preview grid */}
              <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                {ALL_CONTEXTS.map((ctx) => (
                  <PlaygroundPreview
                    key={ctx}
                    ctx={ctx}
                    gender={noSplitEnabled ? 'boy' : playGender}
                    avatarId={safeAvatarId}
                    imageUrl={playImageUrl}
                    noSplit={noSplitEnabled}
                    tuning={resolvedTuningByContext[ctx]?.[noSplitEnabled ? 'boy' : playGender]}
                    onDelta={handlePlaygroundDelta}
                    onWheel={handlePlaygroundWheel}
                    onReset={handlePlaygroundReset}
                  />
                ))}
              </div>

              {/* Numeric summary table */}
              <div className="rounded-xl border overflow-hidden">
                <table className="w-full text-xs">
                  <thead>
                    <tr className="bg-slate-50 border-b">
                      <th className="text-left px-3 py-2 text-slate-600 font-semibold">Context</th>
                      <th className="text-right px-3 py-2 text-slate-600 font-semibold">offsetX%</th>
                      <th className="text-right px-3 py-2 text-slate-600 font-semibold">offsetY%</th>
                      <th className="text-right px-3 py-2 text-slate-600 font-semibold">scale</th>
                      <th className="px-3 py-2"></th>
                    </tr>
                  </thead>
                  <tbody>
                    {ALL_CONTEXTS.map((ctx, i) => {
                      const g = noSplitEnabled ? 'boy' : playGender;
                      const defaults = DEFAULT_OFFSETS[ctx](g);
                      const stored = (tuning as any)?.[ctx]?.[g];
                      const ox = stored?.offsetXPercent ?? defaults.ox;
                      const oy = stored?.offsetYPercent ?? defaults.oy;
                      const sc = stored?.scale ?? defaults.sc;
                      const isCustom = !!stored && (
                        stored.offsetXPercent !== undefined ||
                        stored.offsetYPercent !== undefined ||
                        stored.scale !== undefined
                      );
                      return (
                        <tr key={ctx} className={`border-b last:border-0 ${i % 2 === 0 ? 'bg-white' : 'bg-slate-50/50'}`}>
                          <td className="px-3 py-2 font-mono text-slate-700">
                            {ctx}
                            {isCustom && (
                              <span className="ml-1.5 text-[9px] font-bold px-1.5 py-0.5 rounded-full bg-indigo-100 text-indigo-600">
                                custom
                              </span>
                            )}
                          </td>
                          <td className="px-3 py-2 text-right font-mono text-slate-800 font-semibold">{ox.toFixed(1)}</td>
                          <td className="px-3 py-2 text-right font-mono text-slate-800 font-semibold">{oy.toFixed(1)}</td>
                          <td className="px-3 py-2 text-right font-mono text-slate-800 font-semibold">{sc.toFixed(2)}</td>
                          <td className="px-3 py-2">
                            <button
                              type="button"
                              onClick={() => handlePlaygroundReset(ctx, g)}
                              className="text-[10px] text-slate-400 hover:text-red-500 transition-colors"
                            >
                              ↺
                            </button>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>

              {/* Quick copy */}
              <div className="flex gap-2">
                <button
                  type="button"
                  className="px-3 py-1.5 rounded-lg border text-sm font-semibold bg-indigo-600 text-white border-indigo-600"
                  onClick={() => copyText(jsonText, 'JSON')}
                >
                  Copy Config JSON
                </button>
                <button
                  type="button"
                  className="px-3 py-1.5 rounded-lg border text-sm"
                  onClick={downloadJson}
                >
                  ⬇ Download JSON
                </button>
              </div>
            </div>
          )}

          {/* ── TUNING TAB ── */}
          {activeTab === 'tuning' && (
            <>
              <div className="text-sm font-mono text-slate-600 bg-slate-100 rounded-lg px-3 py-2">
                avatarId: <span className="text-slate-900 font-bold">{safeAvatarId || '(none)'}</span>
              </div>

              {!!safeAvatarId && !noSplitEnabled && (
                <button
                  type="button"
                  className="px-3 py-2 rounded-lg border text-sm font-semibold bg-white hover:border-slate-400"
                  onClick={applyCurrentAsGlobalDefaults}
                >
                  Apply This Avatar As Global Defaults (boy+girl · all contexts)
                </button>
              )}

              {noSplitNum ? (
                <label className="flex items-center gap-2 text-sm bg-amber-50 rounded-lg px-3 py-2 border border-amber-200">
                  <input type="checkbox" checked={noSplitEnabled} onChange={toggleNoSplit} className="w-4 h-4" />
                  <span className="font-semibold">Single-person avatar #{noSplitNum}</span>
                  <span className="text-amber-700 text-xs">(do not split into boy/girl halves)</span>
                </label>
              ) : null}

              {/* Face crop section */}
              <div className="rounded-xl border p-3">
                {noSplitEnabled ? (
                  <>
                    <div className="font-bold text-sm mb-1">Per-Avatar Face Crop</div>
                    <p className="text-xs text-slate-500 mb-1">
                      This is a single-person avatar — global gender crops don't apply.
                      Set the face box here; it is saved per-avatar in localStorage and used for
                      ProfileIcon and inventory squares.
                    </p>
                    <p className="text-xs text-amber-700 bg-amber-50 rounded px-2 py-1 mb-3 border border-amber-200">
                      ℹ️ Tap top-left then bottom-right of the face on the preview to set automatically.
                    </p>
                  </>
                ) : (
                  <>
                    <div className="font-bold text-sm mb-1">Global Face Crop Defaults</div>
                    <p className="text-xs text-slate-500 mb-3">
                      Normalized (0–1) within gendered image. Used for ProfileIcon head circle AND inventory face squares.
                      Tap top-left then bottom-right of face on the preview below.
                    </p>
                  </>
                )}

                {!noSplitEnabled && (
                  <div className="flex items-center gap-2 mb-3">
                    {(['boy', 'girl'] as Gender[]).map((g) => (
                      <button
                        key={g}
                        type="button"
                        onClick={() => { setTapGender(g); setTapStart(null); }}
                        className={`px-3 py-1.5 rounded-lg border text-sm font-semibold ${
                          tapGender === g ? 'bg-slate-900 text-white border-slate-900' : 'bg-white text-slate-700 border-slate-300'
                        }`}
                      >
                        Tap: {g}
                      </button>
                    ))}
                    <div className="text-xs text-slate-500">
                      {tapStart ? '→ Now click bottom-right of face' : '→ Click top-left of face, then bottom-right'}
                    </div>
                  </div>
                )}

                {noSplitEnabled && (
                  <div className="text-xs text-slate-500 mb-2">
                    {tapStart ? '→ Now click bottom-right of face' : '→ Click top-left of face, then bottom-right'}
                  </div>
                )}

                {previewUrl ? (
                  <div className="rounded-xl border bg-slate-50 p-2 mb-3">
                    <img
                      src={previewUrl}
                      alt=""
                      onClick={handlePreviewClick}
                      className="block mx-auto max-h-[280px] w-auto max-w-full cursor-crosshair select-none"
                      draggable={false}
                    />
                  </div>
                ) : (
                  <div className="text-xs text-slate-500 mb-3 bg-slate-100 rounded-lg p-3">
                    No preview image available for this avatar.
                  </div>
                )}

                {noSplitEnabled ? (
                  <div>
                    <div className="font-semibold text-sm mb-2">Face crop (this avatar only)</div>
                    <div className="grid grid-cols-4 gap-2">
                      {(['x', 'y', 'w', 'h'] as (keyof FaceCrop)[]).map((k) => (
                        <Field
                          key={k}
                          label={`face ${k}`}
                          value={getPerAvatarFaceCropValue(k, k === 'x' ? 0.3 : k === 'y' ? 0.05 : 0.35)}
                          onChange={(v) => setPerAvatarFaceCrop(k, v)}
                          min={k === 'w' || k === 'h' ? 0.05 : 0}
                          max={1}
                          step={0.01}
                        />
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="grid grid-cols-2 gap-4">
                    {(['boy', 'girl'] as Gender[]).map((g) => (
                      <div key={g}>
                        <div className="font-semibold text-sm mb-2 capitalize">{g}</div>
                        <div className="grid grid-cols-2 gap-2">
                          {(['x', 'y', 'w', 'h'] as (keyof FaceCrop)[]).map((k) => (
                            <Field
                              key={k}
                              label={`face ${k}`}
                              value={getGlobalFaceCropValue(g, k, k === 'x' ? 0.3 : k === 'y' ? 0.05 : 0.4)}
                              onChange={(v) => setGlobalFaceCrop(g, k, v)}
                              min={k === 'w' || k === 'h' ? 0.05 : 0}
                              max={1}
                              step={0.01}
                            />
                          ))}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              {/* Per-context body tuning — now includes profile_icon */}
              {ALL_CONTEXTS.map((ctx) => (
                <div key={ctx} className="rounded-xl border p-3">
                  <div className="flex items-center gap-2 mb-1">
                    <div className="font-bold text-sm">{ctx}</div>
                    {ctx === 'profile_icon' && (
                      <span className="text-[10px] px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-600 font-semibold border border-indigo-200">
                        new · drag/wheel in Playground
                      </span>
                    )}
                  </div>
                  {ctx === 'inventory' && (
                    <p className="text-xs text-amber-700 bg-amber-50 rounded px-2 py-1 mb-2 border border-amber-200">
                      ℹ️ Inventory offsets shift the face crop window within the square tile.
                    </p>
                  )}
                  {ctx === 'profile_icon' && (
                    <p className="text-xs text-indigo-700 bg-indigo-50 rounded px-2 py-1 mb-2 border border-indigo-200">
                      ℹ️ Icon transform is applied to the avatar image inside the circle.
                      Use Playground tab to drag/scroll tune visually.
                    </p>
                  )}
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    {(['boy', 'girl'] as Gender[]).map((g) => {
                      const defaults = DEFAULT_OFFSETS[ctx](g);
                      return (
                        <div key={g}>
                          <div className="text-xs font-semibold text-slate-600 mb-2 capitalize">{g}</div>
                          <div className="grid grid-cols-3 gap-2">
                            <Field
                              label="offsetX%"
                              value={getValue(ctx, g, 'offsetXPercent', defaults.ox)}
                              onChange={(v) => setTuningValue(ctx, g, 'offsetXPercent', v)}
                              min={-50} max={50} step={0.5}
                            />
                            <Field
                              label="offsetY%"
                              value={getValue(ctx, g, 'offsetYPercent', defaults.oy)}
                              onChange={(v) => setTuningValue(ctx, g, 'offsetYPercent', v)}
                              min={-50} max={50} step={0.5}
                            />
                            <Field
                              label="scale"
                              value={getValue(ctx, g, 'scale', defaults.sc)}
                              onChange={(v) => setTuningValue(ctx, g, 'scale', v)}
                              min={0.5} max={5} step={0.01}
                            />
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              ))}
            </>
          )}

          {/* ── AI PROMPT TAB ── */}
          {activeTab === 'prompt' && (
            <div>
              <div className="flex items-center justify-between mb-2">
                <div>
                  <div className="font-bold text-sm">AI Alignment Prompt</div>
                  <p className="text-xs text-slate-500 mt-0.5">
                    Copy this and paste into your AI coder context to describe how to position this avatar.
                  </p>
                </div>
                <div className="flex gap-2">
                  <button
                    type="button"
                    className="px-3 py-1.5 rounded-lg border text-sm font-semibold bg-indigo-600 text-white border-indigo-600"
                    onClick={() => copyText(promptText, 'Prompt')}
                  >
                    Copy Prompt
                  </button>
                  <button
                    type="button"
                    className="px-3 py-1.5 rounded-lg border text-sm"
                    onClick={() => selectTextarea('cc-tuner-prompt')}
                  >
                    Select All
                  </button>
                </div>
              </div>
              <textarea
                id="cc-tuner-prompt"
                readOnly
                value={promptText}
                className="w-full h-[400px] font-mono text-xs rounded-lg border bg-slate-50 p-3 resize-y"
              />
              <div className="mt-2 text-xs text-slate-500">
                <strong>Config JSON</strong> (paste into import tab or save to file):
              </div>
              <textarea
                id="cc-tuner-json"
                readOnly
                value={jsonText}
                className="mt-1 w-full h-[140px] font-mono text-xs rounded-lg border bg-slate-50 p-2"
              />
              <button
                type="button"
                className="mt-2 px-3 py-1.5 rounded-lg border text-sm"
                onClick={() => copyText(jsonText, 'JSON')}
              >
                Copy JSON
              </button>
            </div>
          )}

          {/* ── IMPORT TAB ── */}
          {activeTab === 'import' && (
            <div>
              <div className="font-bold text-sm mb-1">Import JSON Config</div>
              <p className="text-xs text-slate-500 mb-3">
                Paste a full config JSON here (e.g. exported via ⬇ JSON or Copy JSON). After applying,
                the modal will switch to the Tuning tab so you can verify the values immediately.
                All open inventory squares and profile cards update live — no page reload needed.
              </p>
              {importStatus && (
                <div className={`text-sm rounded-lg px-3 py-2 mb-3 border ${
                  importStatus.startsWith('✓')
                    ? 'text-green-700 bg-green-50 border-green-200'
                    : 'text-red-700 bg-red-50 border-red-200'
                }`}>
                  {importStatus}
                </div>
              )}
              <textarea
                value={importText}
                onChange={(e) => setImportText(e.target.value)}
                placeholder='Paste JSON config here e.g. {"version":1,"noSplitAvatarNumbers":[31,32],...}'
                className="w-full h-[300px] font-mono text-xs rounded-lg border bg-white p-3 resize-y"
              />
              <div className="mt-3 flex items-center gap-2">
                <button
                  type="button"
                  className="px-4 py-2 rounded-lg bg-indigo-600 text-white font-semibold text-sm"
                  onClick={applyImportedJson}
                >
                  Apply Import
                </button>
                <button
                  type="button"
                  className="px-4 py-2 rounded-lg border text-sm"
                  onClick={() => { setImportText(jsonText); setImportStatus('Loaded current config into box.'); }}
                >
                  Load Current
                </button>
              </div>
              <p className="mt-3 text-xs text-slate-500">
                Writes to localStorage key: <code>cc_avatar_tuner_config_v4</code>
              </p>
              <p className="mt-1 text-xs text-slate-500">
                Dev console helpers available:{' '}
                <code>copyAvatarAlignmentPrompt("avatar_20_name")</code>,{' '}
                <code>logAllAvatarAlignmentPrompts()</code>
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

// ─── Shared immutable merge helper ───────────────────────────────────────────

function mergeTuning(
  prev: AvatarTunerConfig,
  avatarId: string,
  ctx: AvatarTunerContext,
  gender: Gender,
  patch: AvatarTuning,
): AvatarTunerConfig {
  const next: AvatarTunerConfig = {
    ...prev,
    byAvatarId: { ...(prev.byAvatarId || {}) },
  };
  const byId = { ...(next.byAvatarId?.[avatarId] || {}) };
  const byCtx = { ...(byId[ctx] || {}) } as any;
  byCtx[gender] = { ...(byCtx[gender] || {}), ...patch };
  (byId as any)[ctx] = byCtx;
  next.byAvatarId![avatarId] = byId as any;
  return next;
}

// ─── Field Component ──────────────────────────────────────────────────────────

function Field({
  label,
  value,
  onChange,
  min,
  max,
  step,
}: {
  label: string;
  value: number;
  onChange: (v: number) => void;
  min: number;
  max: number;
  step: number;
}) {
  return (
    <label className="flex flex-col gap-1">
      <span className="text-xs text-slate-500">{label}</span>
      <input
        type="number"
        className="px-2 py-1 rounded-lg border text-sm bg-white"
        value={String(value)}
        min={min}
        max={max}
        step={step}
        onChange={(e) => onChange(Number(e.target.value))}
      />
    </label>
  );
}

===== FILE: src/lib/chemcity/gachaStaticCache.ts =====

import { collection, doc, getDoc, getDocs } from 'firebase/firestore';
import { db } from '../../firebase/config';
import type { Cosmetic, GachaBanner } from './types';
import { getServerCacheVersion } from '../cache';
import { getDownloadURL, ref } from 'firebase/storage';
import { storage } from '../../firebase/config';

const COSMETICS_CACHE_PREFIX = 'cc_cosmetics_v';

function safeGet<T>(key: string): T | null {
  try {
    const raw = localStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : null;
  } catch {
    return null;
  }
}

function safeSet(key: string, value: unknown): void {
  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch {
    // ignore
  }
}

function entriesCacheKey(bannerId: string, version: number) {
  return `cc_gacha_entries_${bannerId}_v${version}`;
}

function looksLikeHttpUrl(s: string): boolean {
  return /^https?:\/\//i.test(s);
}

function looksLikeStoragePath(s: string): boolean {
  // Typical Firestore value (should be) https://firebasestorage.googleapis.com/...
  // But if it is mistakenly stored as an object path, it looks like:
  //   chemcity/cosmetics/avatars_themed_gendered_v2/foo.png
  // In that case, resolve via getDownloadURL(ref(storage, path)).
  if (!s) return false;
  if (looksLikeHttpUrl(s)) return false;
  if (s.startsWith('data:')) return false;
  if (s.startsWith('gs://')) return true;
  return s.includes('/') && !s.includes(' ') && !s.includes('\n');
}

async function resolveMaybeStorageUrl(raw: unknown): Promise<string | undefined> {
  const s = String(raw ?? '').trim();
  if (!s) return undefined;
  if (looksLikeHttpUrl(s) || s.startsWith('data:')) return s;
  if (!looksLikeStoragePath(s)) return s;

  // Support both gs://bucket/path and plain objectPath.
  const objectPath = s.startsWith('gs://') ? s.replace(/^gs:\/\//, '').split('/').slice(1).join('/') : s;
  try {
    return await getDownloadURL(ref(storage, objectPath));
  } catch {
    // If resolution fails, fall back to original string so UI can still attempt to load it.
    return s;
  }
}

async function normalizeCosmetic(c: Cosmetic): Promise<Cosmetic> {
  const [imageUrl, imageUrlBoy, imageUrlGirl] = await Promise.all([
    resolveMaybeStorageUrl((c as any).imageUrl),
    resolveMaybeStorageUrl((c as any).imageUrlBoy),
    resolveMaybeStorageUrl((c as any).imageUrlGirl),
  ]);

  return {
    ...c,
    ...(imageUrl ? { imageUrl } : {}),
    ...(imageUrlBoy ? { imageUrlBoy } : {}),
    ...(imageUrlGirl ? { imageUrlGirl } : {}),
  };
}

export async function getCosmeticsMap(): Promise<Map<string, Cosmetic>> {
  const version = await getServerCacheVersion();
  const COSMETICS_CACHE_KEY = `${COSMETICS_CACHE_PREFIX}${version}`;

  const cached = safeGet<Cosmetic[]>(COSMETICS_CACHE_KEY);
  if (cached) {
    return new Map(cached.map((c) => [c.id, c]));
  }

  const snap = await getDocs(collection(db, 'cosmetics'));
  const rawCosmetics: Cosmetic[] = snap.docs
    .map((d) => ({ id: d.id, ...(d.data() as any) } as Cosmetic))
    .filter((c) => !c.deprecated);

  const cosmetics = await Promise.all(rawCosmetics.map((c) => normalizeCosmetic(c)));

  safeSet(COSMETICS_CACHE_KEY, cosmetics);
  return new Map(cosmetics.map((c) => [c.id, c]));
}

export function invalidateCosmeticsCache() {
  try {
    const keys: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      if (k && k.startsWith(COSMETICS_CACHE_PREFIX)) keys.push(k);
    }
    keys.forEach((k) => localStorage.removeItem(k));
  } catch {
    // ignore
  }
}

export async function getActiveBanners(): Promise<GachaBanner[]> {
  const snap = await getDocs(collection(db, 'gachaBanners'));
  const now = new Date();

  return snap.docs
    .map((d) => ({ id: d.id, ...(d.data() as any) } as GachaBanner))
    .filter((b) => {
      if (!b.active) return false;

      if (b.startAt) {
        const start = typeof (b.startAt as any)?.toDate === 'function'
          ? (b.startAt as any).toDate()
          : new Date(b.startAt as any);
        if (now < start) return false;
      }

      if (b.endAt) {
        const end = typeof (b.endAt as any)?.toDate === 'function'
          ? (b.endAt as any).toDate()
          : new Date(b.endAt as any);
        if (now > end) return false;
      }

      return true;
    });
}

export async function getBannerEntries(
  bannerId: string,
  cacheVersion: number,
): Promise<Array<{ cosmeticId: string } & Record<string, unknown>>> {
  const key = entriesCacheKey(bannerId, cacheVersion);
  const cached = safeGet<Array<{ cosmeticId: string } & Record<string, unknown>>>(key);
  if (cached) return cached;

  const snap = await getDocs(collection(db, 'gachaBanners', bannerId, 'entries'));
  const entries = snap.docs
    .map((d) => ({ cosmeticId: d.id, ...(d.data() as any) }))
    .filter((e) => e.enabled);

  safeSet(key, entries);
  return entries;
}

export async function getBanner(bannerId: string): Promise<GachaBanner | null> {
  const snap = await getDoc(doc(db, 'gachaBanners', bannerId));
  if (!snap.exists()) return null;
  return { id: snap.id, ...(snap.data() as any) } as GachaBanner;
}


===== FILE: src/lib/chemcity/cloudFunctions.ts =====

import { getFunctions, httpsCallable } from 'firebase/functions';
import type {
  EquipCardRequest,
  UnequipCardRequest,
  PurchaseCardRequest,
  GachaDrawRequest,
  GachaDrawResponse,
  PurchaseCosmeticRequest,
  PurchaseCosmeticResponse,
  EquipCosmeticsRequest,
  EquipCosmeticsResponse,
  BuyTicketsRequest,
  BuyTicketsResponse,
  UnlockPlaceRequest,
  UnlockSlotRequest,
  QuizRewardRequest,
  QuizRewardResult,
} from './types';

function getFns() {
  return getFunctions(undefined, 'asia-east1');
}

export async function callChemCityInitUser(): Promise<void> {
  const fn = httpsCallable(getFns(), 'chemcityInitUser');
  await fn({});
}

export interface MigrateSlotIdsResult {
  ok: boolean;
  alreadyMigrated?: boolean;
  version?: number;
  equippedKeysMigrated?: number;
  unlockedSlotsMigrated?: number;
}

export async function callChemCityMigrateSlotIds(): Promise<MigrateSlotIdsResult> {
  const fn = httpsCallable(getFns(), 'chemcityMigrateSlotIds');
  const result = await fn({});
  return result.data as MigrateSlotIdsResult;
}

export async function callChemCityEquipCard(slotId: string, itemId: string): Promise<void> {
  const fn = httpsCallable<EquipCardRequest, { ok?: boolean }>(getFns(), 'chemcityEquipCard');
  await fn({ slotId, itemId });
}

export async function callChemCityUnequipCard(slotId: string): Promise<void> {
  const fn = httpsCallable<UnequipCardRequest, { ok?: boolean }>(getFns(), 'chemcityUnequipCard');
  await fn({ slotId });
}

export async function callChemCityCollectPassiveIncome(): Promise<{ coinsAwarded: number } & Record<string, unknown>> {
  const fn = httpsCallable<{}, { coinsAwarded: number } & Record<string, unknown>>(
    getFns(),
    'chemcityCollectPassiveIncome',
  );
  const result = await fn({});
  return result.data;
}

export async function callChemCityDevGrantCoins(amount: number): Promise<void> {
  const fn = httpsCallable<{ amount: number }, { ok?: boolean }>(getFns(), 'chemcityDevGrantCoins');
  await fn({ amount });
}

export async function callChemCityGetDailyLoginBonus(): Promise<Record<string, unknown>> {
  const fn = httpsCallable(getFns(), 'chemcityGetDailyLoginBonus');
  const result = await fn({});
  return result.data as Record<string, unknown>;
}

export async function callChemCityPurchaseCard(itemId: string, currency: 'coins' | 'diamonds'): Promise<void> {
  const fn = httpsCallable<PurchaseCardRequest, { ok?: boolean }>(getFns(), 'chemcityPurchaseCard');
  await fn({ itemId, currency });
}

export async function callChemCityGachaDraw(req: GachaDrawRequest): Promise<GachaDrawResponse> {
  const fn = httpsCallable<GachaDrawRequest, GachaDrawResponse>(getFns(), 'chemcityGachaDraw');
  const result = await fn(req);
  return result.data;
}

export async function callChemCityPurchaseCosmetic(
  req: PurchaseCosmeticRequest,
): Promise<PurchaseCosmeticResponse> {
  const fn = httpsCallable<PurchaseCosmeticRequest, PurchaseCosmeticResponse>(
    getFns(),
    'chemcityPurchaseCosmetic',
  );
  const result = await fn(req);
  return result.data;
}

export async function callChemCityEquipCosmetics(
  req: EquipCosmeticsRequest,
): Promise<EquipCosmeticsResponse> {
  const fn = httpsCallable<EquipCosmeticsRequest, EquipCosmeticsResponse>(
    getFns(),
    'chemcityEquipCosmetics',
  );
  const result = await fn(req);
  return result.data;
}

export async function callChemCityBuyTickets(req: BuyTicketsRequest): Promise<BuyTicketsResponse> {
  const fn = httpsCallable<BuyTicketsRequest, BuyTicketsResponse>(getFns(), 'chemcityBuyTickets');
  const result = await fn(req);
  return result.data;
}

export async function callChemCityUnlockStoreSlot(): Promise<Record<string, unknown>> {
  const fn = httpsCallable(getFns(), 'chemcityUnlockStoreSlot');
  const result = await fn({});
  return result.data as Record<string, unknown>;
}

export async function callChemCityUnlockPlace(placeId: string): Promise<void> {
  const fn = httpsCallable<UnlockPlaceRequest, { ok?: boolean }>(getFns(), 'chemcityUnlockPlace');
  await fn({ placeId });
}

export async function callChemCityUnlockSlot(
  placeId: string,
  slotId: string,
  useExtraSlotBudget?: boolean,
): Promise<void> {
  const fn = httpsCallable<UnlockSlotRequest, { ok?: boolean }>(getFns(), 'chemcityUnlockSlot');
  await fn({ placeId, slotId, useExtraSlotBudget });
}

export async function callChemCityQuizReward(req: QuizRewardRequest): Promise<QuizRewardResult> {
  const fn = httpsCallable<QuizRewardRequest, QuizRewardResult>(getFns(), 'chemcityQuizReward');
  const result = await fn(req);
  return result.data;
}

export interface ClaimCollectionRewardResult {
  ok: boolean;
  coinsAwarded: number;
  diamondsAwarded: number;
}

export async function callChemCityClaimCollectionReward(
  collectionId: string,
): Promise<ClaimCollectionRewardResult> {
  const fn = httpsCallable<{ collectionId: string }, ClaimCollectionRewardResult>(
    getFns(),
    'chemcityClaimCollectionReward',
  );
  const result = await fn({ collectionId });
  return result.data;
}

// ─── Phase 4 aliases (used by the Phase 4 handoff code) ───────────────────────

export const callPurchaseCard = (req: PurchaseCardRequest) =>
  callChemCityPurchaseCard(req.itemId, req.currency).then(() => ({ success: true }));

export const callUnlockPlace = (req: UnlockPlaceRequest) =>
  callChemCityUnlockPlace(req.placeId).then(() => ({ success: true, coinsDeducted: 0 }));

export const callUnlockSlot = (req: UnlockSlotRequest) =>
  httpsCallable<UnlockSlotRequest, { ok?: boolean }>(getFns(), 'chemcityUnlockSlot')(req).then((r) => ({
    success: true,
    ...((r.data as any) ?? {}),
  }));

export const callUnlockStoreSlot = (_req: Record<string, never>) =>
  callChemCityUnlockStoreSlot().then((data: any) => ({
    success: true,
    newSlotCount: data?.newSlotCount ?? data?.storeSlotCount ?? 0,
    coinsDeducted: data?.coinsDeducted ?? data?.cost ?? 0,
  }));


===== FILE: src/lib/chemcity/types.ts =====

// ============================================================
// ChemCity — TypeScript Types
// Single source of truth for all data shapes.
// DO NOT change field names once users have data in Firestore.
// ============================================================

// ─── Item Documents ──────────────────────────────────────────

/**
 * Slim fields only — what is cached in localStorage.
 * ~170 bytes per card. Never includes educational content.
 */
export interface SlimItemDocument {
  id: string;                  // e.g. "item_nacl"
  baseId?: string;              // optional grouping key for item variants, e.g. "chem_h2o"
  name: string;                // e.g. "Salt"
  chemicalFormula: string;     // e.g. "NaCl" (Unicode subscripts)
  emoji: string;               // e.g. "🧂"
  imageUrl?: string;
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';
  rarityValue: 1 | 2 | 3 | 4;
  placeId: PlaceId;            // which city location this belongs to
  validSlots: string[];        // slot IDs within that place
  shopData: {
    coinCost?: number;         // undefined = not coin-purchasable
    diamondCost?: number;      // undefined = not diamond-purchasable
  };
  skillContribution: number;   // this card's bonus value added to its place's skill total
  collections: string[];       // collection group IDs only — not full objects
  deprecated: boolean;         // true = hidden from UI, never delete the row
}

/**
 * Full fields — fetched from Firestore on card detail tap only.
 * ~800 bytes per card. NEVER stored in localStorage.
 */
export interface FullItemDocument extends SlimItemDocument {
  displayName: string;         // e.g. "The Seasoning of Life"
  description: string;
  cardBackground?: string;     // CSS gradient or colour token
  imageUrl?: string;
  topicConnections: string[];  // topic IDs this card relates to
  educational: {
    funFact: string;
    everydayUses: string[];
    category: 'element' | 'compound' | 'mixture' | 'process';
  };
  albumMetadata: {
    flavorText: string;
    sortOrder: number;
    tags: string[];
  };
}

// ─── Places ──────────────────────────────────────────────────

export type PlaceId =
  | 'lab'
  | 'kitchen'
  | 'toilet'
  | 'garden'
  | 'gas_station'
  | 'lifestyle_boutique'
  | 'beach'
  | 'school';

export interface SlotDocument {
  slotId: string;
  unlockCost?: number;         // undefined = free by default
  unlockCurrency?: 'coins' | 'diamonds';
  budgetOnly?: boolean;        // if true, can only be unlocked via extraSlotsBudget
  equippedItemId?: string;     // null = empty
}

export interface PlaceDocument {
  id: PlaceId;
  displayName: string;
  emoji: string;
  unlockCost: number;          // coin cost to unlock the place itself
  slots: SlotDocument[];
  skill: {
    description: string;
    formula: string;           // human-readable formula string for display
  };
}

// ─── User Documents ──────────────────────────────────────────

/**
 * Main user document — users/{userId}
 * Kept lean: only IDs and numbers, never full objects.
 */
export interface UserChemCityData {
  userId: string;
  currencies: {
    coins: number;
    diamonds: number;
    tickets?: number;
  };
  storeSlotCount: number;
  ownedItems: string[];        // array of item IDs only
  ownedCosmetics?: string[];
  equipped: {
    [slotId: string]: string;  // slotId → itemId
  };
  equippedCosmetics?: {
    avatarId?: string;
    backgroundId?: string;
    iconId?: string;
  };
  gachaState?: {
    [bannerId: string]: {
      sinceEpic: number;
      sinceLegendary: number;
      lifetimePulls: number;
      updatedAt?: unknown;
    };
  };
  activeBonuses: ActiveBonuses;
  unlockedPlaces: PlaceId[];
  unlockedSlots: string[];     // slot IDs unlocked by the user
  extraSlotsBudget: number;    // remaining Gas Station bonus slots to distribute
  passiveIncome: {
    lastCollected: Date | null; // Firestore Timestamp — set by server
  };
  streaks: {
    currentStreak: number;
    longestStreak: number;
    lastLoginDate: string;     // ISO date string YYYY-MM-DD
    streakFreezeCount: number;
  };
  cacheVersion: number;        // last known version when user doc was written
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Progress sub-document — users/{userId}/progress/data
 * Separated to protect the 1MB Firestore doc limit.
 */
export interface UserProgressData {
  collections: {
    [collectionId: string]: {
      collected: number;
      total: number;
      completed: boolean;
      rewardClaimed: boolean;
    };
  };
  topicMastery: {
    [topicId: string]: {
      quizzesCompleted: number;
      correctAnswers: number;
      totalQuestions: number;
    };
  };
}

// ─── Bonus Engine ─────────────────────────────────────────────

/**
 * Computed bonuses — recalculated after every equip/unequip.
 * Persisted to user doc so they're available instantly on load.
 */
export interface ActiveBonuses {
  passiveBaseCoinsPerHour: number;      // Garden: total_bonus × 10
  passiveMultiplier: number;            // Lab:    1 + (total_bonus × 0.1)
  quizFlatDiamondBonus: number;         // Kitchen: total_bonus × random(1,3) — stored as max
  quizDiamondMultiplier: number;        // School: 1 + (total_bonus × 0.1)
  quizDoubleChancePercent: number;      // Beach:  min(total_bonus × 5, 100)
  dailyLoginDiamonds: number;           // Toilet: 5 + (total_bonus × 2)
  extraSlotsTotal: number;              // Gas Station: total_bonus
  shopDiscountPercent: number;          // Boutique: min(total_bonus × 2, 50) — capped at 50%
}

// ─── Cache ────────────────────────────────────────────────────

export interface CacheManifest {
  version: number;
  fetchedAt: number;           // Date.now() timestamp
  itemIds: string[];           // IDs of what's cached
}

// ─── Collections ─────────────────────────────────────────────

export interface CollectionDocument {
  id: string;
  displayName: string;
  description: string;
  itemIds: string[];
  rewardCoins?: number;
  rewardDiamonds?: number;
}

// ─── Topics ──────────────────────────────────────────────────

export interface TopicDocument {
  id: string;
  name: string;
  dseUnit: string;
  description?: string;
}

// ─── Cosmetics + Gacha ───────────────────────────────────────

export type CosmeticType = 'avatar' | 'background' | 'icon';

export type Rarity = 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';

export interface FaceCropMeta {
  x: number;
  y: number;
  w: number;
  h: number;
}

export interface CosmeticAvailability {
  channels: {
    gacha: boolean;
    shop: boolean;
  };
  eventKey?: string;
  startAt?: unknown;
  endAt?: unknown;
}

export interface CosmeticShopData {
  coinCost?: number;
  diamondCost?: number;
  ticketCost?: number;
}

export interface Cosmetic {
  id: string;
  type: CosmeticType;
  name: string;
  rarity: Rarity;
  imageUrl: string;
  imageUrlBoy?: string;
  imageUrlGirl?: string;
  availability: CosmeticAvailability;
  shopData?: CosmeticShopData;
  faceCrop?: FaceCropMeta;
  tags?: string[];
  deprecated?: boolean;
}

export type RarityRates = Record<Rarity, number>;

export type DuplicateRefunds = Record<Rarity, number>;

export interface PityRules {
  epicEvery: number;
  legendaryEvery: number;
}

export interface GachaBanner {
  id: string;
  name: string;
  description?: string;
  bannerImageUrl?: string;
  active: boolean;
  startAt?: unknown;
  endAt?: unknown;
  eventKey?: string;
  rarityRates: RarityRates;
  duplicateRefundCoinsByRarity: DuplicateRefunds;
  pityRules: PityRules;
  cacheVersion: number;
}

export interface GachaDrawRequest {
  bannerId: string;
  count: 1 | 10;
  payWith: 'tickets' | 'coins';
}

export interface GachaDrawResult {
  cosmeticId: string;
  rarity: Rarity;
  isNew: boolean;
  refundCoins: number;
  pitied: boolean;
}

export interface GachaDrawResponse {
  success: true;
  results: GachaDrawResult[];
  newBalance: {
    coins: number;
    diamonds: number;
    tickets: number;
  };
  newGachaState: {
    sinceEpic: number;
    sinceLegendary: number;
    lifetimePulls: number;
    updatedAt?: unknown;
  };
}

export interface PurchaseCosmeticRequest {
  cosmeticId: string;
  currency: 'coins' | 'diamonds' | 'tickets';
}

export interface PurchaseCosmeticResponse {
  success: true;
  cosmeticId: string;
  newBalance: {
    coins: number;
    diamonds: number;
    tickets: number;
  };
}

export interface EquipCosmeticsRequest {
  avatarId?: string;
  backgroundId?: string;
  iconId?: string;
}

export interface EquipCosmeticsResponse {
  success: true;
  equippedCosmetics: {
    avatarId?: string;
    backgroundId?: string;
    iconId?: string;
  };
}

export interface BuyTicketsRequest {
  count: number;
}

export interface BuyTicketsResponse {
  success: true;
  count: number;
  newBalance: {
    coins: number;
    diamonds: number;
    tickets: number;
  };
}

// ─── Cloud Function Request/Response Types ────────────────────

export interface EquipCardRequest {
  slotId: string;
  itemId: string;
}

export interface UnequipCardRequest {
  slotId: string;
}

export interface PurchaseCardRequest {
  itemId: string;
  currency: 'coins' | 'diamonds';
}

export interface UnlockPlaceRequest {
  placeId: string;
}

export interface UnlockSlotRequest {
  placeId: string;
  slotId: string;
  useExtraSlotBudget?: boolean;
}

export interface QuizRewardRequest {
  baseCoins: number;
  baseDiamonds: number;
  topicId?: string;
  correctAnswers?: number;
  totalQuestions?: number;
}

export interface QuizRewardResult {
  coinsAwarded: number;
  diamondsAwarded: number;
  didDouble?: boolean;
  breakdown?: {
    flatBonus: number;
    afterSchool: number;
    afterBeach: number;
  };
  ok?: boolean;
}


===== FILE: functions/chemcity/gacha.js =====

'use strict';

const admin = require('firebase-admin');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { randomInt } = require('crypto');

const RARITY_ORDER = ['common', 'uncommon', 'rare', 'epic', 'legendary'];

const DRAW_COST = { tickets: 1, coins: 500 };

const TICKET_EXCHANGE = { coinsPerTicket: 250 };

function nowIso() {
  return new Date().toISOString();
}

function invalid(msg) {
  throw new HttpsError('invalid-argument', msg);
}

function precondition(msg) {
  throw new HttpsError('failed-precondition', msg);
}

async function ensureChemCityGachaFields(db, uid) {
  const userRef = db.collection('users').doc(uid);
  const snap = await userRef.get();
  if (!snap.exists) {
    throw new HttpsError('not-found', 'User profile not found.');
  }
  const data = snap.data() || {};
  const chemcity = data.chemcity && typeof data.chemcity === 'object' ? data.chemcity : null;
  if (!chemcity) {
    // Let the main chemcity init flow create the chemcity root. We only merge gacha fields.
    // Existing codebase already provides chemcityInitUser/ensureChemCityInitialized.
    await userRef.set(
      {
        chemcity: {
          currencies: { tickets: 0 },
          ownedCosmetics: [],
          equippedCosmetics: {
            avatarId: 'avatar_1_plain',
            backgroundId: 'bg_1',
          },
          gachaState: {},
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        },
      },
      { merge: true },
    );
    return;
  }

  const currencies = chemcity.currencies && typeof chemcity.currencies === 'object' ? chemcity.currencies : {};

  const patch = {};

  if (typeof currencies.tickets !== 'number') {
    patch['chemcity.currencies.tickets'] = 0;
  }
  if (!Array.isArray(chemcity.ownedCosmetics)) {
    patch['chemcity.ownedCosmetics'] = [];
  }
  if (!chemcity.equippedCosmetics || typeof chemcity.equippedCosmetics !== 'object') {
    patch['chemcity.equippedCosmetics'] = {
      avatarId: 'avatar_1_plain',
      backgroundId: 'bg_1',
    };
  }
  if (!chemcity.gachaState || typeof chemcity.gachaState !== 'object') {
    patch['chemcity.gachaState'] = {};
  }

  if (Object.keys(patch).length > 0) {
    patch['chemcity.updatedAt'] = admin.firestore.FieldValue.serverTimestamp();
    await userRef.update(patch);
  }

  // Gift defaults: ensure user owns and has equipped the starter cosmetics.
  // (Only applies when fields already exist; safe for repeated calls.)
  try {
    const data2 = (await userRef.get()).data() || {};
    const cc2 = data2.chemcity && typeof data2.chemcity === 'object' ? data2.chemcity : {};
    const owned = Array.isArray(cc2.ownedCosmetics) ? cc2.ownedCosmetics : [];
    const equipped = cc2.equippedCosmetics && typeof cc2.equippedCosmetics === 'object' ? cc2.equippedCosmetics : {};

    const needOwned = !owned.includes('avatar_1_plain') || !owned.includes('bg_1');
    const needEquipped = !equipped.avatarId || !equipped.backgroundId;

    if (needOwned || needEquipped) {
      const nextOwned = owned.slice();
      if (!nextOwned.includes('avatar_1_plain')) nextOwned.push('avatar_1_plain');
      if (!nextOwned.includes('bg_1')) nextOwned.push('bg_1');
      await userRef.update({
        'chemcity.ownedCosmetics': nextOwned,
        'chemcity.equippedCosmetics': {
          avatarId: equipped.avatarId || 'avatar_1_plain',
          backgroundId: equipped.backgroundId || 'bg_1',
          ...(equipped.iconId ? { iconId: equipped.iconId } : {}),
        },
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });
    }
  } catch {
    // ignore
  }
}

function secureRandom() {
  return randomInt(0, 2 ** 32) / 2 ** 32;
}

async function loadActiveBanner(db, bannerId) {
  const snap = await db.collection('gachaBanners').doc(bannerId).get();
  if (!snap.exists) invalid(`Banner "${bannerId}" not found.`);
  const banner = { id: snap.id, ...(snap.data() || {}) };
  if (!banner.active) precondition('Banner is not active.');

  const now = new Date();
  if (banner.startAt) {
    const start = typeof banner.startAt?.toDate === 'function' ? banner.startAt.toDate() : new Date(banner.startAt);
    if (now < start) precondition('Banner has not started yet.');
  }
  if (banner.endAt) {
    const end = typeof banner.endAt?.toDate === 'function' ? banner.endAt.toDate() : new Date(banner.endAt);
    if (now > end) precondition('Banner has ended.');
  }
  return banner;
}

async function loadCompiledPool(db, bannerId) {
  const snap = await db
    .collection('gachaBanners')
    .doc(bannerId)
    .collection('entries')
    .where('enabled', '==', true)
    .get();

  if (snap.empty) invalid('Banner has no enabled entries.');

  const byRarity = {};
  snap.docs.forEach((d) => {
    const entry = { cosmeticId: d.id, ...(d.data() || {}) };
    if (!entry.rarity) return;
    if (!byRarity[entry.rarity]) byRarity[entry.rarity] = [];
    byRarity[entry.rarity].push({ cosmeticId: entry.cosmeticId, weight: Number(entry.weight || 1) });
  });

  const compiled = {};
  for (const [rarity, entries] of Object.entries(byRarity)) {
    let total = 0;
    const items = entries.map((e) => {
      total += e.weight;
      return { cosmeticId: e.cosmeticId, cumulativeWeight: total };
    });
    compiled[rarity] = { items, totalWeight: total };
  }
  return compiled;
}

function selectRarity(rarityRates, pityRules, pityState) {
  const sinceEpic = Number(pityState?.sinceEpic || 0);
  const sinceLegendary = Number(pityState?.sinceLegendary || 0);
  const epicEvery = Number(pityRules?.epicEvery || 20);
  const legendaryEvery = Number(pityRules?.legendaryEvery || 40);

  if (sinceLegendary >= legendaryEvery - 1) {
    return { rarity: 'legendary', pitied: true };
  }

  if (sinceEpic >= epicEvery - 1) {
    const roll = secureRandom();
    const epicRate = Number(rarityRates?.epic ?? 0.05);
    const legRate = Number(rarityRates?.legendary ?? 0.02);
    const total = epicRate + legRate;
    if (!(total > 0)) return { rarity: 'epic', pitied: true };
    return { rarity: roll < legRate / total ? 'legendary' : 'epic', pitied: true };
  }

  const roll = secureRandom();
  let cumulative = 0;
  for (const rarity of [...RARITY_ORDER].reverse()) {
    cumulative += Number(rarityRates?.[rarity] ?? 0);
    if (roll <= cumulative) return { rarity, pitied: false };
  }
  return { rarity: 'common', pitied: false };
}

function selectCosmetic(compiledPool, rarity) {
  const rarityIndex = RARITY_ORDER.indexOf(rarity);

  for (let i = rarityIndex; i >= 0; i--) {
    const r = RARITY_ORDER[i];
    const pool = compiledPool[r];
    if (!pool || pool.totalWeight <= 0) continue;

    const roll = secureRandom() * pool.totalWeight;
    const entry = pool.items.find((e) => e.cumulativeWeight >= roll);
    return entry ? entry.cosmeticId : pool.items[pool.items.length - 1].cosmeticId;
  }

  for (const r of [...RARITY_ORDER].reverse()) {
    const pool = compiledPool[r];
    if (pool && pool.items?.length > 0) return pool.items[0].cosmeticId;
  }

  throw new HttpsError('internal', 'No cosmetics available in pool.');
}

function updatePity(currentState, rarity) {
  let sinceEpic = Number(currentState?.sinceEpic || 0);
  let sinceLegendary = Number(currentState?.sinceLegendary || 0);
  let lifetimePulls = Number(currentState?.lifetimePulls || 0);

  lifetimePulls += 1;

  if (rarity === 'legendary') {
    sinceEpic = 0;
    sinceLegendary = 0;
  } else if (rarity === 'epic') {
    sinceEpic = 0;
    sinceLegendary += 1;
  } else {
    sinceEpic += 1;
    sinceLegendary += 1;
  }

  return { sinceEpic, sinceLegendary, lifetimePulls, updatedAt: nowIso() };
}

exports.chemcityGachaDraw = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const bannerId = request.data?.bannerId;
    const count = request.data?.count;
    const payWith = request.data?.payWith;

    if (typeof bannerId !== 'string' || !bannerId) invalid('bannerId is required.');
    if (count !== 1 && count !== 10) invalid('count must be 1 or 10.');
    if (payWith !== 'tickets' && payWith !== 'coins') invalid('payWith must be "tickets" or "coins".');

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const [banner, compiledPool] = await Promise.all([
      loadActiveBanner(db, bannerId),
      loadCompiledPool(db, bannerId),
    ]);

    const totalCost = payWith === 'tickets' ? DRAW_COST.tickets * count : DRAW_COST.coins * count;

    const userRef = db.collection('users').doc(uid);

    let resultsOut = [];
    let newBalanceOut = null;
    let newGachaStateOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);
      const tickets = Number(currencies.tickets || 0);

      const ownedCosmeticsArr = Array.isArray(chemcity.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
      const ownedCosmetics = new Set(ownedCosmeticsArr);

      const gachaState = chemcity.gachaState && typeof chemcity.gachaState === 'object' ? chemcity.gachaState : {};
      const pityBefore = gachaState[bannerId] && typeof gachaState[bannerId] === 'object'
        ? gachaState[bannerId]
        : { sinceEpic: 0, sinceLegendary: 0, lifetimePulls: 0, updatedAt: nowIso() };

      if (payWith === 'tickets' && tickets < totalCost) {
        precondition(`Not enough tickets. Need ${totalCost}, have ${tickets}.`);
      }
      if (payWith === 'coins' && coins < totalCost) {
        precondition(`Not enough coins. Need ${totalCost}, have ${coins}.`);
      }

      let pity = { ...pityBefore };
      let coinRefundTotal = 0;
      const results = [];
      const rollTrace = [];

      for (let i = 0; i < count; i++) {
        const { rarity, pitied } = selectRarity(banner.rarityRates, banner.pityRules, pity);
        const cosmeticId = selectCosmetic(compiledPool, rarity);

        const isNew = !ownedCosmetics.has(cosmeticId);
        let refundCoins = 0;

        if (isNew) {
          ownedCosmetics.add(cosmeticId);
        } else {
          refundCoins = Number(banner.duplicateRefundCoinsByRarity?.[rarity] || 0);
          if (!Number.isFinite(refundCoins) || refundCoins < 0) refundCoins = 0;
          coinRefundTotal += refundCoins;
        }

        pity = updatePity(pity, rarity);

        results.push({ cosmeticId, rarity, isNew, refundCoins, pitied });
        rollTrace.push({ i, cosmeticId, rarity, pitied, isNew, refundCoins });
      }

      // 10-pull guarantee: ensure at least one Rare+ result.
      if (count === 10) {
        const hasRarePlus = results.some((r) => ['rare', 'epic', 'legendary'].includes(r.rarity));
        if (!hasRarePlus) {
          // Upgrade the last pull to Rare (no pity flag), and reroll cosmetic from the Rare pool.
          const upgradedCosmeticId = selectCosmetic(compiledPool, 'rare');
          const old = results[9];
          const wasNew = !ownedCosmetics.has(upgradedCosmeticId);
          let refundCoins = 0;

          if (wasNew) {
            ownedCosmetics.add(upgradedCosmeticId);
          } else {
            refundCoins = Number(banner.duplicateRefundCoinsByRarity?.['rare'] || 0);
            if (!Number.isFinite(refundCoins) || refundCoins < 0) refundCoins = 0;
          }

          // If we replaced a duplicate that previously refunded coins, remove that previous refund.
          if (!old.isNew && Number.isFinite(Number(old.refundCoins))) {
            coinRefundTotal -= Number(old.refundCoins || 0);
          }
          coinRefundTotal += refundCoins;

          results[9] = {
            cosmeticId: upgradedCosmeticId,
            rarity: 'rare',
            isNew: wasNew,
            refundCoins,
            pitied: false,
          };
          rollTrace.push({
            i: 9,
            cosmeticId: upgradedCosmeticId,
            rarity: 'rare',
            pitied: false,
            isNew: wasNew,
            refundCoins,
            guaranteed: true,
          });
        }
      }

      const nextCoins = payWith === 'coins'
        ? coins - totalCost + coinRefundTotal
        : coins + coinRefundTotal;
      const nextTickets = payWith === 'tickets' ? tickets - totalCost : tickets;

      const updatedCurrencies = {
        coins: nextCoins,
        diamonds,
        tickets: nextTickets,
      };

      const updatedOwnedCosmetics = Array.from(ownedCosmetics);
      const updatedGachaState = { ...gachaState, [bannerId]: pity };

      tx.update(userRef, {
        'chemcity.currencies': updatedCurrencies,
        'chemcity.ownedCosmetics': updatedOwnedCosmetics,
        'chemcity.gachaState': updatedGachaState,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      const drawLogRef = userRef.collection('chemcity_gacha_draws').doc();
      tx.set(drawLogRef, {
        bannerId,
        count,
        payWith,
        totalCost,
        coinRefundTotal,
        results: rollTrace,
        currenciesBefore: { coins, diamonds, tickets },
        currenciesAfter: updatedCurrencies,
        pityBefore,
        pityAfter: pity,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      resultsOut = results;
      newBalanceOut = updatedCurrencies;
      newGachaStateOut = pity;
    });

    return {
      success: true,
      results: resultsOut,
      newBalance: newBalanceOut,
      newGachaState: newGachaStateOut,
    };
  },
);

exports.chemcityPurchaseCosmetic = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const cosmeticId = request.data?.cosmeticId;
    const currency = request.data?.currency;

    if (typeof cosmeticId !== 'string' || !cosmeticId) invalid('cosmeticId is required.');
    if (currency !== 'coins' && currency !== 'diamonds' && currency !== 'tickets') {
      invalid('currency must be coins, diamonds, or tickets.');
    }

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const cosmeticSnap = await db.collection('cosmetics').doc(cosmeticId).get();
    if (!cosmeticSnap.exists) invalid(`Cosmetic "${cosmeticId}" not found.`);
    const cosmetic = cosmeticSnap.data() || {};

    if (cosmetic.deprecated === true) precondition('Cosmetic is no longer available.');
    if (!(cosmetic.availability?.channels?.shop === true)) {
      precondition('This cosmetic is not available in the shop.');
    }

    const now = new Date();
    if (cosmetic.availability?.startAt) {
      const start = typeof cosmetic.availability.startAt?.toDate === 'function'
        ? cosmetic.availability.startAt.toDate()
        : new Date(cosmetic.availability.startAt);
      if (now < start) precondition('Cosmetic is not yet available.');
    }
    if (cosmetic.availability?.endAt) {
      const end = typeof cosmetic.availability.endAt?.toDate === 'function'
        ? cosmetic.availability.endAt.toDate()
        : new Date(cosmetic.availability.endAt);
      if (now > end) precondition('Cosmetic is no longer available.');
    }

    const shopData = cosmetic.shopData && typeof cosmetic.shopData === 'object' ? cosmetic.shopData : {};
    const costField = currency === 'coins'
      ? 'coinCost'
      : currency === 'diamonds'
        ? 'diamondCost'
        : 'ticketCost';

    const cost = Number(shopData[costField] || 0);
    if (!Number.isFinite(cost) || cost <= 0) {
      precondition(`This cosmetic cannot be purchased with ${currency}.`);
    }

    const userRef = db.collection('users').doc(uid);

    let newBalanceOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);
      const tickets = Number(currencies.tickets || 0);

      const owned = Array.isArray(chemcity.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
      if (owned.includes(cosmeticId)) precondition('You already own this cosmetic.');

      const balance = currency === 'coins' ? coins : currency === 'diamonds' ? diamonds : tickets;
      if (balance < cost) precondition(`Not enough ${currency}. Need ${cost}, have ${balance}.`);

      const updatedCurrencies = {
        coins: currency === 'coins' ? coins - cost : coins,
        diamonds: currency === 'diamonds' ? diamonds - cost : diamonds,
        tickets: currency === 'tickets' ? tickets - cost : tickets,
      };

      tx.update(userRef, {
        'chemcity.currencies': updatedCurrencies,
        'chemcity.ownedCosmetics': admin.firestore.FieldValue.arrayUnion(cosmeticId),
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      const purchaseRef = userRef.collection('chemcity_purchases').doc();
      tx.set(purchaseRef, {
        cosmeticId,
        currency,
        cost,
        currenciesBefore: { coins, diamonds, tickets },
        currenciesAfter: updatedCurrencies,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      newBalanceOut = updatedCurrencies;
    });

    return {
      success: true,
      cosmeticId,
      newBalance: newBalanceOut,
    };
  },
);

exports.chemcityEquipCosmetics = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const avatarId = request.data?.avatarId;
    const backgroundId = request.data?.backgroundId;
    const iconId = request.data?.iconId;

    if (!avatarId && !backgroundId && !iconId) {
      invalid('Provide at least one of avatarId, backgroundId, or iconId.');
    }

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const userRef = db.collection('users').doc(uid);

    let updatedEquippedOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const owned = Array.isArray(chemcity.ownedCosmetics) ? chemcity.ownedCosmetics.map(String) : [];
      const ownedSet = new Set(owned);

      if (typeof avatarId === 'string' && avatarId && !ownedSet.has(avatarId)) {
        precondition(`You do not own avatar "${avatarId}".`);
      }
      if (typeof backgroundId === 'string' && backgroundId && !ownedSet.has(backgroundId)) {
        precondition(`You do not own background "${backgroundId}".`);
      }
      if (typeof iconId === 'string' && iconId && !ownedSet.has(iconId)) {
        precondition(`You do not own icon "${iconId}".`);
      }

      const currentEquipped = chemcity.equippedCosmetics && typeof chemcity.equippedCosmetics === 'object'
        ? chemcity.equippedCosmetics
        : {};

      const updatedEquipped = {
        ...currentEquipped,
        ...(avatarId !== undefined ? { avatarId } : null),
        ...(backgroundId !== undefined ? { backgroundId } : null),
        ...(iconId !== undefined ? { iconId } : null),
      };

      tx.update(userRef, {
        'chemcity.equippedCosmetics': updatedEquipped,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      updatedEquippedOut = updatedEquipped;
    });

    return {
      success: true,
      equippedCosmetics: updatedEquippedOut,
    };
  },
);

exports.chemcityBuyTickets = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) throw new HttpsError('unauthenticated', 'User must be signed in.');

    const count = request.data?.count;
    if (!Number.isFinite(Number(count)) || Number(count) <= 0) invalid('count must be a positive number.');
    const ticketCount = Math.floor(Number(count));
    if (ticketCount <= 0) invalid('count must be a positive integer.');

    const db = admin.firestore();
    await ensureChemCityGachaFields(db, uid);

    const userRef = db.collection('users').doc(uid);

    let newBalanceOut = null;

    await db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) throw new HttpsError('not-found', 'User not found.');

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};
      const currencies = chemcity.currencies || {};

      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);
      const tickets = Number(currencies.tickets || 0);

      const totalCost = TICKET_EXCHANGE.coinsPerTicket * ticketCount;
      if (coins < totalCost) precondition(`Not enough coins. Need ${totalCost}, have ${coins}.`);

      const updatedCurrencies = {
        coins: coins - totalCost,
        diamonds,
        tickets: tickets + ticketCount,
      };

      tx.update(userRef, {
        'chemcity.currencies': updatedCurrencies,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      const purchaseRef = userRef.collection('chemcity_purchases').doc();
      tx.set(purchaseRef, {
        type: 'tickets',
        ticketCount,
        currency: 'coins',
        cost: totalCost,
        currenciesBefore: { coins, diamonds, tickets },
        currenciesAfter: updatedCurrencies,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      newBalanceOut = updatedCurrencies;
    });

    return {
      success: true,
      count: ticketCount,
      newBalance: newBalanceOut,
    };
  },
);


===== FILE: functions/index.js =====

const admin = require('firebase-admin');
const { onSchedule } = require('firebase-functions/v2/scheduler');
const { onDocumentCreated, onDocumentUpdated, onDocumentDeleted } = require('firebase-functions/v2/firestore');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const algoliasearch = require('algoliasearch');

admin.initializeApp();

Object.assign(exports, require('./chemcity/gacha'));

function getChemCityDefaults(userId) {
  const now = admin.firestore.FieldValue.serverTimestamp();
  return {
    userId,
    currencies: {
      coins: 500,
      diamonds: 20,
    },
    storeSlotCount: 3,
    ownedItems: [],
    ownedCosmetics: ['avatar_1_plain', 'bg_1'],
    equipped: {},
    equippedCosmetics: {
      avatarId: 'avatar_1_plain',
      backgroundId: 'bg_1',
    },
    activeBonuses: {
      passiveBaseCoinsPerHour: 0,
      passiveMultiplier: 1,
      quizFlatDiamondBonus: 0,
      quizDiamondMultiplier: 1,
      quizDoubleChancePercent: 0,
      dailyLoginDiamonds: 5,
      extraSlotsTotal: 0,
      shopDiscountPercent: 0,
    },
    unlockedPlaces: ['lab'],
    unlockedSlots: [],
    extraSlotsBudget: 0,
    passiveIncome: {
      lastCollected: null,
    },
    streaks: {
      currentStreak: 0,
      longestStreak: 0,
      lastLoginDate: '',
      streakFreezeCount: 0,
    },
    cacheVersion: 0,
    createdAt: now,
    updatedAt: now,
  };
}

async function ensureChemCityInitialized(db, userId) {
  const userRef = db.collection('users').doc(userId);
  const snap = await userRef.get();
  if (!snap.exists) {
    throw new HttpsError('not-found', 'User profile not found.');
  }
  const userData = snap.data() || {};
  if (userData.chemcity && typeof userData.chemcity === 'object') {
    // Backfill starter cosmetics if missing (non-destructive).
    const cc = userData.chemcity;
    const patch = {};

    const owned = Array.isArray(cc.ownedCosmetics) ? cc.ownedCosmetics : null;
    if (!owned) {
      patch['chemcity.ownedCosmetics'] = ['avatar_1_plain', 'bg_1'];
    } else {
      const nextOwned = owned.slice();
      if (!nextOwned.includes('avatar_1_plain')) nextOwned.push('avatar_1_plain');
      if (!nextOwned.includes('bg_1')) nextOwned.push('bg_1');
      if (nextOwned.length !== owned.length) patch['chemcity.ownedCosmetics'] = nextOwned;
    }

    const equipped = cc.equippedCosmetics && typeof cc.equippedCosmetics === 'object' ? cc.equippedCosmetics : null;
    if (!equipped) {
      patch['chemcity.equippedCosmetics'] = { avatarId: 'avatar_1_plain', backgroundId: 'bg_1' };
    } else {
      if (!equipped.avatarId || !equipped.backgroundId) {
        patch['chemcity.equippedCosmetics'] = {
          avatarId: equipped.avatarId || 'avatar_1_plain',
          backgroundId: equipped.backgroundId || 'bg_1',
          ...(equipped.iconId ? { iconId: equipped.iconId } : {}),
        };
      }
    }

    if (Object.keys(patch).length > 0) {
      patch['chemcity.updatedAt'] = admin.firestore.FieldValue.serverTimestamp();
      await userRef.update(patch);
    }
    return;
  }

  const chemcity = getChemCityDefaults(userId);
  const progressRef = userRef.collection('chemcity_progress').doc('data');
  const batch = db.batch();
  batch.set(userRef, { chemcity }, { merge: true });
  batch.set(progressRef, { collections: {}, topicMastery: {} }, { merge: true });
  await batch.commit();
}

function calcGardenCoinsPerHour(totalBonus) {
  return totalBonus * 10;
}

function calcLabMultiplier(totalBonus) {
  return 1 + totalBonus * 0.1;
}

function calcKitchenMaxDiamonds(totalBonus) {
  return totalBonus * 3;
}

function calcSchoolMultiplier(totalBonus) {
  return 1 + totalBonus * 0.1;
}

function calcBeachDoubleChance(totalBonus) {
  return Math.min(totalBonus * 5, 100);
}

function calcToiletLoginDiamonds(totalBonus) {
  return 5 + totalBonus * 2;
}

function calcGasStationExtraSlots(totalBonus) {
  return totalBonus;
}

function calcBoutiqueDiscount(totalBonus) {
  return Math.min(totalBonus * 2, 50);
}

function getTodayUtcDateKey() {
  const d = new Date();
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth() + 1).padStart(2, '0');
  const day = String(d.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

function rollKitchenBonusFromMax(maxBonus) {
  const max = Number(maxBonus || 0);
  if (!Number.isFinite(max) || max <= 0) return 0;
  const totalBonus = Math.floor(max / 3);
  if (totalBonus <= 0) return 0;
  const min = totalBonus;
  const mx = totalBonus * 3;
  return Math.floor(Math.random() * (mx - min + 1)) + min;
}

function rollBeachDoubleFromPercent(percent) {
  const p = Number(percent || 0);
  if (!Number.isFinite(p) || p <= 0) return false;
  return Math.random() * 100 < Math.min(p, 100);
}

function getDiscountedCoinCost(baseCost, shopDiscountPercent) {
  const cost = Number(baseCost);
  if (!Number.isFinite(cost) || cost <= 0) return 0;
  const disc = Number(shopDiscountPercent || 0);
  if (!Number.isFinite(disc) || disc <= 0) return cost;
  const factor = 1 - Math.min(disc, 50) / 100;
  return Math.max(1, Math.floor(cost * factor));
}

const STORE_SLOT_UNLOCK_COSTS = {
  4: 1000,
  5: 2500,
  6: 5000,
};

async function computeChemCityActiveBonuses(db, equipped) {
  const itemIds = Object.values(equipped || {}).filter((x) => typeof x === 'string' && x.length > 0);
  const uniqueIds = Array.from(new Set(itemIds));

  const totals = {};
  if (uniqueIds.length > 0) {
    const refs = uniqueIds.map((id) => db.collection('items').doc(id));
    const snaps = await db.getAll(...refs);

    const itemMap = new Map();
    snaps.forEach((s) => {
      if (s.exists) itemMap.set(s.id, s.data() || {});
    });

    for (const id of itemIds) {
      const item = itemMap.get(id);
      if (!item || item.deprecated) continue;
      const placeId = String(item.placeId || '');
      const contrib = Number(item.skillContribution || 0);
      if (!placeId || !Number.isFinite(contrib)) continue;
      totals[placeId] = (totals[placeId] || 0) + contrib;
    }
  }

  const gardenBonus = totals.garden || 0;
  const labBonus = totals.lab || 0;
  const kitchenBonus = totals.kitchen || 0;
  const schoolBonus = totals.school || 0;
  const beachBonus = totals.beach || 0;
  const toiletBonus = totals.toilet || 0;
  const gasStationBonus = totals.gas_station || 0;
  const boutiqueBonus = totals.lifestyle_boutique || 0;

  const gardenBase = calcGardenCoinsPerHour(gardenBonus);
  const labMult = calcLabMultiplier(labBonus);

  return {
    passiveBaseCoinsPerHour: Math.round(gardenBase * labMult),
    passiveMultiplier: labMult,
    quizFlatDiamondBonus: calcKitchenMaxDiamonds(kitchenBonus),
    quizDiamondMultiplier: calcSchoolMultiplier(schoolBonus),
    quizDoubleChancePercent: calcBeachDoubleChance(beachBonus),
    dailyLoginDiamonds: calcToiletLoginDiamonds(toiletBonus),
    extraSlotsTotal: calcGasStationExtraSlots(gasStationBonus),
    shopDiscountPercent: calcBoutiqueDiscount(boutiqueBonus),
  };
}

function encodeKey(value) {
  const s = value == null ? '' : String(value);
  return encodeURIComponent(s);
}

function safeString(value) {
  return value == null ? '' : String(value);
}

function decodeKey(value) {
  const s = value == null ? '' : String(value);
  try {
    return decodeURIComponent(s);
  } catch {
    return s;
  }
}

function normalizeBucket(value) {
  const v = value == null ? '' : String(value);
  if (v === 'not_in_srs' || v === 'new' || v === 'progressing' || v === 'near' || v === 'archived') return v;
  return 'not_in_srs';
}

function getTopicFromMistake(m) {
  if (!m || typeof m !== 'object') return '';
  return safeString(m.Topic || m.topic || '');
}

function getBucketFromMistake(m) {
  if (!m || typeof m !== 'object') return 'not_in_srs';
  return normalizeBucket(m.srsBucket || 'not_in_srs');
}

function getIsActiveFromMistake(m) {
  if (!m || typeof m !== 'object') return false;
  return m.srsIsActive === true;
}

async function applyMistakeTopicStatsDelta(db, userId, delta, topic, bucket, isActive) {
  const uid = safeString(userId);
  const d = Number(delta);
  if (!uid || !Number.isFinite(d) || d === 0) return;

  const topicEnc = encodeKey(topic || '');
  if (!topicEnc) return;

  const b = normalizeBucket(bucket);
  const active = isActive === true;

  const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(statsRef);
    const prev = snap.exists ? (snap.data() || {}) : {};
    const prevTopics = prev.topics && typeof prev.topics === 'object' ? prev.topics : {};
    const prevEntry = prevTopics[topicEnc] && typeof prevTopics[topicEnc] === 'object' ? prevTopics[topicEnc] : {};

    const nextTopics = { ...prevTopics };
    const nextEntry = { ...prevEntry };

    const prevTotal = Number(nextEntry.total || 0);
    const nextTotal = Math.max(0, prevTotal + d);
    nextEntry.total = nextTotal;

    const bucketKey = `b_${b}`;
    const prevBucket = Number(nextEntry[bucketKey] || 0);
    const nextBucket = Math.max(0, prevBucket + d);
    if (nextBucket === 0) delete nextEntry[bucketKey];
    else nextEntry[bucketKey] = nextBucket;

    if (active) {
      const prevActive = Number(nextEntry.active || 0);
      const nextActive = Math.max(0, prevActive + d);
      nextEntry.active = nextActive;
    }

    // Prune empty
    if (nextEntry.total === 0) {
      delete nextTopics[topicEnc];
    } else {
      nextEntry.updatedAt = admin.firestore.FieldValue.serverTimestamp();
      nextTopics[topicEnc] = nextEntry;
    }

    tx.set(statsRef, {
      topics: nextTopics,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });
  });
}

async function applySrsAttemptDelta(db, userId, attemptedAtIso, deltaCorrect, statusBefore) {
  const uid = safeString(userId);
  const iso = safeString(attemptedAtIso);
  if (!uid || !iso) return;

  const dateKey = iso.slice(0, 10);
  if (!dateKey) return;

  const summaryRef = db.collection('users').doc(uid).collection('srs_daily_summaries').doc(dateKey);
  const dCorrect = Number.isFinite(deltaCorrect) ? deltaCorrect : 0;

  const normalizeStatus = (s) => {
    const v = safeString(s);
    if (v === 'new') return 'new';
    if (v === 'learning') return 'learning';
    if (v === 'review') return 'review';
    if (v === 'graduated') return 'graduated';
    return '';
  };

  const bucket = normalizeStatus(statusBefore);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(summaryRef);
    const prev = snap.exists ? (snap.data() || {}) : {};
    const next = { ...prev };

    next.date = dateKey;
    next.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    if (dCorrect !== 0) {
      const old = Number(prev.clearedCorrect || 0);
      next.clearedCorrect = Math.max(0, old + dCorrect);
    }

    if (bucket) {
      const field = bucket === 'new' ? 'statusNew'
        : bucket === 'learning' ? 'statusLearning'
        : bucket === 'review' ? 'statusReview'
        : 'statusGraduated';
      const old = Number(prev[field] || 0);
      next[field] = Math.max(0, old + 1);
    }

    tx.set(summaryRef, next, { merge: true });
  });
}

async function applyMistakeDocDelta(db, userId, before, after) {
  const beforeExists = before && typeof before === 'object' && Object.keys(before).length > 0;
  const afterExists = after && typeof after === 'object' && Object.keys(after).length > 0;

  if (!beforeExists && !afterExists) return;

  // Create
  if (!beforeExists && afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      1,
      getTopicFromMistake(after),
      getBucketFromMistake(after),
      getIsActiveFromMistake(after)
    );
    return;
  }

  // Delete
  if (beforeExists && !afterExists) {
    await applyMistakeTopicStatsDelta(
      db,
      userId,
      -1,
      getTopicFromMistake(before),
      getBucketFromMistake(before),
      getIsActiveFromMistake(before)
    );
    return;
  }

  const beforeTopic = getTopicFromMistake(before);
  const afterTopic = getTopicFromMistake(after);
  const beforeBucket = getBucketFromMistake(before);
  const afterBucket = getBucketFromMistake(after);
  const beforeActive = getIsActiveFromMistake(before);
  const afterActive = getIsActiveFromMistake(after);

  const changed =
    beforeTopic !== afterTopic ||
    beforeBucket !== afterBucket ||
    beforeActive !== afterActive;

  if (!changed) return;

  // Remove old
  await applyMistakeTopicStatsDelta(db, userId, -1, beforeTopic, beforeBucket, beforeActive);
  // Add new
  await applyMistakeTopicStatsDelta(db, userId, 1, afterTopic, afterBucket, afterActive);
}

// Maintain mistake topic stats for global sidebar facets
exports.updateMistakeTopicStatsOnCreate = onDocumentCreated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const after = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, null, after);
  }
);

exports.chemcityUnlockStoreSlot = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const current = Number(chemcity.storeSlotCount || 3);
      if (!Number.isFinite(current) || current < 3) {
        throw new HttpsError('failed-precondition', 'Invalid storeSlotCount.');
      }
      if (current >= 6) {
        throw new HttpsError('failed-precondition', 'All store slots already unlocked.');
      }

      const next = current + 1;
      const cost = STORE_SLOT_UNLOCK_COSTS[next];
      if (!Number.isFinite(cost) || cost <= 0) {
        throw new HttpsError('failed-precondition', 'Invalid store slot unlock cost.');
      }

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      if (coins < cost) {
        throw new HttpsError('failed-precondition', 'Insufficient coins.');
      }

      tx.update(userRef, {
        'chemcity.currencies.coins': coins - cost,
        'chemcity.storeSlotCount': next,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, newSlotCount: next, coinsDeducted: cost };
    });
  }
);

exports.chemcityDevGrantCoins = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const amount = request.data?.amount;
    if (typeof amount !== 'number' || !Number.isFinite(amount) || amount === 0) {
      throw new HttpsError('invalid-argument', 'amount must be a non-zero number.');
    }

    const delta = Math.floor(amount);
    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    await db.runTransaction(async (tx) => {
      const snap = await tx.get(userRef);
      if (!snap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      tx.update(userRef, {
        'chemcity.currencies.coins': admin.firestore.FieldValue.increment(delta),
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });
    });

    return { ok: true, amount: delta };
  }
);

exports.chemcityClaimCollectionReward = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const collectionId = request.data?.collectionId;
    if (typeof collectionId !== 'string' || !collectionId) {
      throw new HttpsError('invalid-argument', 'collectionId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const progressRef = userRef.collection('chemcity_progress').doc('data');
    const colRef = db.collection('collections').doc(collectionId);

    return db.runTransaction(async (tx) => {
      const [userSnap, progressSnap, colSnap] = await Promise.all([
        tx.get(userRef),
        tx.get(progressRef),
        tx.get(colRef),
      ]);

      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      if (!colSnap.exists) {
        throw new HttpsError('not-found', `Collection '${collectionId}' not found.`);
      }

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const ownedItems = Array.isArray(chemcity.ownedItems) ? chemcity.ownedItems : [];
      const ownedSet = new Set(ownedItems.map(String));

      const colData = colSnap.data() || {};
      const itemIds = Array.isArray(colData.itemIds) ? colData.itemIds.map(String) : [];
      const rewardCoins = Number(colData.rewardCoins || 0);
      const rewardDiamonds = Number(colData.rewardDiamonds || 0);

      if (itemIds.length === 0) {
        throw new HttpsError('failed-precondition', 'Collection has no items.');
      }

      const allOwned = itemIds.every((id) => ownedSet.has(id));
      if (!allOwned) {
        throw new HttpsError('failed-precondition', 'You have not collected all items in this collection.');
      }

      const progress = progressSnap.exists ? (progressSnap.data() || {}) : {};
      const collectionsProgress = progress.collections && typeof progress.collections === 'object'
        ? progress.collections
        : {};
      const prevColProgress = collectionsProgress[collectionId] && typeof collectionsProgress[collectionId] === 'object'
        ? collectionsProgress[collectionId]
        : {};

      if (prevColProgress.rewardClaimed === true) {
        throw new HttpsError('already-exists', 'Reward for this collection has already been claimed.');
      }

      const update = {
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      };
      if (rewardCoins > 0) {
        update['chemcity.currencies.coins'] = admin.firestore.FieldValue.increment(rewardCoins);
      }
      if (rewardDiamonds > 0) {
        update['chemcity.currencies.diamonds'] = admin.firestore.FieldValue.increment(rewardDiamonds);
      }

      tx.update(userRef, update);

      tx.set(
        progressRef,
        {
          collections: {
            [collectionId]: {
              collected: itemIds.length,
              total: itemIds.length,
              completed: true,
              rewardClaimed: true,
              claimedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          },
        },
        { merge: true },
      );

      return {
        ok: true,
        coinsAwarded: Math.max(0, Math.floor(rewardCoins)),
        diamondsAwarded: Math.max(0, Math.floor(rewardDiamonds)),
      };
    });
  },
);

exports.chemcityPurchaseCard = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const itemId = request.data?.itemId;
    const currency = request.data?.currency;
    if (typeof itemId !== 'string' || !itemId) {
      throw new HttpsError('invalid-argument', 'itemId must be a non-empty string.');
    }
    if (currency !== 'coins' && currency !== 'diamonds') {
      throw new HttpsError('invalid-argument', 'currency must be "coins" or "diamonds".');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const itemRef = db.collection('items').doc(itemId);

    const itemSnap = await itemRef.get();
    if (!itemSnap.exists) {
      throw new HttpsError('not-found', 'Item not found.');
    }
    const item = itemSnap.data() || {};
    if (item.deprecated === true) {
      throw new HttpsError('failed-precondition', 'Item is deprecated.');
    }

    const shopData = item.shopData && typeof item.shopData === 'object' ? item.shopData : {};
    const baseCoinCost = shopData.coinCost;
    const baseDiamondCost = shopData.diamondCost;

    if (currency === 'coins' && !(Number.isFinite(Number(baseCoinCost)) && Number(baseCoinCost) > 0)) {
      throw new HttpsError('failed-precondition', 'Item is not purchasable with coins.');
    }
    if (currency === 'diamonds' && !(Number.isFinite(Number(baseDiamondCost)) && Number(baseDiamondCost) > 0)) {
      throw new HttpsError('failed-precondition', 'Item is not purchasable with diamonds.');
    }

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const owned = Array.isArray(chemcity.ownedItems) ? chemcity.ownedItems : [];
      if (owned.includes(itemId)) {
        throw new HttpsError('already-exists', 'Item already owned.');
      }

      const bonuses = chemcity.activeBonuses || {};
      const discountPercent = Number(bonuses.shopDiscountPercent || 0);

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);

      const effectiveCoinCost = currency === 'coins'
        ? getDiscountedCoinCost(baseCoinCost, discountPercent)
        : 0;
      const effectiveDiamondCost = currency === 'diamonds'
        ? Number(baseDiamondCost)
        : 0;

      if (currency === 'coins') {
        if (!Number.isFinite(effectiveCoinCost) || effectiveCoinCost <= 0) {
          throw new HttpsError('failed-precondition', 'Invalid coin cost.');
        }
        if (coins < effectiveCoinCost) {
          throw new HttpsError('failed-precondition', 'Insufficient coins.');
        }
      } else {
        if (!Number.isFinite(effectiveDiamondCost) || effectiveDiamondCost <= 0) {
          throw new HttpsError('failed-precondition', 'Invalid diamond cost.');
        }
        if (diamonds < effectiveDiamondCost) {
          throw new HttpsError('failed-precondition', 'Insufficient diamonds.');
        }
      }

      const update = {
        'chemcity.ownedItems': [...owned, itemId],
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      };

      if (currency === 'coins') {
        update['chemcity.currencies.coins'] = coins - effectiveCoinCost;
      } else {
        update['chemcity.currencies.diamonds'] = diamonds - effectiveDiamondCost;
      }

      tx.update(userRef, update);

      return {
        ok: true,
        itemId,
        currency,
        coinCost: currency === 'coins' ? effectiveCoinCost : null,
        diamondCost: currency === 'diamonds' ? effectiveDiamondCost : null,
      };
    });
  }
);

exports.chemcityUnlockPlace = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const placeId = request.data?.placeId;
    if (typeof placeId !== 'string' || !placeId) {
      throw new HttpsError('invalid-argument', 'placeId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const placeRef = db.collection('places').doc(placeId);

    const placeSnap = await placeRef.get();
    if (!placeSnap.exists) {
      throw new HttpsError('not-found', 'Place not found.');
    }
    const place = placeSnap.data() || {};
    const unlockCost = Number(place.unlockCost || 0);
    if (!Number.isFinite(unlockCost) || unlockCost < 0) {
      throw new HttpsError('failed-precondition', 'Invalid place unlock cost.');
    }

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const unlockedPlaces = Array.isArray(chemcity.unlockedPlaces) ? chemcity.unlockedPlaces : [];
      if (unlockedPlaces.includes(placeId)) {
        return { ok: true, alreadyUnlocked: true, placeId };
      }

      if (unlockCost === 0) {
        tx.update(userRef, {
          'chemcity.unlockedPlaces': [...unlockedPlaces, placeId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, placeId, cost: 0 };
      }

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      if (coins < unlockCost) {
        throw new HttpsError('failed-precondition', 'Insufficient coins.');
      }

      tx.update(userRef, {
        'chemcity.currencies.coins': coins - unlockCost,
        'chemcity.unlockedPlaces': [...unlockedPlaces, placeId],
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, placeId, cost: unlockCost };
    });
  }
);

exports.chemcityUnlockSlot = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const placeId = request.data?.placeId;
    const slotId = request.data?.slotId;
    const useExtraSlotBudget = request.data?.useExtraSlotBudget === true;

    if (typeof placeId !== 'string' || !placeId) {
      throw new HttpsError('invalid-argument', 'placeId must be a non-empty string.');
    }
    if (typeof slotId !== 'string' || !slotId) {
      throw new HttpsError('invalid-argument', 'slotId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const placeRef = db.collection('places').doc(placeId);

    const placeSnap = await placeRef.get();
    if (!placeSnap.exists) {
      throw new HttpsError('not-found', 'Place not found.');
    }
    const place = placeSnap.data() || {};
    const slots = Array.isArray(place.slots) ? place.slots : [];
    const slot = slots.find((s) => s && typeof s === 'object' && String(s.slotId || '') === slotId);
    if (!slot) {
      throw new HttpsError('failed-precondition', 'Invalid slotId.');
    }

    const isBudgetOnly = slot.budgetOnly === true;

    const unlockCost = slot.unlockCost == null ? null : Number(slot.unlockCost);
    const unlockCurrency = slot.unlockCurrency == null ? 'coins' : String(slot.unlockCurrency);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const unlockedPlaces = Array.isArray(chemcity.unlockedPlaces) ? chemcity.unlockedPlaces : [];
      if (!unlockedPlaces.includes(placeId)) {
        throw new HttpsError('failed-precondition', 'Place is locked.');
      }

      const unlockedSlots = Array.isArray(chemcity.unlockedSlots) ? chemcity.unlockedSlots : [];
      if (unlockedSlots.includes(slotId)) {
        return { ok: true, alreadyUnlocked: true, slotId };
      }

      // Budget-only slots can only be unlocked via extraSlotsBudget.
      if (isBudgetOnly) {
        if (!useExtraSlotBudget) {
          throw new HttpsError('failed-precondition', 'This slot can only be unlocked using extra slot budget.');
        }
        const budget = Number(chemcity.extraSlotsBudget || 0);
        if (budget <= 0) {
          throw new HttpsError('failed-precondition', 'No extra slot budget available.');
        }
        tx.update(userRef, {
          'chemcity.extraSlotsBudget': budget - 1,
          'chemcity.unlockedSlots': [...unlockedSlots, slotId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, slotId, usedExtraSlotBudget: true, budgetOnly: true };
      }

      // Non-budget slots must not spend extraSlotsBudget.
      if (useExtraSlotBudget) {
        throw new HttpsError('failed-precondition', 'This slot cannot be unlocked using extra slot budget.');
      }

      if (unlockCost == null) {
        tx.update(userRef, {
          'chemcity.unlockedSlots': [...unlockedSlots, slotId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, slotId, cost: 0, currency: null };
      }

      const currencies = chemcity.currencies || {};
      const coins = Number(currencies.coins || 0);
      const diamonds = Number(currencies.diamonds || 0);

      if (unlockCurrency === 'diamonds') {
        if (!Number.isFinite(unlockCost) || unlockCost <= 0) {
          throw new HttpsError('failed-precondition', 'Invalid slot unlock cost.');
        }
        if (diamonds < unlockCost) {
          throw new HttpsError('failed-precondition', 'Insufficient diamonds.');
        }
        tx.update(userRef, {
          'chemcity.currencies.diamonds': diamonds - unlockCost,
          'chemcity.unlockedSlots': [...unlockedSlots, slotId],
          'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, slotId, cost: unlockCost, currency: 'diamonds' };
      }

      if (!Number.isFinite(unlockCost) || unlockCost <= 0) {
        throw new HttpsError('failed-precondition', 'Invalid slot unlock cost.');
      }
      if (coins < unlockCost) {
        throw new HttpsError('failed-precondition', 'Insufficient coins.');
      }
      tx.update(userRef, {
        'chemcity.currencies.coins': coins - unlockCost,
        'chemcity.unlockedSlots': [...unlockedSlots, slotId],
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });
      return { ok: true, slotId, cost: unlockCost, currency: 'coins' };
    });
  }
);

exports.chemcityGetDailyLoginBonus = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};
      const streaks = chemcity.streaks || {};

      const today = getTodayUtcDateKey();
      const lastLoginDate = typeof streaks.lastLoginDate === 'string' ? streaks.lastLoginDate : '';

      if (lastLoginDate === today) {
        return { ok: true, alreadyClaimed: true, date: today };
      }

      const prevStreak = Number(streaks.currentStreak || 0);

      let nextStreak = 1;
      if (lastLoginDate) {
        const last = new Date(`${lastLoginDate}T00:00:00.000Z`);
        const t = new Date(`${today}T00:00:00.000Z`);
        const diffDays = Math.floor((t.getTime() - last.getTime()) / (24 * 3600 * 1000));
        if (diffDays === 1) nextStreak = prevStreak + 1;
        else nextStreak = 1;
      }

      const longestStreak = Math.max(Number(streaks.longestStreak || 0), nextStreak);

      const bonuses = chemcity.activeBonuses || {};
      const diamondsAwarded = Math.max(0, Math.floor(Number(bonuses.dailyLoginDiamonds || 5)));

      tx.update(userRef, {
        'chemcity.currencies.diamonds': admin.firestore.FieldValue.increment(diamondsAwarded),
        'chemcity.streaks.currentStreak': nextStreak,
        'chemcity.streaks.longestStreak': longestStreak,
        'chemcity.streaks.lastLoginDate': today,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        ok: true,
        date: today,
        diamondsAwarded,
        currentStreak: nextStreak,
        longestStreak,
      };
    });
  }
);

exports.chemcityQuizReward = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const baseDiamonds = Number(request.data?.baseDiamonds || 0);
    const baseCoins = Number(request.data?.baseCoins || 0);
    const topicId = request.data?.topicId;
    const correctAnswers = Number(request.data?.correctAnswers || 0);
    const totalQuestions = Number(request.data?.totalQuestions || 0);

    if (!Number.isFinite(baseDiamonds) || baseDiamonds < 0) {
      throw new HttpsError('invalid-argument', 'baseDiamonds must be a non-negative number.');
    }
    if (!Number.isFinite(baseCoins) || baseCoins < 0) {
      throw new HttpsError('invalid-argument', 'baseCoins must be a non-negative number.');
    }
    if (topicId != null && typeof topicId !== 'string') {
      throw new HttpsError('invalid-argument', 'topicId must be a string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const progressRef = userRef.collection('chemcity_progress').doc('data');

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};
      const bonuses = chemcity.activeBonuses || {};

      let diamonds = Math.floor(baseDiamonds);

      const kitchenRoll = rollKitchenBonusFromMax(bonuses.quizFlatDiamondBonus);
      diamonds += kitchenRoll;

      const mult = Number(bonuses.quizDiamondMultiplier || 1);
      if (Number.isFinite(mult) && mult > 0) {
        diamonds = Math.floor(diamonds * mult);
      }

      if (rollBeachDoubleFromPercent(bonuses.quizDoubleChancePercent)) {
        diamonds *= 2;
      }

      diamonds = Math.max(0, diamonds);

      const updates = {
        'chemcity.currencies.coins': admin.firestore.FieldValue.increment(Math.floor(baseCoins)),
        'chemcity.currencies.diamonds': admin.firestore.FieldValue.increment(diamonds),
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      };

      tx.update(userRef, updates);

      if (typeof topicId === 'string' && topicId) {
        const progressSnap = await tx.get(progressRef);
        const progress = progressSnap.exists ? (progressSnap.data() || {}) : {};
        const tm = progress.topicMastery && typeof progress.topicMastery === 'object' ? progress.topicMastery : {};
        const prev = tm[topicId] && typeof tm[topicId] === 'object' ? tm[topicId] : {};

        const next = {
          quizzesCompleted: Number(prev.quizzesCompleted || 0) + 1,
          correctAnswers: Number(prev.correctAnswers || 0) + (Number.isFinite(correctAnswers) ? correctAnswers : 0),
          totalQuestions: Number(prev.totalQuestions || 0) + (Number.isFinite(totalQuestions) ? totalQuestions : 0),
        };

        const nextTm = { ...tm, [topicId]: next };
        tx.set(progressRef, { topicMastery: nextTm }, { merge: true });
      }

      return {
        ok: true,
        coinsAwarded: Math.floor(baseCoins),
        diamondsAwarded: diamonds,
      };
    });
  }
);

exports.chemcityEquipCard = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const slotId = request.data?.slotId;
    const itemId = request.data?.itemId;
    if (typeof slotId !== 'string' || !slotId) {
      throw new HttpsError('invalid-argument', 'slotId must be a non-empty string.');
    }
    if (typeof itemId !== 'string' || !itemId) {
      throw new HttpsError('invalid-argument', 'itemId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const itemRef = db.collection('items').doc(itemId);

    const itemSnap = await itemRef.get();
    if (!itemSnap.exists) {
      throw new HttpsError('not-found', 'Item not found.');
    }
    const item = itemSnap.data() || {};
    if (item.deprecated === true) {
      throw new HttpsError('failed-precondition', 'Item is deprecated.');
    }
    const baseId = typeof item.baseId === 'string' && item.baseId.trim() ? item.baseId.trim() : '';
    const itemPlaceId = String(item.placeId || '');
    const validSlots = Array.isArray(item.validSlots) ? item.validSlots.map(String) : [];
    if (!validSlots.includes(slotId)) {
      throw new HttpsError('failed-precondition', 'Item cannot be equipped in this slot.');
    }

    const placeRef = itemPlaceId ? db.collection('places').doc(itemPlaceId) : null;

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const owned = Array.isArray(chemcity.ownedItems) ? chemcity.ownedItems : [];
      if (!owned.includes(itemId)) {
        throw new HttpsError('failed-precondition', 'Item not owned.');
      }

      const unlockedPlaces = Array.isArray(chemcity.unlockedPlaces) ? chemcity.unlockedPlaces : [];
      if (itemPlaceId && !unlockedPlaces.includes(itemPlaceId)) {
        throw new HttpsError('failed-precondition', 'Place is locked.');
      }

      if (placeRef) {
        const placeSnap = await tx.get(placeRef);
        if (!placeSnap.exists) {
          throw new HttpsError('failed-precondition', 'Place config missing.');
        }
        const place = placeSnap.data() || {};
        const slots = Array.isArray(place.slots) ? place.slots : [];
        const slot = slots.find((s) => s && typeof s === 'object' && String(s.slotId || '') === slotId);
        if (!slot) {
          throw new HttpsError('failed-precondition', 'Invalid slotId.');
        }
        const unlockedSlots = Array.isArray(chemcity.unlockedSlots) ? chemcity.unlockedSlots : [];
        const isFree = slot.unlockCost == null;
        if (!isFree && !unlockedSlots.includes(slotId)) {
          throw new HttpsError('failed-precondition', 'Slot is locked.');
        }
      }

      const prevEquipped = chemcity.equipped && typeof chemcity.equipped === 'object' ? chemcity.equipped : {};
      const nextEquipped = { ...prevEquipped };

      if (baseId) {
        const entries = Object.entries(prevEquipped);
        for (const [equippedSlotId, equippedItemId] of entries) {
          if (equippedSlotId === slotId) continue;
          if (typeof equippedItemId !== 'string' || !equippedItemId) continue;

          const equippedRef = db.collection('items').doc(equippedItemId);
          const equippedSnap = await tx.get(equippedRef);
          if (!equippedSnap.exists) continue;
          const equipped = equippedSnap.data() || {};
          const equippedBaseId =
            typeof equipped.baseId === 'string' && equipped.baseId.trim() ? equipped.baseId.trim() : '';
          if (equippedBaseId && equippedBaseId === baseId) {
            delete nextEquipped[equippedSlotId];
          }
        }
      }

      nextEquipped[slotId] = itemId;

      const nextBonuses = await computeChemCityActiveBonuses(db, nextEquipped);

      tx.update(userRef, {
        'chemcity.equipped': nextEquipped,
        'chemcity.activeBonuses': nextBonuses,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, equipped: nextEquipped, activeBonuses: nextBonuses };
    });
  }
);

exports.chemcityUnequipCard = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const slotId = request.data?.slotId;
    if (typeof slotId !== 'string' || !slotId) {
      throw new HttpsError('invalid-argument', 'slotId must be a non-empty string.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }
      const userData = userSnap.data() || {};
      const chemcity = userData.chemcity || {};

      const prevEquipped = chemcity.equipped && typeof chemcity.equipped === 'object' ? chemcity.equipped : {};
      const nextEquipped = { ...prevEquipped };
      delete nextEquipped[slotId];

      const nextBonuses = await computeChemCityActiveBonuses(db, nextEquipped);

      tx.update(userRef, {
        'chemcity.equipped': nextEquipped,
        'chemcity.activeBonuses': nextBonuses,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return { ok: true, equipped: nextEquipped, activeBonuses: nextBonuses };
    });
  }
);

exports.chemcityInitUser = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);
    return { ok: true };
  }
);

exports.chemcityMigrateSlotIds = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();
    await ensureChemCityInitialized(db, uid);

    const SLOT_ID_SCHEMA_VERSION = 2;

    const SLOT_ID_MAP = {
      // Lab
      lab_bench_1: 'lab_bench',
      lab_bench_2: 'lab_fume_hood',
      lab_bench_3: 'lab_acid_alkali_cabinet',
      lab_bench_4: 'lab_apparatus_1',
      lab_bench_5: 'lab_metal_shelf',
      lab_bench_6: 'lab_salt_shelf',
      lab_premium_1: 'lab_hazardous_chemical_shelf',
      lab_premium_2: 'lab_apparatus_2',
      lab_premium_3: 'lab_chemical_shelf',
      lab_premium_4: 'lab_gas_tank',
      // Kitchen
      kitchen_counter_1: 'kitchen_cutlery_drawer',
      kitchen_counter_2: 'kitchen_pantry_1',
      kitchen_counter_3: 'kitchen_stove_oven',
      kitchen_counter_4: 'kitchen_dinette',
      kitchen_shelf_1: 'kitchen_fridge',
      kitchen_shelf_2: 'kitchen_pantry_2',
      kitchen_shelf_3: 'kitchen_base_cabinet',
      kitchen_shelf_4: 'kitchen_countertop',
      // Toilet
      toilet_tank_1: 'toilet_faucet',
      toilet_tank_2: 'toilet_vanity_cabinet',
      toilet_tank_3: 'toilet_bathtub',
      toilet_tank_4: 'toilet_mirror_cabinet_1',
      toilet_cabinet_1: 'toilet_toilet',
      toilet_cabinet_2: 'toilet_vanity_top',
      toilet_cabinet_3: 'toilet_mirror_cabinet_2',
      // Garden
      garden_bed_1: 'garden_shed_1',
      garden_bed_2: 'garden_lawn',
      garden_bed_3: 'garden_greenhouse',
      garden_bed_4: 'garden_flower_bed',
      garden_plot_1: 'garden_mole_hill',
      garden_plot_2: 'garden_broadcast_spreader',
      garden_plot_3: 'garden_shed_2',
      // Gas Station
      gas_pump_1: 'gas_station_car_1',
      gas_pump_2: 'gas_station_construction_site',
      gas_pump_3: 'gas_station_factory',
      gas_pump_4: 'gas_station_petrol_pump',
      gas_shelf_1: 'gas_station_car_2',
      gas_shelf_2: 'gas_station_motel',
      gas_shelf_3: 'gas_station_street_light',
      gas_shelf_4: 'gas_station_firework',
      // Boutique
      boutique_shelf_1: 'lifestyle_boutique_poseur_table_1',
      boutique_shelf_2: 'lifestyle_boutique_service_desk',
      boutique_shelf_3: 'lifestyle_boutique_jewellery_display',
      boutique_shelf_4: 'lifestyle_boutique_power_essentials',
      boutique_display_1: 'lifestyle_boutique_apparel_gallery',
      boutique_display_2: 'lifestyle_boutique_poseur_table_2',
      // Beach
      beach_sand_1: 'beach_sky',
      beach_sand_2: 'beach_sea',
      beach_sand_3: 'beach_rock_1',
      beach_sand_4: 'beach_dry_sand',
      beach_pier_1: 'beach_strandline',
      beach_pier_2: 'beach_rock_2',
      beach_pier_3: 'beach_cliffside',
      // School
      school_desk_1: 'school_student_desk_1',
      school_desk_2: 'school_teacher_desk',
      school_desk_3: 'school_blackboard',
      school_desk_4: 'school_science_corner',
      school_desk_5: 'school_poster',
      school_locker_1: 'school_window_side_table',
      school_locker_2: 'school_student_desk_2',
    };

    const userRef = db.collection('users').doc(uid);

    return db.runTransaction(async (tx) => {
      const snap = await tx.get(userRef);
      if (!snap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = snap.data() || {};
      const chemcity = userData.chemcity || {};

      const currentVersion = Number(chemcity.slotIdSchemaVersion || 0);
      if (currentVersion >= SLOT_ID_SCHEMA_VERSION) {
        return { ok: true, alreadyMigrated: true, version: currentVersion };
      }

      const prevEquipped = chemcity.equipped && typeof chemcity.equipped === 'object' ? chemcity.equipped : {};
      const prevUnlockedSlots = Array.isArray(chemcity.unlockedSlots) ? chemcity.unlockedSlots.map(String) : [];

      const nextEquipped = {};
      let equippedKeysMigrated = 0;
      for (const [oldSlotId, itemId] of Object.entries(prevEquipped)) {
        const newSlotId = SLOT_ID_MAP[oldSlotId] || oldSlotId;
        if (newSlotId !== oldSlotId) equippedKeysMigrated++;
        nextEquipped[newSlotId] = itemId;
      }

      const nextUnlockedSlots = [];
      let unlockedSlotsMigrated = 0;
      const seen = new Set();
      for (const oldSlotId of prevUnlockedSlots) {
        const newSlotId = SLOT_ID_MAP[oldSlotId] || oldSlotId;
        if (newSlotId !== oldSlotId) unlockedSlotsMigrated++;
        if (seen.has(newSlotId)) continue;
        seen.add(newSlotId);
        nextUnlockedSlots.push(newSlotId);
      }

      const nextBonuses = await computeChemCityActiveBonuses(db, nextEquipped);

      tx.update(userRef, {
        'chemcity.equipped': nextEquipped,
        'chemcity.unlockedSlots': nextUnlockedSlots,
        'chemcity.activeBonuses': nextBonuses,
        'chemcity.slotIdSchemaVersion': SLOT_ID_SCHEMA_VERSION,
        'chemcity.updatedAt': admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        ok: true,
        alreadyMigrated: false,
        version: SLOT_ID_SCHEMA_VERSION,
        equippedKeysMigrated,
        unlockedSlotsMigrated,
      };
    });
  }
);

exports.chemcityCollectPassiveIncome = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'User must be signed in.');
    }

    const db = admin.firestore();

    await ensureChemCityInitialized(db, uid);

    const userRef = db.collection('users').doc(uid);
    const MAX_HOURS = 24;

    return db.runTransaction(async (tx) => {
      const snap = await tx.get(userRef);
      if (!snap.exists) {
        throw new HttpsError('not-found', 'User not found.');
      }

      const userData = snap.data() || {};
      const chemcity = userData.chemcity || {};
      const bonuses = chemcity.activeBonuses || {};
      const passiveBase = Number(bonuses.passiveBaseCoinsPerHour || 0);

      if (!Number.isFinite(passiveBase) || passiveBase <= 0) {
        return {
          coinsAwarded: 0,
          message: 'No passive income yet — equip cards in the Garden and Lab.',
        };
      }

      const serverNow = admin.firestore.Timestamp.now();
      const lastCollected = chemcity.passiveIncome?.lastCollected || null;

      let elapsedSeconds = 0;
      if (lastCollected && typeof lastCollected.seconds === 'number') {
        elapsedSeconds = serverNow.seconds - lastCollected.seconds;
      }

      const cappedSeconds = Math.min(elapsedSeconds, MAX_HOURS * 3600);
      const elapsedHours = cappedSeconds / 3600;
      const coinsAwarded = Math.floor(passiveBase * elapsedHours);

      tx.update(userRef, {
        'chemcity.currencies.coins': admin.firestore.FieldValue.increment(coinsAwarded),
        'chemcity.passiveIncome.lastCollected': serverNow,
        'chemcity.updatedAt': serverNow,
      });

      return {
        coinsAwarded,
        elapsedHours: Number(elapsedHours.toFixed(2)),
        newLastCollected: serverNow.toDate().toISOString(),
      };
    });
  }
);

exports.normalizeMistakes = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to normalize mistakes');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');

    const pageSize = 800;
    let last = null;
    let processed = 0;
    let updated = 0;

    const nowIso = new Date().toISOString();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);

      const snap = await q.get();
      if (snap.empty) break;

      // Only write docs that truly need a patch.
      const toPatch = [];
      for (const docSnap of snap.docs) {
        const d = docSnap.data() || {};

        const topic = d.Topic ?? d.topic ?? null;
        const subtopic = d.Subtopic ?? d.subtopic ?? null;
        const lastWrongAt = d.lastWrongAt ?? d.lastAttempted ?? d.updatedAt ?? d.createdAt ?? nowIso;

        const needsTopic = d.Topic == null && d.topic != null;
        const needsSubtopic = d.Subtopic == null && d.subtopic != null;
        const needsLastWrongAt = d.lastWrongAt == null;

        if (needsTopic || needsSubtopic || needsLastWrongAt) {
          toPatch.push({
            ref: docSnap.ref,
            patch: {
              Topic: topic,
              Subtopic: subtopic,
              lastWrongAt,
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          });
        }
      }

      if (toPatch.length > 0) {
        for (let i = 0; i < toPatch.length; i += 450) {
          const batch = db.batch();
          const slice = toPatch.slice(i, i + 450);
          slice.forEach((x) => {
            batch.set(x.ref, x.patch, { merge: true });
          });
          await batch.commit();
          updated += slice.length;
        }
      }

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Make it easy to see when it was last run.
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');
    await statsRef.set({
      lastNormalizedAt: admin.firestore.FieldValue.serverTimestamp(),
      lastNormalizedProcessed: processed,
      lastNormalizedUpdated: updated,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, updated };
  }
);

exports.updateMistakeTopicStatsOnUpdate = onDocumentUpdated(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || null;
    const after = event.data?.after?.data?.() || null;
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, after);
  }
);

exports.updateMistakeTopicStatsOnDelete = onDocumentDeleted(
  {
    document: 'users/{userId}/mistakes/{mistakeId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const before = snap.data() || {};
    const userId = event.params?.userId;
    if (!userId) return;
    const db = admin.firestore();
    await applyMistakeDocDelta(db, userId, before, null);
  }
);

exports.rebuildMistakeTopicStats = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild mistake topic stats');
    }

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');
    const statsRef = db.collection('users').doc(uid).collection('mistake_stats').doc('topicBuckets');

    const topics = {};

    const pageSize = 800;
    let last = null;
    let processed = 0;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = mistakesRef.orderBy(admin.firestore.FieldPath.documentId()).limit(pageSize);
      if (last) q = q.startAfter(last);
      const snap = await q.get();
      if (snap.empty) break;

      snap.docs.forEach((docSnap) => {
        const m = docSnap.data() || {};
        const topic = getTopicFromMistake(m);
        if (!topic) return;
        const topicEnc = encodeKey(topic);
        const bucket = getBucketFromMistake(m);
        const isActive = getIsActiveFromMistake(m);

        const entry = topics[topicEnc] && typeof topics[topicEnc] === 'object' ? topics[topicEnc] : {};
        entry.total = Number(entry.total || 0) + 1;
        const bucketKey = `b_${bucket}`;
        entry[bucketKey] = Number(entry[bucketKey] || 0) + 1;
        if (isActive) entry.active = Number(entry.active || 0) + 1;
        topics[topicEnc] = entry;
      });

      processed += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    await statsRef.set({
      topics,
      processed,
      rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    }, { merge: true });

    return { ok: true, userId: uid, processed, topics: Object.keys(topics).length };
  }
);

exports.pickMistakesForReview = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to pick mistakes');
    }

    const data = request.data && typeof request.data === 'object' ? request.data : {};
    const limitN = Math.min(Math.max(parseInt(data.limit || 40, 10) || 40, 1), 400);
    const filters = data.filters && typeof data.filters === 'object' ? data.filters : {};

    const datePeriod = safeString(filters.datePeriod || 'all');
    const selectedTopics = Array.isArray(filters.selectedTopics) ? filters.selectedTopics.filter(Boolean).map(String) : [];
    const selectedSubtopics = Array.isArray(filters.selectedSubtopics) ? filters.selectedSubtopics.filter(Boolean).map(String) : [];
    const selectedMasteryLevels = Array.isArray(filters.selectedMasteryLevels) ? filters.selectedMasteryLevels.filter(Boolean).map(String) : [];
    const srsPresence = safeString(filters.srsPresence || 'all');

    const db = admin.firestore();
    const mistakesRef = db.collection('users').doc(uid).collection('mistakes');

    const now = new Date();
    const weekAgo = new Date(now);
    weekAgo.setDate(weekAgo.getDate() - 7);
    const monthAgo = new Date(now);
    monthAgo.setMonth(monthAgo.getMonth() - 1);

    const matchesSrs = (row) => {
      if (srsPresence === 'in_srs') return row && row.srsIsActive === true;
      if (srsPresence === 'not_in_srs') return normalizeBucket((row && row.srsBucket) || 'not_in_srs') === 'not_in_srs';
      return true;
    };

    const topics = selectedTopics;
    const subs = selectedSubtopics;
    const lvls = selectedMasteryLevels;

    const baseParts = [];
    if (datePeriod === 'week') baseParts.push(['lastWrongAt', '>=', weekAgo.toISOString()]);
    if (datePeriod === 'month') baseParts.push(['lastWrongAt', '>=', monthAgo.toISOString()]);

    if (topics.length === 1) baseParts.push(['Topic', '==', topics[0]]);
    else if (topics.length >= 2 && topics.length <= 10) baseParts.push(['Topic', 'in', topics]);

    if (subs.length === 1 && topics.length <= 1) baseParts.push(['Subtopic', '==', subs[0]]);

    if (srsPresence !== 'not_in_srs' && lvls.length === 1) baseParts.push(['srsBucket', '==', normalizeBucket(lvls[0])]);

    if (srsPresence === 'in_srs') baseParts.push(['srsIsActive', '==', true]);
    if (srsPresence === 'not_in_srs') baseParts.push(['srsBucket', '==', 'not_in_srs']);

    const collected = [];
    let fetched = 0;
    const maxFetch = 1200;
    const pageSize = 250;
    let last = null;

    // eslint-disable-next-line no-constant-condition
    while (true) {
      if (collected.length >= limitN) break;
      if (fetched >= maxFetch) break;

      let q = mistakesRef.orderBy('lastWrongAt', 'desc');
      baseParts.forEach(([f, op, v]) => { q = q.where(f, op, v); });
      if (last) q = q.startAfter(last);
      q = q.limit(Math.min(pageSize, maxFetch - fetched));

      let snap;
      try {
        snap = await q.get();
      } catch (err) {
        const code = err && (err.code || err.status || err.statusCode);
        const details = err && (err.details || err.message || String(err));
        // Firestore missing index => FAILED_PRECONDITION (gRPC code 9)
        if (code === 9 || code === 'FAILED_PRECONDITION') {
          throw new HttpsError('failed-precondition', details);
        }
        throw new HttpsError('internal', details);
      }
      if (snap.empty) break;
      fetched += snap.size;
      last = snap.docs[snap.docs.length - 1];

      for (const docSnap of snap.docs) {
        const row = docSnap.data() || {};

        if (topics.length > 10) {
          const tp = safeString(row.Topic || row.topic || '');
          if (!tp || !topics.includes(tp)) continue;
        }

        if (subs.length > 1) {
          const sb = safeString(row.Subtopic || row.subtopic || '');
          if (!sb || !subs.includes(sb)) continue;
        }

        if (srsPresence !== 'not_in_srs' && lvls.length > 1) {
          const b = normalizeBucket(row.srsBucket || 'not_in_srs');
          if (!lvls.includes(b)) continue;
        }

        if (!matchesSrs(row)) continue;

        collected.push(docSnap.id);
        if (collected.length >= limitN) break;
      }

      if (snap.size < pageSize) break;
    }

    return {
      ok: true,
      userId: uid,
      ids: collected.slice(0, limitN),
      requested: limitN,
      fetched,
    };
  }
);

async function applySrsSummaryDelta(db, userId, dateStr, delta, topic, subtopic) {
  const uid = safeString(userId);
  const dateKey = safeString(dateStr);
  if (!uid || !dateKey || !Number.isFinite(delta) || delta === 0) return;

  const topicKey = encodeKey(topic || '');
  const subtopicKey = encodeKey(subtopic || '');
  const hasTopic = Boolean(topicKey);
  const hasSubtopic = Boolean(topicKey) && Boolean(subtopicKey);
  const compoundSubKey = hasSubtopic ? `${topicKey}::${subtopicKey}` : '';

  const summaryRef = db.collection('users').doc(uid).collection('srs_daily_summaries').doc(dateKey);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(summaryRef);
    const prev = snap.exists ? (snap.data() || {}) : {};

    const next = { ...prev };
    next.date = dateKey;
    next.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    const prevTotal = Number(prev.dueTotal || 0);
    next.dueTotal = Math.max(0, prevTotal + delta);

    const prevTopics = prev.topicCounts && typeof prev.topicCounts === 'object' ? prev.topicCounts : {};
    const prevSubs = prev.subtopicCounts && typeof prev.subtopicCounts === 'object' ? prev.subtopicCounts : {};

    const nextTopics = { ...prevTopics };
    const nextSubs = { ...prevSubs };

    if (hasTopic) {
      const old = Number(nextTopics[topicKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextTopics[topicKey];
      else nextTopics[topicKey] = v;
    }

    if (hasSubtopic) {
      const old = Number(nextSubs[compoundSubKey] || 0);
      const v = Math.max(0, old + delta);
      if (v === 0) delete nextSubs[compoundSubKey];
      else nextSubs[compoundSubKey] = v;
    }

    next.topicCounts = nextTopics;
    next.subtopicCounts = nextSubs;

    tx.set(summaryRef, next, { merge: true });
  });
}

function isActiveCard(card) {
  if (!card || typeof card !== 'object') return false;
  if (card.isActive === false) return false;
  if (!card.userId) return false;
  if (!card.nextReviewDate) return false;
  return true;
}

// Define secrets (use new Firebase Functions params API)
const algoliaAppId = defineSecret('ALGOLIA_APP_ID');
const algoliaAdminKey = defineSecret('ALGOLIA_ADMIN_KEY');
const ALGOLIA_INDEX_NAME = 'forum_posts';

// Initialize Algolia client lazily at runtime
function getAlgoliaClient() {
  const appId = algoliaAppId.value();
  const adminKey = algoliaAdminKey.value();
  if (!appId || !adminKey) return null;
  return algoliasearch(appId, adminKey);
}

exports.aggregateCommentQuestionStatsOnCommentCreate = onDocumentCreated(
  {
    document: 'comments/{commentId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;

    const comment = snap.data() || {};
    const questionId = comment.questionId != null ? String(comment.questionId) : '';
    if (!questionId) return;

    const createdAt = typeof comment.createdAt === 'string'
      ? comment.createdAt
      : new Date().toISOString();

    const db = admin.firestore();
    const statsRef = db.collection('comment_question_stats').doc(questionId);

    await db.runTransaction(async (tx) => {
      const statsSnap = await tx.get(statsRef);
      const prev = statsSnap.exists ? (statsSnap.data() || {}) : {};

      const prevLast = typeof prev.lastActivity === 'string' ? prev.lastActivity : '';
      const nextLastActivity = prevLast && prevLast > createdAt ? prevLast : createdAt;

      tx.set(statsRef, {
        questionId,
        commentCount: admin.firestore.FieldValue.increment(1),
        lastActivity: nextLastActivity,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.rebuildSrsDailySummaries = onCall(
  {
    region: 'asia-east1',
  },
  async (request) => {
    const uid = request.auth?.uid;
    if (!uid) {
      throw new HttpsError('unauthenticated', 'Must be signed in to rebuild summaries');
    }

    const db = admin.firestore();

    // Page through all active cards for this user
    const cardsRef = db.collection('spaced_repetition_cards');
    const pageSize = 500;
    let last = null;
    let totalCards = 0;

    // dateStr => { dueTotal, topicCounts, subtopicCounts }
    const aggregated = new Map();

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let q = cardsRef
        .where('userId', '==', uid)
        .where('isActive', '==', true)
        .orderBy(admin.firestore.FieldPath.documentId())
        .limit(pageSize);

      if (last) {
        q = q.startAfter(last);
      }

      const snap = await q.get();
      if (snap.empty) break;

      for (const docSnap of snap.docs) {
        const card = docSnap.data() || {};
        if (!card.nextReviewDate) continue;

        const dateKey = safeString(card.nextReviewDate);
        const topicEnc = encodeKey(card.topic || '');
        const subEnc = encodeKey(card.subtopic || '');
        const compound = (topicEnc && subEnc) ? `${topicEnc}::${subEnc}` : '';

        if (!aggregated.has(dateKey)) {
          aggregated.set(dateKey, {
            date: dateKey,
            dueTotal: 0,
            topicCounts: {},
            subtopicCounts: {},
          });
        }

        const entry = aggregated.get(dateKey);
        entry.dueTotal += 1;

        if (topicEnc) {
          entry.topicCounts[topicEnc] = (entry.topicCounts[topicEnc] || 0) + 1;
        }
        if (compound) {
          entry.subtopicCounts[compound] = (entry.subtopicCounts[compound] || 0) + 1;
        }
      }

      totalCards += snap.size;
      last = snap.docs[snap.docs.length - 1];
      if (snap.size < pageSize) break;
    }

    // Write summaries for encountered dates (overwrite those docs).
    const summariesRef = db.collection('users').doc(uid).collection('srs_daily_summaries');
    const dateKeys = Array.from(aggregated.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    let written = 0;
    for (let i = 0; i < dateKeys.length; i += 400) {
      const batch = db.batch();
      const slice = dateKeys.slice(i, i + 400);

      for (const dateKey of slice) {
        const data = aggregated.get(dateKey);
        const ref = summariesRef.doc(dateKey);
        batch.set(ref, {
          date: data.date,
          dueTotal: data.dueTotal,
          topicCounts: data.topicCounts,
          subtopicCounts: data.subtopicCounts,
          rebuiltAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
      }

      await batch.commit();
      written += slice.length;
    }

    return {
      ok: true,
      userId: uid,
      cardsProcessed: totalCards,
      datesWritten: written,
    };
  }
);

// Maintain SRS daily summaries (cheap calendar counts)
exports.updateSrsDailySummaryOnCardCreate = onDocumentCreated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, 1, card.topic, card.subtopic);
  }
);

exports.updateSrsDailySummaryOnCardUpdate = onDocumentUpdated(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const before = event.data?.before?.data?.() || {};
    const after = event.data?.after?.data?.() || {};

    const beforeActive = isActiveCard(before);
    const afterActive = isActiveCard(after);

    const db = admin.firestore();

    // Removed from active set
    if (beforeActive && !afterActive) {
      await applySrsSummaryDelta(db, before.userId, before.nextReviewDate, -1, before.topic, before.subtopic);
      return;
    }

    // Added to active set
    if (!beforeActive && afterActive) {
      await applySrsSummaryDelta(db, after.userId, after.nextReviewDate, 1, after.topic, after.subtopic);
      return;
    }

    if (!beforeActive && !afterActive) return;

    const uid = after.userId || before.userId;
    const beforeDate = safeString(before.nextReviewDate);
    const afterDate = safeString(after.nextReviewDate);
    const beforeTopic = safeString(before.topic);
    const afterTopic = safeString(after.topic);
    const beforeSub = safeString(before.subtopic);
    const afterSub = safeString(after.subtopic);

    const dateChanged = beforeDate !== afterDate;
    const topicChanged = beforeTopic !== afterTopic;
    const subChanged = beforeSub !== afterSub;

    if (!dateChanged && !topicChanged && !subChanged) return;

    // Remove old
    await applySrsSummaryDelta(db, uid, beforeDate, -1, beforeTopic, beforeSub);
    // Add new
    await applySrsSummaryDelta(db, uid, afterDate, 1, afterTopic, afterSub);
  }
);

exports.updateSrsDailySummaryOnCardDelete = onDocumentDeleted(
  {
    document: 'spaced_repetition_cards/{cardId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const card = snap.data() || {};
    if (!isActiveCard(card)) return;

    const db = admin.firestore();
    await applySrsSummaryDelta(db, card.userId, card.nextReviewDate, -1, card.topic, card.subtopic);
  }
);

// Maintain daily cleared/milestone stats from SRS review attempts
exports.updateSrsDailySummaryOnAttemptCreate = onDocumentCreated(
  {
    document: 'review_attempts/{attemptId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const attempt = snap.data() || {};

    const uid = safeString(attempt.userId);
    if (!uid) return;

    const attemptedAt = safeString(attempt.attemptedAt);
    if (!attemptedAt) return;

    const wasCorrect = attempt.wasCorrect === true;
    const statusBefore = attempt?.stateBefore?.status;

    const db = admin.firestore();
    await applySrsAttemptDelta(db, uid, attemptedAt, wasCorrect ? 1 : 0, statusBefore);
  }
);

 function toHongKongDate(dateObj) {
   // Convert an instant-in-time to a Date whose UTC fields represent Asia/Hong_Kong local time.
   // This avoids discrepancies between browser local time (HK) and Cloud Functions runtime (UTC).
   const d = dateObj instanceof Date ? dateObj : new Date(dateObj);
   return new Date(d.getTime() + 8 * 60 * 60 * 1000);
 }

function getWeeklyKeyForDate(dateObj) {
  // Use UTC getters so output is independent of the runtime's local timezone.
  const date = new Date(Date.UTC(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
  const yyyy = date.getUTCFullYear();
  return `leaderboard_weekly_${yyyy}-W${String(weekNo).padStart(2, '0')}`;
}

function weeklyTokensForRank(rank) {
  const r = Number(rank || 0);
  if (!Number.isFinite(r) || r <= 0) return 0;
  // Keep consistent with frontend logic: max(0, 11 - rank)
  return Math.max(0, 11 - r);
}

exports.aggregateWeeklyLeaderboardOnAttemptCreate = onDocumentCreated(
  {
    document: 'attempts/{attemptId}',
    region: 'asia-east1',
  },
  async (event) => {
    const snap = event.data;
    if (!snap) return;
    const attemptData = snap.data() || {};
    const userId = attemptData.userId;
    if (!userId) return;

    const attemptTs = attemptData.timestamp ? new Date(attemptData.timestamp) : new Date();
    const weekId = getWeeklyKeyForDate(toHongKongDate(attemptTs));

    const db = admin.firestore();
    const entryRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries').doc(userId);
    const userRef = db.collection('users').doc(userId);

    await db.runTransaction(async (tx) => {
      const [entrySnap, userSnap] = await Promise.all([
        tx.get(entryRef),
        tx.get(userRef),
      ]);

      const userData = userSnap.exists ? userSnap.data() : {};
      const prev = entrySnap.exists ? entrySnap.data() : {};

      const prevAttemptCount = Number(prev.attemptCount || 0);
      const prevTotalScore = Number(prev.totalScore || 0);
      const prevTotalQuestions = Number(prev.totalQuestions || 0);
      const prevTotalCorrect = Number(prev.totalCorrect || 0);

      const nextAttemptCount = prevAttemptCount + 1;
      const nextTotalScore = prevTotalScore + Number(attemptData.percentage || 0);
      const nextTotalQuestions = prevTotalQuestions + Number(attemptData.totalQuestions || 0);
      const nextTotalCorrect = prevTotalCorrect + Number(attemptData.correctAnswers || 0);
      const nextAverageScore = nextAttemptCount > 0 ? Math.round(nextTotalScore / nextAttemptCount) : 0;

      tx.set(entryRef, {
        userId,
        weekId,
        displayName: userData?.displayName || 'Unknown',
        level: userData?.level || null,
        equippedProfilePic: (userData?.equipped || {}).profilePic || 'flask_blue',
        equippedTheme: (userData?.equipped || {}).theme || 'default',
        streak: Number(userData?.streak || 0),
        attemptCount: nextAttemptCount,
        totalScore: nextTotalScore,
        averageScore: nextAverageScore,
        totalQuestions: nextTotalQuestions,
        totalCorrect: nextTotalCorrect,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });
    });
  }
);

exports.weeklyLeaderboardPayout = onSchedule(
  {
    schedule: '0 0 * * 1',
    timeZone: 'Asia/Hong_Kong',
    region: 'asia-east1',
  },
  async () => {
    const db = admin.firestore();

    // Run payout for LAST week (so the leaderboard is complete)
    const now = toHongKongDate(new Date());
    const lastWeekDate = new Date(now);
    lastWeekDate.setDate(lastWeekDate.getDate() - 7);
    const weekId = getWeeklyKeyForDate(toHongKongDate(lastWeekDate));

    const entriesRef = db.collection('weekly_leaderboards').doc(weekId).collection('entries');
    const topSnap = await entriesRef.orderBy('averageScore', 'desc').limit(10).get();

    if (topSnap.empty) return;

    // Batch-like loop (transactions per user to keep idempotency + correct balances)
    const payoutPromises = topSnap.docs.map(async (docSnap, idx) => {
      const entry = docSnap.data() || {};
      const userId = entry.userId || docSnap.id;
      const rank = idx + 1;
      const tokens = weeklyTokensForRank(rank);
      if (!userId || tokens <= 0) return;

      const payoutRef = db
        .collection('weekly_leaderboards')
        .doc(weekId)
        .collection('payouts')
        .doc(userId);

      const userRef = db.collection('users').doc(userId);

      await db.runTransaction(async (tx) => {
        const [payoutSnap, userSnap] = await Promise.all([
          tx.get(payoutRef),
          tx.get(userRef),
        ]);

        if (payoutSnap.exists) {
          return; // already paid
        }

        if (!userSnap.exists) {
          // still record payout marker to avoid repeated attempts
          tx.set(payoutRef, {
            userId,
            weekId,
            rank,
            tokens,
            skipped: true,
            reason: 'User doc missing',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          });
          return;
        }

        const userData = userSnap.data() || {};
        const currentTokens = Number(userData.tokens || 0);
        const newTokens = currentTokens + tokens;

        tx.update(userRef, {
          tokens: newTokens,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const historyRef = userRef.collection('tokenHistory').doc();
        tx.set(historyRef, {
          amount: tokens,
          reason: `Leaderboard Reward: weekly #${rank}`,
          type: 'gain',
          timestamp: admin.firestore.FieldValue.serverTimestamp(),
          balanceAfter: newTokens,
          metadata: {
            category: 'leaderboard',
            period: 'weekly',
            rank,
            weekId,
          },
        });

        const notifRef = db.collection('notifications').doc();
        tx.set(notifRef, {
          recipientId: userId,
          senderId: 'system',
          type: 'leaderboard_reward',
          senderDisplayName: 'System',
          previewText: `Weekly leaderboard #${rank}: +${tokens} tokens`,
          read: false,
          createdAt: new Date().toISOString(),
          weekId,
          rank,
          tokens,
        });

        tx.set(payoutRef, {
          userId,
          weekId,
          rank,
          tokens,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      });
    });

    await Promise.all(payoutPromises);
  }
);

// === Algolia search sync for forum_posts ===

// Helper: prepare Algolia record from Firestore doc
function toAlgoliaRecord(postId, data) {
  return {
    objectID: postId,
    title: data.title || '',
    content: data.content || '',
    category: data.category || '',
    userDisplayName: data.userDisplayName || '',
    userId: data.userId || '',
    createdAt: data.createdAt || '',
    // You can add more fields if you want them searchable/filterable
  };
}

// Create: when a new forum post is created
exports.syncForumPostToAlgoliaOnCreate = onDocumentCreated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Update: when a forum post is updated
exports.syncForumPostToAlgoliaOnUpdate = onDocumentUpdated(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const snap = event.data;
    if (!snap) return;
    const data = snap.after.data() || {};
    const postId = event.params.postId;
    const record = toAlgoliaRecord(postId, data);
    await algoliaIndex.saveObject(record);
  }
);

// Delete: when a forum post is deleted
exports.syncForumPostToAlgoliaOnDelete = onDocumentDeleted(
  {
    document: 'forum_posts/{postId}',
    region: 'asia-east1',
    secrets: [algoliaAppId, algoliaAdminKey],
  },
  async (event) => {
    const algoliaClient = getAlgoliaClient();
    if (!algoliaClient) return;
    const algoliaIndex = algoliaClient.initIndex(ALGOLIA_INDEX_NAME);
    const postId = event.params.postId;
    await algoliaIndex.deleteObject(postId);
  }
);


===== FILE: functions/chemcity/initChemCityUser.ts =====

// ============================================================
// ChemCity — User Initialization
// Creates the user doc + progress sub-document with defaults.
// Called by the initChemCityUser Cloud Function.
//
// NOTE: This function must run server-side (Cloud Function).
//       It writes currencies — clients cannot do this.
// ============================================================

import * as admin from 'firebase-admin';
import type { UserChemCityData, UserProgressData } from '../../src/lib/chemcity/types';

const db = admin.firestore();

/**
 * Creates a fresh ChemCity user doc and progress sub-document.
 * Called once per user on their first ChemCity session.
 *
 * Starter state:
 *  - 500 coins, 20 diamonds (enough to unlock Garden + Kitchen)
 *  - Lab unlocked by default (free)
 *  - No cards, no equipped items
 */
export async function initChemCityUser(userId: string): Promise<void> {
  const userRef = db.collection('users').doc(userId);
  const progressRef = userRef.collection('progress').doc('data');

  // Check if already initialised
  const existing = await userRef.get();
  if (existing.exists) {
    console.warn(`[initChemCityUser] User ${userId} already initialised — skipping.`);
    return;
  }

  const now = admin.firestore.FieldValue.serverTimestamp();

  const userDoc: Omit<UserChemCityData, 'createdAt' | 'updatedAt' | 'passiveIncome'> & {
    createdAt: admin.firestore.FieldValue;
    updatedAt: admin.firestore.FieldValue;
    passiveIncome: { lastCollected: null };
  } = {
    userId,
    currencies: {
      coins: 500,
      diamonds: 20,
    },
    storeSlotCount: 3,
    ownedItems: [],
    ownedCosmetics: ['avatar_1_plain', 'bg_1'],
    equipped: {},
    equippedCosmetics: {
      avatarId: 'avatar_1_plain',
      backgroundId: 'bg_1',
    },
    activeBonuses: {
      passiveBaseCoinsPerHour: 0,
      passiveMultiplier: 1,
      quizFlatDiamondBonus: 0,
      quizDiamondMultiplier: 1,
      quizDoubleChancePercent: 0,
      dailyLoginDiamonds: 5, // base Toilet: 5 + (0 × 2)
      extraSlotsTotal: 0,
      shopDiscountPercent: 0,
    },
    unlockedPlaces: ['lab'], // Lab is free — unlocked from the start
    unlockedSlots: [],
    extraSlotsBudget: 0,
    passiveIncome: {
      lastCollected: null,
    },
    streaks: {
      currentStreak: 0,
      longestStreak: 0,
      lastLoginDate: '',
      streakFreezeCount: 0,
    },
    cacheVersion: 0, // will be updated on first client load
    createdAt: now,
    updatedAt: now,
  };

  const progressDoc: UserProgressData = {
    collections: {},
    topicMastery: {},
  };

  // Write both docs in a single batch
  const batch = db.batch();
  batch.set(userRef, userDoc);
  batch.set(progressRef, progressDoc);
  await batch.commit();

  console.info(`[initChemCityUser] User ${userId} initialised successfully.`);
}


===== FILE: src/services/tokenService.js =====

// ============================================================================
// TOKEN SERVICE - Real-Time Token Economy with Anti-Cheat
// ============================================================================

import { 
  doc, getDoc, setDoc, updateDoc, collection, addDoc, 
  query, orderBy, limit, getDocs, runTransaction, serverTimestamp,
  onSnapshot, increment, writeBatch
} from 'firebase/firestore';
import { db } from '../firebase/config';

// ────────────────────────────────────────────────────────────────────────────
// TRANSACTION-SAFE TOKEN OPERATIONS
// ────────────────────────────────────────────────────────────────────────────

/**
 * Award tokens to a user with transaction safety
 * Creates entry in tokenHistory sub-collection
 */
export async function awardTokens(userId, amount, reason, metadata = {}) {
  try {
    const userRef = doc(db, 'users', userId);
    
    await runTransaction(db, async (transaction) => {
      const userDoc = await transaction.get(userRef);
      
      if (!userDoc.exists()) {
        throw new Error('User not found');
      }

      const currentTokens = userDoc.data().tokens || 0;
      const newTokens = currentTokens + amount;

      // Update user tokens
      transaction.update(userRef, {
        tokens: newTokens,
        updatedAt: serverTimestamp()
      });

      // Create history entry
      const historyRef = doc(collection(db, 'users', userId, 'tokenHistory'));
      transaction.set(historyRef, {
        amount,
        reason,
        type: 'gain',
        timestamp: serverTimestamp(),
        balanceAfter: newTokens,
        metadata
      });
    });

    // Clean up old history records (keep only 8 most recent)
    // Run this after transaction to avoid conflicts
    setTimeout(() => cleanupTokenHistory(userId), 100);

    return { success: true, message: `Awarded ${amount} tokens` };
  } catch (error) {
    console.error('Error awarding tokens:', error);
    throw error;
  }
}

/**
 * Deduct tokens with transaction safety (prevents double-spending)
 */
export async function deductTokens(userId, amount, reason, metadata = {}) {
  try {
    const userRef = doc(db, 'users', userId);
    
    const result = await runTransaction(db, async (transaction) => {
      const userDoc = await transaction.get(userRef);
      
      if (!userDoc.exists()) {
        throw new Error('User not found');
      }

      const currentTokens = userDoc.data().tokens || 0;
      
      // Anti-cheat: Verify sufficient funds
      if (currentTokens < amount) {
        throw new Error('INSUFFICIENT_TOKENS');
      }

      const newTokens = currentTokens - amount;

      // Update user tokens
      transaction.update(userRef, {
        tokens: newTokens,
        updatedAt: serverTimestamp()
      });

      // Create history entry
      const historyRef = doc(collection(db, 'users', userId, 'tokenHistory'));
      transaction.set(historyRef, {
        amount: -amount,
        reason,
        type: 'spend',
        timestamp: serverTimestamp(),
        balanceAfter: newTokens,
        metadata
      });

      return { newBalance: newTokens };
    });

    // Clean up old history records (keep only 8 most recent)
    setTimeout(() => cleanupTokenHistory(userId), 100);

    return { success: true, newBalance: result.newBalance };
  } catch (error) {
    if (error.message === 'INSUFFICIENT_TOKENS') {
      return { success: false, error: 'Not enough tokens' };
    }
    console.error('Error deducting tokens:', error);
    throw error;
  }
}

// ────────────────────────────────────────────────────────────────────────────
// STORE OPERATIONS
// ────────────────────────────────────────────────────────────────────────────

/**
 * Purchase an item from the store
 */
export async function purchaseItem(userId, itemId, price) {
  try {
    const userRef = doc(db, 'users', userId);
    
    const result = await runTransaction(db, async (transaction) => {
      const userDoc = await transaction.get(userRef);
      
      if (!userDoc.exists()) {
        throw new Error('User not found');
      }

      const currentTokens = userDoc.data().tokens || 0;
      const inventory = userDoc.data().inventory || [];

      // Check if already owned
      if (inventory.includes(itemId)) {
        throw new Error('ALREADY_OWNED');
      }

      // Verify funds
      if (currentTokens < price) {
        throw new Error('INSUFFICIENT_TOKENS');
      }

      const newTokens = currentTokens - price;

      // Update user
      transaction.update(userRef, {
        tokens: newTokens,
        inventory: [...inventory, itemId],
        updatedAt: serverTimestamp()
      });

      // Log transaction
      const historyRef = doc(collection(db, 'users', userId, 'tokenHistory'));
      transaction.set(historyRef, {
        amount: -price,
        reason: `Purchased: ${itemId}`,
        type: 'spend',
        timestamp: serverTimestamp(),
        balanceAfter: newTokens,
        metadata: { itemId, category: 'store_purchase' }
      });

      return { newBalance: newTokens, newInventory: [...inventory, itemId] };
    });

    return { success: true, ...result };
  } catch (error) {
    if (error.message === 'ALREADY_OWNED') {
      return { success: false, error: 'You already own this item' };
    }
    if (error.message === 'INSUFFICIENT_TOKENS') {
      return { success: false, error: 'Not enough tokens' };
    }
    console.error('Error purchasing item:', error);
    throw error;
  }
}

/**
 * Equip an item (set as active profile picture, etc.)
 */
export async function equipItem(userId, itemId, slot = 'profilePic') {
  try {
    const userRef = doc(db, 'users', userId);
    const userDoc = await getDoc(userRef);

    if (!userDoc.exists()) {
      throw new Error('User not found');
    }

    const inventory = userDoc.data().inventory || [];
    
    if (!inventory.includes(itemId)) {
      return { success: false, error: 'Item not owned' };
    }

    // Update equipped item
    await updateDoc(userRef, {
      [`equipped.${slot}`]: itemId,
      updatedAt: serverTimestamp()
    });

    return { success: true };
  } catch (error) {
    console.error('Error equipping item:', error);
    throw error;
  }
}

// ────────────────────────────────────────────────────────────────────────────
// TOKEN HISTORY
// ────────────────────────────────────────────────────────────────────────────

/**
 * Get user's token transaction history
 */
export async function getTokenHistory(userId, limitCount = 8) {
  try {
    const historyRef = collection(db, 'users', userId, 'tokenHistory');
    const q = query(historyRef, orderBy('timestamp', 'desc'), limit(limitCount));
    
    const snapshot = await getDocs(q);
    const history = [];
    
    snapshot.forEach(doc => {
      history.push({
        id: doc.id,
        ...doc.data()
      });
    });

    return history;
  } catch (error) {
    console.error('Error fetching token history:', error);
    return [];
  }
}

/**
 * Clean up old token history records, keeping only the most recent 8
 */
export async function cleanupTokenHistory(userId) {
  try {
    const historyRef = collection(db, 'users', userId, 'tokenHistory');
    
    // Get all records ordered by timestamp (newest first)
    const allRecordsQuery = query(historyRef, orderBy('timestamp', 'desc'));
    const snapshot = await getDocs(allRecordsQuery);
    
    // If we have more than 8 records, delete the oldest ones
    if (snapshot.size > 8) {
      const batch = writeBatch(db);
      let deletedCount = 0;
      
      // Skip the first 8 (newest) and delete the rest
      snapshot.docs.forEach((doc, index) => {
        if (index >= 8) {
          batch.delete(doc.ref);
          deletedCount++;
        }
      });
      
      if (deletedCount > 0) {
        await batch.commit();
        console.log(`Cleaned up ${deletedCount} old token history records for user ${userId}`);
      }
    }
  } catch (error) {
    console.error('Error cleaning up token history:', error);
  }
}

/**
 * Subscribe to real-time token updates
 */
export function subscribeToTokens(userId, callback) {
  const userRef = doc(db, 'users', userId);

  const disableListeners = String(import.meta.env?.VITE_DISABLE_FIRESTORE_LISTENERS ?? '').trim() === '1';
  if (disableListeners) {
    let timer = null;
    const poll = async () => {
      try {
        const snap = await getDoc(userRef);
        if (snap.exists()) {
          const data = snap.data();
          callback({
            tokens: data.tokens || 0,
            inventory: data.inventory || [],
            equipped: data.equipped || {},
          });
        }
      } catch (error) {
        console.error('Error in token polling:', error);
      }
    };
    poll();
    timer = window.setInterval(poll, 15000);
    return () => {
      if (timer) window.clearInterval(timer);
    };
  }

  return onSnapshot(
    userRef,
    (doc) => {
      if (doc.exists()) {
        const data = doc.data();
        callback({
          tokens: data.tokens || 0,
          inventory: data.inventory || [],
          equipped: data.equipped || {},
        });
      }
    },
    (error) => {
      console.error('Error in token subscription:', error);
    },
  );
}

// ────────────────────────────────────────────────────────────────────────────
// ANTI-CHEAT UTILITIES
// ────────────────────────────────────────────────────────────────────────────

/**
 * Check if user can claim a reward (prevents spam/abuse)
 */
export async function canClaimReward(userId, rewardKey) {
  try {
    const cooldownRef = doc(db, 'users', userId, 'rewardCooldowns', rewardKey);
    const cooldownDoc = await getDoc(cooldownRef);

    if (!cooldownDoc.exists()) {
      return { canClaim: true };
    }

    const lastClaimed = cooldownDoc.data().lastClaimed?.toDate();
    const cooldownHours = cooldownDoc.data().cooldownHours || 24;
    
    if (!lastClaimed) {
      return { canClaim: true };
    }

    const hoursSince = (Date.now() - lastClaimed.getTime()) / (1000 * 60 * 60);
    
    if (hoursSince >= cooldownHours) {
      return { canClaim: true };
    }

    const hoursRemaining = Math.ceil(cooldownHours - hoursSince);
    return { 
      canClaim: false, 
      hoursRemaining,
      message: `Please wait ${hoursRemaining}h before claiming again`
    };
  } catch (error) {
    console.error('Error checking reward cooldown:', error);
    return { canClaim: true }; // Fail open
  }
}

/**
 * Record a reward claim with cooldown
 */
export async function recordRewardClaim(userId, rewardKey, cooldownHours = 24) {
  try {
    const cooldownRef = doc(db, 'users', userId, 'rewardCooldowns', rewardKey);
    await setDoc(cooldownRef, {
      lastClaimed: serverTimestamp(),
      cooldownHours,
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Error recording reward claim:', error);
  }
}

/**
 * Record multiple reward claims efficiently in one batch
 */
export async function recordRewardClaimsBatch(userId, rewardKeys = [], cooldownHours = 24) {
  try {
    if (!userId || !Array.isArray(rewardKeys) || rewardKeys.length === 0) return;

    const batch = writeBatch(db);
    rewardKeys.forEach((rewardKey) => {
      const cooldownRef = doc(db, 'users', userId, 'rewardCooldowns', rewardKey);
      batch.set(cooldownRef, {
        lastClaimed: serverTimestamp(),
        cooldownHours,
        updatedAt: serverTimestamp()
      });
    });
    await batch.commit();
  } catch (error) {
    console.error('Error recording reward claims batch:', error);
  }
}

// ────────────────────────────────────────────────────────────────────────────
// INITIALIZATION
// ────────────────────────────────────────────────────────────────────────────

/**
 * Initialize token system for new user
 */
export async function initializeUserTokens(userId, initialTokens = 100) {
  try {
    const userRef = doc(db, 'users', userId);
    
    await updateDoc(userRef, {
      tokens: initialTokens,
      inventory: [],
      equipped: {},
      updatedAt: serverTimestamp()
    });

    // Create welcome token entry
    const historyRef = doc(collection(db, 'users', userId, 'tokenHistory'));
    await setDoc(historyRef, {
      amount: initialTokens,
      reason: 'Welcome to ChemLeung! 🎉',
      type: 'gain',
      timestamp: serverTimestamp(),
      balanceAfter: initialTokens,
      metadata: { category: 'welcome_bonus' }
    });

    // Clean up old history records (keep only 8 most recent)
    setTimeout(() => cleanupTokenHistory(userId), 100);

    return { success: true };
  } catch (error) {
    console.error('Error initializing tokens:', error);
    throw error;
  }
}

===== FILE: src/contexts/AuthContext.jsx =====

import React, { createContext, useState, useEffect, useContext, useRef } from 'react';
import { 
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  updateProfile
} from 'firebase/auth';
import { doc, setDoc, getDoc, onSnapshot } from 'firebase/firestore';
import { auth, db } from '../firebase/config';
import { initializeUserTokens } from '../services/tokenService';

const AuthContext = createContext({
  currentUser: null,
  userProfile: null,
  profileError: null,
  signup: async () => {
    throw new Error('AuthProvider not mounted');
  },
  login: async () => {
    throw new Error('AuthProvider not mounted');
  },
  logout: async () => {},
  loadUserProfile: async () => {},
});

export function useAuth() {
  return useContext(AuthContext) || { currentUser: null, userProfile: null, profileError: null };
}

export function AuthProvider({ children }) {
  const [currentUser, setCurrentUser] = useState(null);
  const [userProfile, setUserProfile] = useState(null);
  const [profileError, setProfileError] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Real-time listener cleanup ref
  const profileUnsubscribeRef = useRef(null);

  // Register new user
  async function signup(email, password, displayName) {
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    
    // Update profile with display name
    await updateProfile(userCredential.user, {
      displayName: displayName
    });

    // Create user profile in Firestore with token initialization
    await setDoc(doc(db, 'users', userCredential.user.uid), {
      uid: userCredential.user.uid,
      email: email,
      displayName: displayName,
      gender: 'boy',
      createdAt: new Date().toISOString(),
      totalAttempts: 0,
      totalQuestions: 0,
      totalCorrect: 0,
      tokens: 100,        // Initial token balance
      inventory: [],      // Owned items
      equipped: {}        // Currently equipped items
    });

    // Initialize token system (creates welcome bonus entry)
    await initializeUserTokens(userCredential.user.uid, 100);

    return userCredential;
  }

  // Login user
  function login(email, password) {
    return signInWithEmailAndPassword(auth, email, password);
  }

  // Logout user
  function logout() {
    // Clean up real-time listener
    if (profileUnsubscribeRef.current) {
      profileUnsubscribeRef.current();
      profileUnsubscribeRef.current = null;
    }
    return signOut(auth);
  }

  // Load user profile with REAL-TIME synchronization
  function setupProfileListener(uid) {
    // Clean up existing listener
    if (profileUnsubscribeRef.current) {
      profileUnsubscribeRef.current();
    }

    const disableListeners = String(import.meta.env?.VITE_DISABLE_FIRESTORE_LISTENERS ?? '')
      .trim() === '1';

    const docRef = doc(db, 'users', uid);
    
    if (disableListeners) {
      let timer = null;
      const poll = async () => {
        try {
          const docSnap = await getDoc(docRef);
          setProfileError(null);
          if (docSnap.exists()) {
            const data = docSnap.data();
            setUserProfile(data);
          } else {
            setUserProfile(null);
          }
        } catch (error) {
          setProfileError(error);
        }
      };
      poll();
      timer = window.setInterval(poll, 15000);
      const unsubscribe = () => {
        if (timer) window.clearInterval(timer);
      };
      profileUnsubscribeRef.current = unsubscribe;
      return unsubscribe;
    }

    // Set up real-time listener
    const unsubscribe = onSnapshot(
      docRef,
      (docSnap) => {
        setProfileError(null);
        if (docSnap.exists()) {
          const data = docSnap.data();
          console.log('📊 Profile updated:', {
            tokens: data.tokens,
            inventory: data.inventory?.length || 0,
          });
          setUserProfile(data);
        } else {
          console.error('❌ User profile not found');
          setUserProfile(null);
        }
      },
      (error) => {
        console.error('❌ Profile listener error:', error);
        setProfileError(error);
        loadUserProfile(uid);
      },
    );

    profileUnsubscribeRef.current = unsubscribe;
    return unsubscribe;
  }

  // Legacy: Load profile once (for backwards compatibility)
  async function loadUserProfile(uid) {
    try {
      const docRef = doc(db, 'users', uid);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        setProfileError(null);
        setUserProfile(docSnap.data());
      }
    } catch (error) {
      setProfileError(error);
      console.error('Error loading profile:', error);
    }
  }

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      setCurrentUser(user);
      
      if (user) {
        // Set up real-time profile listener
        setupProfileListener(user.uid);
      } else {
        setUserProfile(null);
        setProfileError(null);
        // Clean up listener
        if (profileUnsubscribeRef.current) {
          profileUnsubscribeRef.current();
          profileUnsubscribeRef.current = null;
        }
      }
      
      setLoading(false);
    });

    return () => {
      unsubscribe();
      // Clean up listener on unmount
      if (profileUnsubscribeRef.current) {
        profileUnsubscribeRef.current();
      }
    };
  }, []);

  const value = {
    currentUser,
    userProfile,
    profileError,
    signup,
    login,
    logout,
    loadUserProfile  // Keep for backwards compatibility
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
}

===== FILE: src/components/TokenLog.jsx =====

// ============================================================================
// TOKEN LOG - Transaction History
// ============================================================================

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useLanguage } from '../contexts/LanguageContext';
import { getTokenHistory } from '../services/tokenService';
import { ArrowLeft, TrendingUp, TrendingDown, Clock, Filter, Gem } from 'lucide-react';

export default function TokenLog() {
  const navigate = useNavigate();
  const { currentUser } = useAuth();
  const { t, tf, isEnglish } = useLanguage();
  const [history, setHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('all'); // all | gains | spends

  useEffect(() => {
    loadHistory();
  }, [currentUser]);

  async function loadHistory() {
    if (!currentUser) return;
    
    setLoading(true);
    try {
      const data = await getTokenHistory(currentUser.uid, 8);
      setHistory(data);
    } catch (error) {
      console.error('Error loading token history:', error);
    }
    setLoading(false);
  }

  const formatTimeAgo = (timestamp) => {
    if (!timestamp) return t('tokenLog.unknown');
    
    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return t('forum.justNow');
    if (diffMins < 60) return tf('forum.timeAgoMinutesShort', { count: diffMins });
    if (diffHours < 24) return tf('forum.timeAgoHoursShort', { count: diffHours });
    if (diffDays < 7) return tf('forum.timeAgoDaysShort', { count: diffDays });
    
    return date.toLocaleDateString(isEnglish ? 'en-GB' : 'zh-HK', { 
      timeZone: 'Asia/Hong_Kong',
      day: '2-digit', 
      month: 'short', 
      year: 'numeric' 
    });
  };

  const filteredHistory = history.filter(entry => {
    if (filter === 'gains') return entry.type === 'gain';
    if (filter === 'spends') return entry.type === 'spend';
    return true;
  });

  // Calculate totals
  const totalGained = history
    .filter(e => e.type === 'gain')
    .reduce((sum, e) => sum + e.amount, 0);
  
  const totalSpent = history
    .filter(e => e.type === 'spend')
    .reduce((sum, e) => sum + Math.abs(e.amount), 0);

  return (
    <div className="max-w-4xl mx-auto space-y-6">
      {/* Header */}
      <div className="flex items-center gap-4">
        <button
          onClick={() => navigate('/dashboard')}
          className="p-3 bg-white rounded-lg border-2 border-slate-200 hover:border-lab-blue transition-all"
        >
          <ArrowLeft size={20} />
        </button>
        
        <div className="flex-1 bg-gradient-to-r from-amber-500 to-orange-600 rounded-2xl shadow-xl p-6 text-white">
          <h1 className="text-3xl font-black flex items-center gap-3">
            <Clock size={32} />
            {t('tokenLog.title')}
          </h1>
          <p className="text-orange-100 mt-1">
            {t('tokenLog.subtitle')}
          </p>
        </div>
      </div>

      {/* Stats Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="bg-white rounded-xl shadow-lg border-2 border-green-200 p-6">
          <div className="flex items-center gap-3 mb-2">
            <div className="p-3 bg-green-100 rounded-lg">
              <TrendingUp className="text-green-600" size={24} />
            </div>
            <div>
              <div className="text-sm font-semibold text-slate-600">{t('tokenLog.totalEarned')}</div>
              <div className="text-3xl font-black text-green-600 flex items-center gap-2">
                <Gem size={24} fill="currentColor" />
                {totalGained}
              </div>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-xl shadow-lg border-2 border-red-200 p-6">
          <div className="flex items-center gap-3 mb-2">
            <div className="p-3 bg-red-100 rounded-lg">
              <TrendingDown className="text-red-600" size={24} />
            </div>
            <div>
              <div className="text-sm font-semibold text-slate-600">{t('tokenLog.totalSpent')}</div>
              <div className="text-3xl font-black text-red-600 flex items-center gap-2">
                <Gem size={24} fill="currentColor" />
                {totalSpent}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Filters */}
      <div className="bg-white rounded-xl shadow-lg border-2 border-slate-200 p-4">
        <div className="flex items-center gap-3">
          <Filter size={18} className="text-slate-600" />
          <div className="flex gap-2">
            {[
              { value: 'all', label: t('tokenLog.allTransactions') },
              { value: 'gains', label: t('tokenLog.gains') },
              { value: 'spends', label: t('tokenLog.spends') }
            ].map(opt => (
              <button
                key={opt.value}
                onClick={() => setFilter(opt.value)}
                className={`px-4 py-2 rounded-lg font-bold text-sm transition-all ${
                  filter === opt.value
                    ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white'
                    : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                }`}
              >
                {opt.label}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Transaction List */}
      <div className="bg-white rounded-2xl shadow-xl border-2 border-slate-200 overflow-hidden">
        <div className="bg-slate-50 p-4 border-b-2 border-slate-200">
          <h2 className="text-lg font-bold text-slate-800">
            {tf('tokenLog.recentTransactionsCount', { count: filteredHistory.length })}
          </h2>
        </div>

        <div className="divide-y divide-slate-100">
          {loading ? (
            <div className="flex justify-center py-12">
              <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-lab-blue"></div>
            </div>
          ) : filteredHistory.length === 0 ? (
            <div className="text-center py-12">
              <Clock className="w-16 h-16 text-slate-300 mx-auto mb-4" />
              <p className="text-slate-400 text-lg">
                {filter === 'all' 
                  ? t('tokenLog.noTransactionsYet')
                  : (filter === 'gains' ? t('tokenLog.noEarningsYet') : t('tokenLog.noPurchasesYet'))
                }
              </p>
              <p className="text-slate-500 text-sm mt-2">
                {t('tokenLog.completeQuizzesToEarn')}
              </p>
            </div>
          ) : (
            filteredHistory.map((entry, index) => {
              const isGain = entry.type === 'gain';
              const amount = Math.abs(entry.amount);

              return (
                <div
                  key={entry.id || index}
                  className="p-4 hover:bg-slate-50 transition-all"
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4 flex-1">
                      {/* Icon */}
                      <div className={`p-3 rounded-lg ${
                        isGain ? 'bg-green-100' : 'bg-red-100'
                      }`}>
                        {isGain ? (
                          <TrendingUp className="text-green-600" size={20} />
                        ) : (
                          <TrendingDown className="text-red-600" size={20} />
                        )}
                      </div>

                      {/* Details */}
                      <div className="flex-1 min-w-0">
                        <div className="font-bold text-slate-800 mb-1">
                          {entry.reason}
                        </div>
                        <div className="text-sm text-slate-500 flex items-center gap-2">
                          <Clock size={12} />
                          {formatTimeAgo(entry.timestamp)}
                          {entry.metadata?.category && (
                            <>
                              <span>•</span>
                              <span className="capitalize">
                                {entry.metadata.category.replace('_', ' ')}
                              </span>
                            </>
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Amount */}
                    <div className="flex items-center gap-2">
                      <div className={`text-2xl font-black ${
                        isGain ? 'text-green-600' : 'text-red-600'
                      }`}>
                        {isGain ? '+' : '-'}{amount}
                      </div>
                      <Gem 
                        size={20} 
                        className={isGain ? 'text-green-600' : 'text-red-600'}
                        fill="currentColor"
                      />
                    </div>
                  </div>

                  {/* Balance After */}
                  {entry.balanceAfter !== undefined && (
                    <div className="mt-2 text-xs text-slate-400 text-right">
                      {tf('tokenLog.balanceAfterTokens', { balance: entry.balanceAfter })}
                    </div>
                  )}
                </div>
              );
            })
          )}
        </div>
      </div>
    </div>
  );
}