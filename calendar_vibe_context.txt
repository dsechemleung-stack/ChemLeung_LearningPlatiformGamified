
--- START OF FILE: src/services/calendarService.js ---
import { doc, setDoc, collection, addDoc, updateDoc, deleteDoc, query, where, getDocs, writeBatch } from 'firebase/firestore';
import { db } from '../firebase/config';

/**
 * Calendar Service - Manages user events, exams, quizzes, and auto-generated study plans
 */

export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  SPACED_REPETITION: 'spaced_repetition',
  COMPLETION_LOG: 'completion_log'
};

export const calendarService = {
  /**
   * Add a major exam event
   */
  async addMajorExam(userId, examData) {
    try {
      const { date, topic, subtopic, title } = examData;
      
      // Create the exam event
      const examRef = await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.MAJOR_EXAM,
        date: new Date(date).toISOString().split('T')[0],
        topic: topic || null,
        subtopic: subtopic || null,
        title: title || 'Major Exam',
        createdAt: new Date().toISOString(),
        completed: false
      });

      // Generate study plan (10-7 days, 6-4 days, 3-1 days)
      await this.generateMajorExamStudyPlan(userId, examRef.id, date, topic, subtopic);

      return examRef.id;
    } catch (error) {
      console.error('Error adding major exam:', error);
      throw error;
    }
  },

  /**
   * Add a small quiz event
   */
  async addSmallQuiz(userId, quizData) {
    try {
      const { date, topic, subtopic, title } = quizData;
      
      // Create the quiz event
      const quizRef = await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.SMALL_QUIZ,
        date: new Date(date).toISOString().split('T')[0],
        topic: topic || null,
        subtopic: subtopic || null,
        title: title || 'Quiz',
        createdAt: new Date().toISOString(),
        completed: false
      });

      // Generate study plan (3 days, 2 days, 1 day)
      await this.generateSmallQuizStudyPlan(userId, quizRef.id, date, topic, subtopic);

      return quizRef.id;
    } catch (error) {
      console.error('Error adding small quiz:', error);
      throw error;
    }
  },

  /**
   * Generate study plan for major exam
   * 10-7 days: 10 MCQs/day (Warm-up)
   * 6-4 days: 20 MCQs/day (Consolidation)
   * 3-1 days: 40 MCQs/day (Sprint)
   */
  async generateMajorExamStudyPlan(userId, examId, examDate, topic, subtopic) {
    const batch = writeBatch(db);
    const examDateObj = new Date(examDate);
    const suggestions = [];

    // Phase 1: Warm-up (10-7 days before)
    for (let daysBeforeExam = 10; daysBeforeExam >= 7; daysBeforeExam--) {
      const studyDate = new Date(examDateObj);
      studyDate.setDate(studyDate.getDate() - daysBeforeExam);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: 10,
        phase: 'warm-up',
        linkedEventId: examId,
        linkedEventType: EVENT_TYPES.MAJOR_EXAM,
        title: `Warm-up: 10 MCQs${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false
      });
    }

    // Phase 2: Consolidation (6-4 days before)
    for (let daysBeforeExam = 6; daysBeforeExam >= 4; daysBeforeExam--) {
      const studyDate = new Date(examDateObj);
      studyDate.setDate(studyDate.getDate() - daysBeforeExam);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: 20,
        phase: 'consolidation',
        linkedEventId: examId,
        linkedEventType: EVENT_TYPES.MAJOR_EXAM,
        title: `Consolidation: 20 MCQs${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false
      });
    }

    // Phase 3: Sprint (3-1 days before)
    for (let daysBeforeExam = 3; daysBeforeExam >= 1; daysBeforeExam--) {
      const studyDate = new Date(examDateObj);
      studyDate.setDate(studyDate.getDate() - daysBeforeExam);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: 40,
        phase: 'sprint',
        linkedEventId: examId,
        linkedEventType: EVENT_TYPES.MAJOR_EXAM,
        title: `Sprint: 40 MCQs${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false
      });
    }

    await batch.commit();
  },

  /**
   * Generate study plan for small quiz
   * 3 days: 5 MCQs (Initial Review)
   * 2 days: 10 MCQs (Topic Focus)
   * 1 day: 15 MCQs + Mistake Review (Final Polish)
   */
  async generateSmallQuizStudyPlan(userId, quizId, quizDate, topic, subtopic) {
    const batch = writeBatch(db);
    const quizDateObj = new Date(quizDate);

    const plan = [
      { days: 3, count: 5, phase: 'initial-review', title: 'Initial Review: 5 MCQs' },
      { days: 2, count: 10, phase: 'topic-focus', title: 'Topic Focus: 10 MCQs' },
      { days: 1, count: 15, phase: 'final-polish', title: 'Final Polish: 15 MCQs + Mistakes' }
    ];

    for (const { days, count, phase, title } of plan) {
      const studyDate = new Date(quizDateObj);
      studyDate.setDate(studyDate.getDate() - days);
      
      const ref = doc(collection(db, 'calendar_events'));
      batch.set(ref, {
        userId,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: studyDate.toISOString().split('T')[0],
        topic,
        subtopic,
        questionCount: count,
        phase,
        linkedEventId: quizId,
        linkedEventType: EVENT_TYPES.SMALL_QUIZ,
        title: `${title}${topic ? ` - ${topic}` : ''}`,
        createdAt: new Date().toISOString(),
        completed: false,
        includeMistakes: phase === 'final-polish'
      });
    }

    await batch.commit();
  },

  /**
   * Schedule spaced repetition for a mistake
   * Uses Ebbinghaus intervals: 1 day, 3 days, 7 days, 14 days
   */
  async scheduleSpacedRepetition(userId, mistakeData) {
    try {
      const { questionId, topic, subtopic, attemptCount } = mistakeData;
      
      // Determine interval based on attempt count
      const intervals = [1, 3, 7, 14, 30]; // days
      const intervalIndex = Math.min(attemptCount - 1, intervals.length - 1);
      const daysUntilReview = intervals[intervalIndex];

      const reviewDate = new Date();
      reviewDate.setDate(reviewDate.getDate() + daysUntilReview);

      // Check if a spaced repetition already exists for this question on this date
      const existingQuery = query(
        collection(db, 'calendar_events'),
        where('userId', '==', userId),
        where('type', '==', EVENT_TYPES.SPACED_REPETITION),
        where('questionId', '==', questionId),
        where('date', '==', reviewDate.toISOString().split('T')[0])
      );
      
      const existingDocs = await getDocs(existingQuery);
      
      if (existingDocs.empty) {
        // Create new spaced repetition event
        await addDoc(collection(db, 'calendar_events'), {
          userId,
          type: EVENT_TYPES.SPACED_REPETITION,
          date: reviewDate.toISOString().split('T')[0],
          questionId,
          topic,
          subtopic,
          attemptCount,
          interval: daysUntilReview,
          title: `Review: ${topic}${subtopic ? ` - ${subtopic}` : ''}`,
          createdAt: new Date().toISOString(),
          completed: false
        });
      }

      return reviewDate.toISOString().split('T')[0];
    } catch (error) {
      console.error('Error scheduling spaced repetition:', error);
      throw error;
    }
  },

  /**
   * Log completion of a study session
   */
  async logCompletion(userId, date, sessionData) {
    try {
      const { type, topic, questionCount, correctCount } = sessionData;
      
      await addDoc(collection(db, 'calendar_events'), {
        userId,
        type: EVENT_TYPES.COMPLETION_LOG,
        date: new Date(date).toISOString().split('T')[0],
        sessionType: type,
        topic,
        questionCount,
        correctCount,
        accuracy: correctCount / questionCount,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('Error logging completion:', error);
      throw error;
    }
  },

  /**
   * Mark an event as completed
   */
  async markEventCompleted(eventId) {
    try {
      const eventRef = doc(db, 'calendar_events', eventId);
      await updateDoc(eventRef, {
        completed: true,
        completedAt: new Date().toISOString()
      });
    } catch (error) {
      console.error('Error marking event completed:', error);
      throw error;
    }
  },

  /**
   * Get all events for a user in a date range
   */
  async getUserEvents(userId, startDate, endDate) {
    try {
      const q = query(
        collection(db, 'calendar_events'),
        where('userId', '==', userId),
        where('date', '>=', startDate),
        where('date', '<=', endDate)
      );
      
      const querySnapshot = await getDocs(q);
      const events = [];
      
      querySnapshot.forEach((doc) => {
        events.push({ id: doc.id, ...doc.data() });
      });
      
      return events;
    } catch (error) {
      console.error('Error getting user events:', error);
      throw error;
    }
  },

  /**
   * Delete an event (and optionally its linked study suggestions)
   */
  async deleteEvent(eventId, deleteLinkedEvents = true) {
    try {
      const eventRef = doc(db, 'calendar_events', eventId);
      
      if (deleteLinkedEvents) {
        // Find and delete linked events
        const linkedQuery = query(
          collection(db, 'calendar_events'),
          where('linkedEventId', '==', eventId)
        );
        
        const linkedDocs = await getDocs(linkedQuery);
        const batch = writeBatch(db);
        
        linkedDocs.forEach((doc) => {
          batch.delete(doc.ref);
        });
        
        batch.delete(eventRef);
        await batch.commit();
      } else {
        await deleteDoc(eventRef);
      }
    } catch (error) {
      console.error('Error deleting event:', error);
      throw error;
    }
  },

  /**
   * Get events grouped by date for calendar display
   */
  async getCalendarData(userId, year, month) {
    try {
      const startDate = new Date(year, month, 1).toISOString().split('T')[0];
      const endDate = new Date(year, month + 1, 0).toISOString().split('T')[0];
      
      const events = await this.getUserEvents(userId, startDate, endDate);
      
      // Group events by date
      const calendar = {};
      
      events.forEach(event => {
        if (!calendar[event.date]) {
          calendar[event.date] = {
            exams: [],
            quizzes: [],
            suggestions: [],
            repetitions: [],
            completions: []
          };
        }
        
        switch (event.type) {
          case EVENT_TYPES.MAJOR_EXAM:
            calendar[event.date].exams.push(event);
            break;
          case EVENT_TYPES.SMALL_QUIZ:
            calendar[event.date].quizzes.push(event);
            break;
          case EVENT_TYPES.STUDY_SUGGESTION:
            calendar[event.date].suggestions.push(event);
            break;
          case EVENT_TYPES.SPACED_REPETITION:
            calendar[event.date].repetitions.push(event);
            break;
          case EVENT_TYPES.COMPLETION_LOG:
            calendar[event.date].completions.push(event);
            break;
        }
      });
      
      return calendar;
    } catch (error) {
      console.error('Error getting calendar data:', error);
      throw error;
    }
  }
};
--- END OF FILE: src/services/calendarService.js ---


--- START OF FILE: src/utils/calendarEventManager.js ---
/**
 * Calendar Event Manager (Merged)
 * Combines user-specific storage with spaced repetition and event management
 */

import { auth } from '../firebase/config';

// Event Types
export const EVENT_TYPES = {
  MAJOR_EXAM: 'major_exam',
  SMALL_QUIZ: 'small_quiz',
  STUDY_SUGGESTION: 'study_suggestion',
  MISTAKE_REVIEW: 'mistake_review',
  COMPLETED_ACTIVITY: 'completed_activity',
};

// Event Icons
export const EVENT_ICONS = {
  [EVENT_TYPES.MAJOR_EXAM]: 'ðŸš©',
  [EVENT_TYPES.SMALL_QUIZ]: 'âœï¸',
  [EVENT_TYPES.STUDY_SUGGESTION]: 'ðŸ’¡',
  [EVENT_TYPES.MISTAKE_REVIEW]: 'ðŸ§ ',
  [EVENT_TYPES.COMPLETED_ACTIVITY]: 'âœ…',
};

/**
 * Get user-specific storage key (Firebase auth aware)
 */
function getUserStorageKey(suffix) {
  const user = auth.currentUser;
  if (!user) return `studyCalendar_guest_${suffix}`;
  return `studyCalendar_${user.uid}_${suffix}`;
}

/**
 * Load calendar data from localStorage (user-specific)
 */
export function loadCalendarData() {
  try {
    const data = localStorage.getItem(getUserStorageKey('data'));
    return data ? JSON.parse(data) : { events: [], completedSessions: {} };
  } catch (error) {
    console.error('Error loading calendar data:', error);
    return { events: [], completedSessions: {} };
  }
}

/**
 * Save calendar data to localStorage (user-specific)
 */
export function saveCalendarData(data) {
  try {
    localStorage.setItem(getUserStorageKey('data'), JSON.stringify(data));
    // Trigger storage event for cross-component updates
    window.dispatchEvent(new Event('calendar-update'));
  } catch (error) {
    console.error('Error saving calendar data:', error);
  }
}

/**
 * Get all calendar events
 */
export function getCalendarEvents() {
  const data = loadCalendarData();
  return data.events || [];
}

/**
 * Save calendar events
 */
export function saveCalendarEvents(events) {
  const data = loadCalendarData();
  data.events = events;
  saveCalendarData(data);
}

/**
 * Calculate spaced repetition interval based on mistake improvement count
 * Uses SM-2 inspired algorithm with mistake-specific adjustments
 */
export function calculateSpacedRepetitionDate(mistake) {
  const now = new Date();
  const improvementCount = mistake.improvementCount || 0;
  
  // Spaced repetition intervals (in days)
  const intervals = {
    0: 1,   // First review: next day
    1: 3,   // Second review: 3 days later
    2: 7,   // Third review: 1 week later
    3: 14,  // Mastered but reinforce: 2 weeks
  };
  
  const daysToAdd = intervals[improvementCount] || 14;
  const reviewDate = new Date(now);
  reviewDate.setDate(reviewDate.getDate() + daysToAdd);
  
  return reviewDate.toISOString().split('T')[0];
}

/**
 * Generate study suggestions based on exam date and topic
 * Returns array of suggestion events with scaled MCQ counts
 */
export function generateExamPrepSuggestions(examDate, topic, subtopic = null) {
  const exam = new Date(examDate);
  const suggestions = [];
  
  // Major Exam Scaling Algorithm
  const prepSchedule = [
    { daysBeforeStart: 10, daysBeforeEnd: 7, mcqCount: 10, phase: 'Warm-up' },
    { daysBeforeStart: 6, daysBeforeEnd: 4, mcqCount: 20, phase: 'Consolidation' },
    { daysBeforeStart: 3, daysBeforeEnd: 1, mcqCount: 40, phase: 'Sprint' },
  ];
  
  prepSchedule.forEach(({ daysBeforeStart, daysBeforeEnd, mcqCount, phase }) => {
    for (let day = daysBeforeStart; day >= daysBeforeEnd; day--) {
      const suggestionDate = new Date(exam);
      suggestionDate.setDate(suggestionDate.getDate() - day);
      
      suggestions.push({
        id: `prep_${topic}_${day}`,
        type: EVENT_TYPES.STUDY_SUGGESTION,
        date: suggestionDate.toISOString().split('T')[0],
        title: `${phase} - ${mcqCount} MCQs`,
        description: `Practice ${mcqCount} questions on ${topic}`,
        topic,
        subtopic,
        mcqCount,
        phase,
        linkedExamId: examDate,
      });
    }
  });
  
  return suggestions;
}

/**
 * Generate quiz prep suggestions (smaller scale)
 */
export function generateQuizPrepSuggestions(quizDate, topic, subtopic) {
  const quiz = new Date(quizDate);
  const suggestions = [];
  
  // Small Quiz: 3-1 days before with 5-15 MCQs on subtopic
  for (let day = 3; day >= 1; day--) {
    const suggestionDate = new Date(quiz);
    suggestionDate.setDate(suggestionDate.getDate() - day);
    
    const mcqCount = day === 1 ? 15 : (day === 2 ? 10 : 5);
    
    suggestions.push({
      id: `quiz_prep_${subtopic}_${day}`,
      type: EVENT_TYPES.STUDY_SUGGESTION,
      date: suggestionDate.toISOString().split('T')[0],
      title: `Quiz Prep - ${mcqCount} MCQs`,
      description: `Review ${mcqCount} questions on ${subtopic}`,
      topic,
      subtopic,
      mcqCount,
      linkedQuizId: quizDate,
    });
  }
  
  return suggestions;
}

/**
 * Add a new event (exam or quiz)
 */
export function addCalendarEvent(event) {
  const events = getCalendarEvents();
  
  // Add the main event
  events.push({
    ...event,
    id: event.id || `${event.type}_${Date.now()}`,
    createdAt: new Date().toISOString(),
  });
  
  // Generate prep suggestions if it's an exam or quiz
  if (event.type === EVENT_TYPES.MAJOR_EXAM) {
    const suggestions = generateExamPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  } else if (event.type === EVENT_TYPES.SMALL_QUIZ) {
    const suggestions = generateQuizPrepSuggestions(event.date, event.topic, event.subtopic);
    events.push(...suggestions);
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Delete an event and its associated suggestions
 */
export function deleteCalendarEvent(eventId) {
  const events = getCalendarEvents();
  const filtered = events.filter(e => 
    e.id !== eventId && 
    e.linkedExamId !== eventId && 
    e.linkedQuizId !== eventId
  );
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Mark event as completed
 */
export function completeCalendarEvent(eventId, completedData = {}) {
  const events = getCalendarEvents();
  const event = events.find(e => e.id === eventId);
  
  if (event) {
    // Mark original as completed
    event.completed = true;
    event.completedAt = new Date().toISOString();
    event.completedData = completedData;
    
    // Add completion badge
    events.push({
      id: `completed_${eventId}`,
      type: EVENT_TYPES.COMPLETED_ACTIVITY,
      date: event.date,
      title: `âœ… ${event.title}`,
      description: `Completed: ${event.description}`,
      parentEventId: eventId,
    });
  }
  
  saveCalendarEvents(events);
  return events;
}

/**
 * Schedule mistake review based on spaced repetition
 */
export function scheduleMistakeReview(mistake) {
  const events = getCalendarEvents();
  const reviewDate = calculateSpacedRepetitionDate(mistake);
  
  // Remove old review for this mistake
  const filtered = events.filter(e => 
    !(e.type === EVENT_TYPES.MISTAKE_REVIEW && e.mistakeId === mistake.ID)
  );
  
  // Add new review
  filtered.push({
    id: `review_${mistake.ID}_${Date.now()}`,
    type: EVENT_TYPES.MISTAKE_REVIEW,
    date: reviewDate,
    title: `Review Mistake`,
    description: `${mistake.Topic} â†’ ${mistake.Subtopic}`,
    topic: mistake.Topic,
    subtopic: mistake.Subtopic,
    mistakeId: mistake.ID,
    improvementCount: mistake.improvementCount || 0,
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Batch schedule mistake reviews for all active mistakes
 */
export function batchScheduleMistakeReviews(mistakes) {
  const events = getCalendarEvents();
  
  // Remove all existing mistake reviews
  const filtered = events.filter(e => e.type !== EVENT_TYPES.MISTAKE_REVIEW);
  
  // Add new reviews for all mistakes
  mistakes.forEach(mistake => {
    const reviewDate = calculateSpacedRepetitionDate(mistake);
    
    filtered.push({
      id: `review_${mistake.ID}_${Date.now()}`,
      type: EVENT_TYPES.MISTAKE_REVIEW,
      date: reviewDate,
      title: `Review Mistake`,
      description: `${mistake.Topic}${mistake.Subtopic ? ` â†’ ${mistake.Subtopic}` : ''}`,
      topic: mistake.Topic,
      subtopic: mistake.Subtopic,
      mistakeId: mistake.ID,
      improvementCount: mistake.improvementCount || 0,
    });
  });
  
  saveCalendarEvents(filtered);
  return filtered;
}

/**
 * Get events for a specific date
 */
export function getEventsForDate(dateStr) {
  const events = getCalendarEvents();
  return events.filter(e => e.date === dateStr && !e.completed);
}

/**
 * Get events for a date range
 */
export function getEventsForDateRange(startDate, endDate) {
  const events = getCalendarEvents();
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  return events.filter(e => {
    const eventDate = new Date(e.date);
    return eventDate >= start && eventDate <= end && !e.completed;
  });
}

/**
 * Get events in range (alias for compatibility)
 */
export function getEventsInRange(startDate, endDate) {
  return getEventsForDateRange(startDate, endDate);
}

/**
 * Get upcoming events (next 7 days)
 */
export function getUpcomingEvents(days = 7) {
  const today = new Date();
  const future = new Date();
  future.setDate(future.getDate() + days);
  
  return getEventsForDateRange(
    today.toISOString().split('T')[0],
    future.toISOString().split('T')[0]
  ).sort((a, b) => new Date(a.date) - new Date(b.date));
}

/**
 * Add completed session to calendar
 */
export function addCompletedSession(date, sessionType, details = {}) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  
  if (!calendarData.completedSessions[dateStr]) {
    calendarData.completedSessions[dateStr] = [];
  }
  
  calendarData.completedSessions[dateStr].push({
    type: sessionType,
    timestamp: new Date().toISOString(),
    ...details
  });
  
  saveCalendarData(calendarData);
}

/**
 * Get completed sessions for a specific date
 */
export function getCompletedSessions(date) {
  const calendarData = loadCalendarData();
  const dateStr = date.toISOString().split('T')[0];
  return calendarData.completedSessions[dateStr] || [];
}

/**
 * Remove event from calendar (alias for compatibility)
 */
export function removeCalendarEvent(eventId) {
  return deleteCalendarEvent(eventId);
}

/**
 * Clear old data (older than 6 months)
 */
export function clearOldCalendarData() {
  const calendarData = loadCalendarData();
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  
  // Filter old events
  calendarData.events = calendarData.events.filter(event => 
    new Date(event.date) >= sixMonthsAgo
  );
  
  // Filter old completed sessions
  Object.keys(calendarData.completedSessions).forEach(dateStr => {
    if (new Date(dateStr) < sixMonthsAgo) {
      delete calendarData.completedSessions[dateStr];
    }
  });
  
  saveCalendarData(calendarData);
}
--- END OF FILE: src/utils/calendarEventManager.js ---


--- START OF FILE: src/utils/storeItems.js ---
// ============================================================================
// STORE ITEMS - ChemStore Catalog
// ============================================================================

export const STORE_ITEMS = {
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PROFILE PICTURES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  profilePics: [
    {
      id: 'flask_blue',
      name: 'Blue Flask',
      description: 'Classic chemistry icon',
      price: 0,
      icon: 'ðŸ§ª',
      rarity: 'common',
      category: 'profilePic'
    },
    {
      id: 'atom_green',
      name: 'Green Atom',
      description: 'Atomic structure design',
      price: 50,
      icon: 'âš›ï¸',
      rarity: 'common',
      category: 'profilePic'
    },
    {
      id: 'molecule',
      name: 'Molecule Master',
      description: 'For molecular enthusiasts',
      price: 100,
      icon: 'ðŸ”¬',
      rarity: 'uncommon',
      category: 'profilePic'
    },
    {
      id: 'fire',
      name: 'Combustion King',
      description: 'Exothermic reactions only',
      price: 150,
      icon: 'ðŸ”¥',
      rarity: 'uncommon',
      category: 'profilePic'
    },
    {
      id: 'lightning',
      name: 'Electrochemist',
      description: 'Charged with energy',
      price: 200,
      icon: 'âš¡',
      rarity: 'rare',
      category: 'profilePic'
    },
    {
      id: 'crystal',
      name: 'Crystal Scholar',
      description: 'Perfectly structured',
      price: 250,
      icon: 'ðŸ’Ž',
      rarity: 'rare',
      category: 'profilePic'
    },
    {
      id: 'explosion',
      name: 'Reaction Expert',
      description: 'Explosive personality',
      price: 300,
      icon: 'ðŸ’¥',
      rarity: 'epic',
      category: 'profilePic'
    },
    {
      id: 'star',
      name: 'Chemistry Star',
      description: 'Shine bright like neon',
      price: 400,
      icon: 'â­',
      rarity: 'epic',
      category: 'profilePic'
    },
    {
      id: 'crown',
      name: 'Noble Gas King',
      description: 'Unreactive royalty',
      price: 500,
      icon: 'ðŸ‘‘',
      rarity: 'legendary',
      category: 'profilePic'
    },
    {
      id: 'trophy',
      name: 'Grand Master',
      description: 'Ultimate achievement',
      price: 1000,
      icon: 'ðŸ†',
      rarity: 'legendary',
      category: 'profilePic'
    }
  ],

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BADGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  badges: [
    {
      id: 'beginner',
      name: 'Beginner Badge',
      description: 'Your first steps',
      price: 0,
      icon: 'ðŸŽ–ï¸',
      rarity: 'common',
      category: 'badge'
    },
    {
      id: 'scholar',
      name: 'Scholar Badge',
      description: '100 questions solved',
      price: 200,
      icon: 'ðŸ“š',
      rarity: 'uncommon',
      category: 'badge'
    },
    {
      id: 'expert',
      name: 'Expert Badge',
      description: '500 questions mastered',
      price: 500,
      icon: 'ðŸŽ“',
      rarity: 'rare',
      category: 'badge'
    }
  ],

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ THEMES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  themes: [
    {
      id: 'default',
      name: 'Classic Blue',
      description: 'Original ChemLeung theme',
      price: 0,
      preview: 'linear-gradient(135deg, #2563eb, #1e40af)',
      rarity: 'common',
      category: 'theme'
    },
    {
      id: 'forest',
      name: 'Forest Green',
      description: 'Organic chemistry vibes',
      price: 150,
      preview: 'linear-gradient(135deg, #10b981, #059669)',
      rarity: 'uncommon',
      category: 'theme'
    },
    {
      id: 'sunset',
      name: 'Sunset Orange',
      description: 'Warm combustion colors',
      price: 200,
      preview: 'linear-gradient(135deg, #f97316, #ea580c)',
      rarity: 'rare',
      category: 'theme'
    },
    {
      id: 'royal',
      name: 'Royal Purple',
      description: 'Permanganate elegance',
      price: 300,
      preview: 'linear-gradient(135deg, #9333ea, #7e22ce)',
      rarity: 'epic',
      category: 'theme'
    }
  ]
};

// Flatten all items for easy lookup
export const ALL_ITEMS = [
  ...STORE_ITEMS.profilePics,
  ...STORE_ITEMS.badges,
  ...STORE_ITEMS.themes
];

// Get item by ID
export function getItemById(itemId) {
  return ALL_ITEMS.find(item => item.id === itemId);
}

// Rarity colors
export const RARITY_COLORS = {
  common: 'from-slate-400 to-slate-500',
  uncommon: 'from-green-400 to-green-600',
  rare: 'from-blue-400 to-blue-600',
  epic: 'from-purple-400 to-purple-600',
  legendary: 'from-amber-400 to-amber-600'
};

export const RARITY_BORDER = {
  common: 'border-slate-300',
  uncommon: 'border-green-300',
  rare: 'border-blue-300',
  epic: 'border-purple-300',
  legendary: 'border-amber-300'
};

export const RARITY_LABELS = {
  common: 'Common',
  uncommon: 'Uncommon',
  rare: 'Rare',
  epic: 'Epic',
  legendary: 'Legendary'
};
--- END OF FILE: src/utils/storeItems.js ---


--- START OF FILE: src/components/dashboard/SmartMonthlyCalendar.jsx ---
import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { ChevronLeft, ChevronRight, Plus, Flag, Calendar as CalendarIcon, BookOpen, Brain, CheckCircle, Trash2, X } from 'lucide-react';
import { calendarService, EVENT_TYPES } from '../../services/calendarService';
import { quizStorage } from '../../utils/quizStorage';
import { motion, AnimatePresence } from 'framer-motion';

/**
 * SmartMonthlyCalendar - Real monthly calendar with exam tracking, study plans, and spaced repetition
 */
export default function SmartMonthlyCalendar({ userId, questions = [], onAddEvent }) {
  const navigate = useNavigate();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [calendarData, setCalendarData] = useState({});
  const [loading, setLoading] = useState(true);
  const [selectedDate, setSelectedDate] = useState(null);
  const [hoveredDate, setHoveredDate] = useState(null);
  
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  
  // Load calendar data
  useEffect(() => {
    loadCalendarData();
  }, [userId, year, month]);

  async function loadCalendarData() {
    if (!userId) return;
    
    try {
      setLoading(false);
      const data = await calendarService.getCalendarData(userId, year, month);
      setCalendarData(data);
    } catch (error) {
      console.error('Error loading calendar data:', error);
    } finally {
      setLoading(false);
    }
  }

  // Generate calendar grid
  const calendarGrid = useMemo(() => {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startingDayOfWeek = firstDay.getDay();
    const daysInMonth = lastDay.getDate();
    
    const grid = [];
    let week = [];
    
    // Add empty cells for days before month starts
    for (let i = 0; i < startingDayOfWeek; i++) {
      week.push(null);
    }
    
    // Add all days in month
    for (let day = 1; day <= daysInMonth; day++) {
      week.push(day);
      
      if (week.length === 7) {
        grid.push(week);
        week = [];
      }
    }
    
    // Add remaining days to complete the last week
    if (week.length > 0) {
      while (week.length < 7) {
        week.push(null);
      }
      grid.push(week);
    }
    
    return grid;
  }, [year, month]);

  const monthName = new Date(year, month, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  const today = new Date().toISOString().split('T')[0];

  function prevMonth() {
    setCurrentDate(new Date(year, month - 1, 1));
  }

  function nextMonth() {
    setCurrentDate(new Date(year, month + 1, 1));
  }

  function getDateString(day) {
    if (!day) return null;
    return new Date(year, month, day).toISOString().split('T')[0];
  }

  function getDayEvents(day) {
    const dateStr = getDateString(day);
    if (!dateStr) return null;
    return calendarData[dateStr] || null;
  }

  function isToday(day) {
    return getDateString(day) === today;
  }

  function isPast(day) {
    if (!day) return false;
    return getDateString(day) < today;
  }

  async function handleStudySuggestionClick(suggestion) {
    try {
      // Filter questions by topic/subtopic if specified
      let filteredQuestions = questions;
      
      if (suggestion.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.Topic === suggestion.topic);
      }
      
      if (suggestion.subtopic) {
        filteredQuestions = filteredQuestions.filter(q => q.Subtopic === suggestion.subtopic);
      }

      // Select random questions up to the suggested count
      const selectedQuestions = filteredQuestions
        .sort(() => Math.random() - 0.5)
        .slice(0, Math.min(suggestion.questionCount, filteredQuestions.length));

      if (selectedQuestions.length === 0) {
        alert('No questions available for this topic.');
        return;
      }

      // Save to quiz storage and navigate
      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions(selectedQuestions);
      localStorage.setItem('quiz_mode', 'study-plan');
      localStorage.setItem('quiz_event_id', suggestion.id);
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting study session:', error);
      alert('Failed to start study session. Please try again.');
    }
  }

  async function handleSpacedRepetitionClick(repetition) {
    try {
      // Load the specific mistake question
      const mistakeQuestion = questions.find(q => q.ID === repetition.questionId);
      
      if (!mistakeQuestion) {
        alert('Question not found.');
        return;
      }

      // Start quiz with just this question
      quizStorage.clearQuizData();
      quizStorage.saveSelectedQuestions([mistakeQuestion]);
      localStorage.setItem('quiz_mode', 'spaced-repetition');
      localStorage.setItem('quiz_event_id', repetition.id);
      localStorage.setItem('quiz_timer_enabled', 'true');
      navigate('/quiz');
    } catch (error) {
      console.error('Error starting spaced repetition:', error);
      alert('Failed to start review. Please try again.');
    }
  }

  async function handleDeleteEvent(eventId, event) {
    event.stopPropagation();
    
    if (!window.confirm('Delete this event? This will also remove all linked study suggestions.')) {
      return;
    }
    
    try {
      await calendarService.deleteEvent(eventId, true);
      await loadCalendarData();
    } catch (error) {
      console.error('Error deleting event:', error);
      alert('Failed to delete event.');
    }
  }

  // Render day cell content
  function renderDayCell(day) {
    if (!day) return null;
    
    const dateStr = getDateString(day);
    const events = getDayEvents(day);
    const isSelectedDate = selectedDate === dateStr;
    const isHovered = hoveredDate === dateStr;
    const isTodayDate = isToday(day);
    const isPastDate = isPast(day);
    
    const hasExam = events?.exams?.length > 0;
    const hasQuiz = events?.quizzes?.length > 0;
    const hasSuggestions = events?.suggestions?.length > 0;
    const hasRepetitions = events?.repetitions?.length > 0;
    const hasCompletions = events?.completions?.length > 0;
    
    const totalEvents = (events?.exams?.length || 0) + 
                       (events?.quizzes?.length || 0) + 
                       (events?.suggestions?.length || 0) + 
                       (events?.repetitions?.length || 0);

    return (
      <div className="flex flex-col h-full p-1">
        {/* Day number */}
        <div className={`text-sm font-bold mb-1 ${
          isTodayDate ? 'text-blue-600' : isPastDate ? 'text-slate-400' : 'text-slate-700'
        }`}>
          {day}
        </div>
        
        {/* Event markers */}
        <div className="flex-1 flex flex-col gap-0.5 overflow-hidden">
          {/* Major Exam */}
          {hasExam && events.exams.map((exam, idx) => (
            <div
              key={`exam-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-red-100 text-red-700 font-semibold hover:bg-red-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <Flag size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{exam.title}</span>
              {!exam.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(exam.id, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Small Quiz */}
          {hasQuiz && events.quizzes.map((quiz, idx) => (
            <div
              key={`quiz-${idx}`}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-amber-100 text-amber-700 font-semibold hover:bg-amber-200 transition-colors cursor-pointer group relative"
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
            >
              <BookOpen size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{quiz.title}</span>
              {!quiz.completed && (
                <button
                  onClick={(e) => handleDeleteEvent(quiz.id, e)}
                  className="opacity-0 group-hover:opacity-100 transition-opacity"
                >
                  <X size={10} />
                </button>
              )}
            </div>
          ))}
          
          {/* Study Suggestions */}
          {hasSuggestions && events.suggestions.slice(0, 2).map((suggestion, idx) => (
            <button
              key={`suggestion-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleStudySuggestionClick(suggestion);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-blue-100 text-blue-700 font-semibold hover:bg-blue-200 transition-colors group"
            >
              <CalendarIcon size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">{suggestion.questionCount} MCQs</span>
              {suggestion.completed && <CheckCircle size={10} className="text-blue-600" />}
            </button>
          ))}
          
          {/* Spaced Repetition */}
          {hasRepetitions && events.repetitions.slice(0, 1).map((rep, idx) => (
            <button
              key={`rep-${idx}`}
              onClick={(e) => {
                e.stopPropagation();
                handleSpacedRepetitionClick(rep);
              }}
              className="flex items-center gap-1 text-xs px-1.5 py-0.5 rounded bg-purple-100 text-purple-700 font-semibold hover:bg-purple-200 transition-colors"
            >
              <Brain size={10} className="flex-shrink-0" />
              <span className="truncate flex-1">Review</span>
              {rep.completed && <CheckCircle size={10} className="text-purple-600" />}
            </button>
          ))}
          
          {/* Overflow indicator */}
          {totalEvents > 3 && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                setSelectedDate(dateStr);
              }}
              className="text-xs text-slate-500 hover:text-slate-700 font-semibold px-1"
            >
              +{totalEvents - 3} more
            </button>
          )}
          
          {/* Completion dots */}
          {hasCompletions && events.completions.length <= 3 && (
            <div className="flex gap-0.5 mt-auto">
              {events.completions.slice(0, 3).map((comp, idx) => (
                <div
                  key={`comp-${idx}`}
                  className="w-1.5 h-1.5 rounded-full bg-green-500"
                  title={`Completed: ${comp.questionCount} questions`}
                />
              ))}
            </div>
          )}
          {hasCompletions && events.completions.length > 3 && (
            <div className="text-xs text-green-600 font-bold px-1">
              âœ“ {events.completions.length}
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-2xl shadow-lg border-2 border-slate-100 p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-blue-100 flex items-center justify-center">
            <CalendarIcon className="text-blue-600" size={28} />
          </div>
          <div>
            <h3 className="text-xl font-black text-slate-800">Smart Study Calendar</h3>
            <p className="text-xs text-slate-500 mt-1">{monthName}</p>
          </div>
        </div>
        
        <div className="flex items-center gap-2">
          <button
            onClick={prevMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronLeft size={20} className="text-slate-600" />
          </button>
          <button
            onClick={nextMonth}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <ChevronRight size={20} className="text-slate-600" />
          </button>
          <button
            onClick={onAddEvent}
            className="ml-2 px-4 py-2 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition-all flex items-center gap-2"
          >
            <Plus size={16} />
            Add Event
          </button>
        </div>
      </div>

      {/* Legend */}
      <div className="grid grid-cols-2 md:grid-cols-5 gap-2 mb-4 text-xs">
        <div className="flex items-center gap-1.5">
          <Flag size={12} className="text-red-600" />
          <span className="text-slate-600 font-semibold">Major Exam</span>
        </div>
        <div className="flex items-center gap-1.5">
          <BookOpen size={12} className="text-amber-600" />
          <span className="text-slate-600 font-semibold">Quiz</span>
        </div>
        <div className="flex items-center gap-1.5">
          <CalendarIcon size={12} className="text-blue-600" />
          <span className="text-slate-600 font-semibold">Study Plan</span>
        </div>
        <div className="flex items-center gap-1.5">
          <Brain size={12} className="text-purple-600" />
          <span className="text-slate-600 font-semibold">Review</span>
        </div>
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-green-500" />
          <span className="text-slate-600 font-semibold">Completed</span>
        </div>
      </div>

      {/* Calendar Grid */}
      <div className="border-2 border-slate-200 rounded-lg overflow-hidden">
        {/* Day headers */}
        <div className="grid grid-cols-7 bg-slate-50 border-b-2 border-slate-200">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
            <div
              key={day}
              className="p-2 text-center text-sm font-black text-slate-600 uppercase tracking-wider"
            >
              {day}
            </div>
          ))}
        </div>

        {/* Calendar body */}
        {calendarGrid.map((week, weekIdx) => (
          <div key={weekIdx} className="grid grid-cols-7 border-b border-slate-200 last:border-b-0">
            {week.map((day, dayIdx) => (
              <div
                key={dayIdx}
                onMouseEnter={() => day && setHoveredDate(getDateString(day))}
                onMouseLeave={() => setHoveredDate(null)}
                onClick={() => day && setSelectedDate(getDateString(day))}
                className={`min-h-[100px] border-r border-slate-200 last:border-r-0 transition-all cursor-pointer ${
                  day ? 'hover:bg-slate-50' : 'bg-slate-50/30'
                } ${
                  isToday(day) ? 'bg-blue-50 ring-2 ring-inset ring-blue-400' : ''
                } ${
                  isPast(day) ? 'opacity-60' : ''
                }`}
              >
                {renderDayCell(day)}
              </div>
            ))}
          </div>
        ))}
      </div>

      {/* Day Detail Modal */}
      <AnimatePresence>
        {selectedDate && (
          <div 
            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
            onClick={() => setSelectedDate(null)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              onClick={(e) => e.stopPropagation()}
              className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto"
            >
              <div className="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
                <h3 className="text-lg font-black text-slate-800">
                  {new Date(selectedDate).toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                  })}
                </h3>
                <button
                  onClick={() => setSelectedDate(null)}
                  className="p-2 hover:bg-slate-100 rounded-lg transition-all"
                >
                  <X size={20} />
                </button>
              </div>
              
              <div className="p-6 space-y-4">
                {calendarData[selectedDate] ? (
                  <>
                    {/* Exams */}
                    {calendarData[selectedDate].exams?.map((exam) => (
                      <div key={exam.id} className="p-4 rounded-lg bg-red-50 border-2 border-red-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <Flag className="text-red-600" size={20} />
                            <span className="font-bold text-red-900">{exam.title}</span>
                          </div>
                          <button
                            onClick={(e) => handleDeleteEvent(exam.id, e)}
                            className="p-1 hover:bg-red-100 rounded transition-all"
                          >
                            <Trash2 size={16} className="text-red-600" />
                          </button>
                        </div>
                        {exam.topic && (
                          <div className="text-sm text-red-700">
                            Topic: {exam.topic}
                            {exam.subtopic && ` â†’ ${exam.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* Quizzes */}
                    {calendarData[selectedDate].quizzes?.map((quiz) => (
                      <div key={quiz.id} className="p-4 rounded-lg bg-amber-50 border-2 border-amber-200">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-2">
                            <BookOpen className="text-amber-600" size={20} />
                            <span className="font-bold text-amber-900">{quiz.title}</span>
                          </div>
                          <button
                            onClick={(e) => handleDeleteEvent(quiz.id, e)}
                            className="p-1 hover:bg-amber-100 rounded transition-all"
                          >
                            <Trash2 size={16} className="text-amber-600" />
                          </button>
                        </div>
                        {quiz.topic && (
                          <div className="text-sm text-amber-700">
                            Topic: {quiz.topic}
                            {quiz.subtopic && ` â†’ ${quiz.subtopic}`}
                          </div>
                        )}
                      </div>
                    ))}
                    
                    {/* Study Suggestions */}
                    {calendarData[selectedDate].suggestions?.map((suggestion) => (
                      <button
                        key={suggestion.id}
                        onClick={() => {
                          handleStudySuggestionClick(suggestion);
                          setSelectedDate(null);
                        }}
                        className="w-full p-4 rounded-lg bg-blue-50 border-2 border-blue-200 hover:bg-blue-100 transition-all text-left"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <CalendarIcon className="text-blue-600" size={20} />
                          <span className="font-bold text-blue-900">{suggestion.title}</span>
                          {suggestion.completed && <CheckCircle size={16} className="text-blue-600 ml-auto" />}
                        </div>
                        <div className="text-sm text-blue-700">
                          {suggestion.questionCount} questions
                          {suggestion.phase && ` â€¢ ${suggestion.phase}`}
                          {suggestion.includeMistakes && ' â€¢ Includes mistake review'}
                        </div>
                      </button>
                    ))}
                    
                    {/* Spaced Repetitions */}
                    {calendarData[selectedDate].repetitions?.map((rep) => (
                      <button
                        key={rep.id}
                        onClick={() => {
                          handleSpacedRepetitionClick(rep);
                          setSelectedDate(null);
                        }}
                        className="w-full p-4 rounded-lg bg-purple-50 border-2 border-purple-200 hover:bg-purple-100 transition-all text-left"
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <Brain className="text-purple-600" size={20} />
                          <span className="font-bold text-purple-900">{rep.title}</span>
                          {rep.completed && <CheckCircle size={16} className="text-purple-600 ml-auto" />}
                        </div>
                        <div className="text-sm text-purple-700">
                          Review interval: {rep.interval} days â€¢ Attempt #{rep.attemptCount}
                        </div>
                      </button>
                    ))}
                    
                    {/* Completions */}
                    {calendarData[selectedDate].completions?.length > 0 && (
                      <div className="p-4 rounded-lg bg-green-50 border-2 border-green-200">
                        <div className="flex items-center gap-2 mb-2">
                          <CheckCircle className="text-green-600" size={20} />
                          <span className="font-bold text-green-900">
                            {calendarData[selectedDate].completions.length} Session(s) Completed
                          </span>
                        </div>
                        <div className="space-y-1">
                          {calendarData[selectedDate].completions.map((comp, idx) => (
                            <div key={idx} className="text-sm text-green-700">
                              {comp.questionCount} questions â€¢ {Math.round(comp.accuracy * 100)}% accuracy
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                ) : (
                  <div className="text-center py-8 text-slate-400">
                    No events scheduled for this day
                  </div>
                )}
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>
    </div>
  );
}
--- END OF FILE: src/components/dashboard/SmartMonthlyCalendar.jsx ---


--- START OF FILE: src/components/dashboard/EventCreationModal.jsx ---
import React, { useState, useMemo } from 'react';
import { X, Flag, BookOpen, Calendar, Tag, Layers } from 'lucide-react';
import { motion } from 'framer-motion';
import { calendarService } from '../../services/calendarService';

/**
 * EventCreationModal - UI for adding Major Exams and Small Quizzes
 */
export default function EventCreationModal({ userId, questions = [], onClose, onEventCreated }) {
  const [eventType, setEventType] = useState('major_exam'); // 'major_exam' or 'small_quiz'
  const [title, setTitle] = useState('');
  const [date, setDate] = useState('');
  const [topic, setTopic] = useState('');
  const [subtopic, setSubtopic] = useState('');
  const [loading, setLoading] = useState(false);

  // Extract unique topics and subtopics from questions
  const topics = useMemo(() => {
    const topicSet = new Set(questions.map(q => q.Topic).filter(Boolean));
    return ['', ...Array.from(topicSet)].sort();
  }, [questions]);

  const subtopics = useMemo(() => {
    if (!topic) return [''];
    const subtopicSet = new Set(
      questions
        .filter(q => q.Topic === topic && q.Subtopic)
        .map(q => q.Subtopic)
    );
    return ['', ...Array.from(subtopicSet)].sort();
  }, [questions, topic]);

  const minDate = new Date().toISOString().split('T')[0];

  async function handleSubmit(e) {
    e.preventDefault();
    
    if (!date || !title.trim()) {
      alert('Please fill in all required fields.');
      return;
    }

    setLoading(true);
    
    try {
      const eventData = {
        date,
        title: title.trim(),
        topic: topic || null,
        subtopic: subtopic || null
      };

      if (eventType === 'major_exam') {
        await calendarService.addMajorExam(userId, eventData);
      } else {
        await calendarService.addSmallQuiz(userId, eventData);
      }

      onEventCreated();
      onClose();
    } catch (error) {
      console.error('Error creating event:', error);
      alert('Failed to create event. Please try again.');
    } finally {
      setLoading(false);
    }
  }

  return (
    <div 
      className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4"
      onClick={onClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        onClick={(e) => e.stopPropagation()}
        className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full"
      >
        {/* Header */}
        <div className="border-b p-6 flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-black text-slate-800">Add Event</h2>
            <p className="text-sm text-slate-500 mt-1">Schedule an exam or quiz and get a smart study plan</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all"
          >
            <X size={24} />
          </button>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* Event Type Selector */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-3">
              Event Type
            </label>
            <div className="grid grid-cols-2 gap-3">
              <button
                type="button"
                onClick={() => setEventType('major_exam')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'major_exam'
                    ? 'border-red-500 bg-red-50'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
                    eventType === 'major_exam' ? 'bg-red-100' : 'bg-slate-100'
                  }`}>
                    <Flag className={eventType === 'major_exam' ? 'text-red-600' : 'text-slate-400'} size={20} />
                  </div>
                  <span className={`font-bold ${
                    eventType === 'major_exam' ? 'text-red-900' : 'text-slate-600'
                  }`}>
                    Major Exam
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  10-day study plan with scaled intensity
                </div>
              </button>

              <button
                type="button"
                onClick={() => setEventType('small_quiz')}
                className={`p-4 rounded-xl border-2 transition-all ${
                  eventType === 'small_quiz'
                    ? 'border-amber-500 bg-amber-50'
                    : 'border-slate-200 hover:border-slate-300'
                }`}
              >
                <div className="flex items-center gap-3 mb-2">
                  <div className={`w-10 h-10 rounded-lg flex items-center justify-center ${
                    eventType === 'small_quiz' ? 'bg-amber-100' : 'bg-slate-100'
                  }`}>
                    <BookOpen className={eventType === 'small_quiz' ? 'text-amber-600' : 'text-slate-400'} size={20} />
                  </div>
                  <span className={`font-bold ${
                    eventType === 'small_quiz' ? 'text-amber-900' : 'text-slate-600'
                  }`}>
                    Small Quiz
                  </span>
                </div>
                <div className="text-xs text-slate-500 text-left">
                  3-day focused review plan
                </div>
              </button>
            </div>
          </div>

          {/* Study Plan Preview */}
          <div className={`p-4 rounded-xl border-2 ${
            eventType === 'major_exam' 
              ? 'bg-red-50 border-red-200' 
              : 'bg-amber-50 border-amber-200'
          }`}>
            <div className="flex items-center gap-2 mb-3">
              <Calendar className={eventType === 'major_exam' ? 'text-red-600' : 'text-amber-600'} size={18} />
              <span className={`font-bold text-sm ${
                eventType === 'major_exam' ? 'text-red-900' : 'text-amber-900'
              }`}>
                Auto-Generated Study Plan
              </span>
            </div>
            {eventType === 'major_exam' ? (
              <ul className="space-y-1 text-xs text-red-700">
                <li>â€¢ <strong>10-7 days before:</strong> 10 MCQs/day (Warm-up)</li>
                <li>â€¢ <strong>6-4 days before:</strong> 20 MCQs/day (Consolidation)</li>
                <li>â€¢ <strong>3-1 days before:</strong> 40 MCQs/day (Sprint Intensity)</li>
              </ul>
            ) : (
              <ul className="space-y-1 text-xs text-amber-700">
                <li>â€¢ <strong>3 days before:</strong> 5 MCQs (Initial Review)</li>
                <li>â€¢ <strong>2 days before:</strong> 10 MCQs (Topic Focus)</li>
                <li>â€¢ <strong>1 day before:</strong> 15 MCQs + Mistake Review (Final Polish)</li>
              </ul>
            )}
          </div>

          {/* Title Input */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Event Title *
            </label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={eventType === 'major_exam' ? 'e.g., Chemistry Final Exam' : 'e.g., Organic Chemistry Quiz'}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
              required
            />
          </div>

          {/* Date Input */}
          <div>
            <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2">
              Exam/Quiz Date *
            </label>
            <input
              type="date"
              value={date}
              onChange={(e) => setDate(e.target.value)}
              min={minDate}
              className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
              required
            />
          </div>

          {/* Topic Selection */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2 flex items-center gap-1">
                <Tag size={14} />
                Topic (Optional)
              </label>
              <select
                value={topic}
                onChange={(e) => {
                  setTopic(e.target.value);
                  setSubtopic('');
                }}
                className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium"
              >
                <option value="">All Topics</option>
                {topics.slice(1).map((t) => (
                  <option key={t} value={t}>{t}</option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-black text-slate-700 uppercase tracking-wider mb-2 flex items-center gap-1">
                <Layers size={14} />
                Subtopic (Optional)
              </label>
              <select
                value={subtopic}
                onChange={(e) => setSubtopic(e.target.value)}
                disabled={!topic}
                className="w-full px-4 py-3 rounded-lg border-2 border-slate-200 focus:border-indigo-500 focus:outline-none transition-all font-medium disabled:bg-slate-50 disabled:text-slate-400"
              >
                <option value="">All Subtopics</option>
                {subtopics.slice(1).map((s) => (
                  <option key={s} value={s}>{s}</option>
                ))}
              </select>
            </div>
          </div>

          {/* Info Box */}
          <div className="p-4 rounded-lg bg-blue-50 border border-blue-200">
            <p className="text-sm text-blue-900">
              <strong>ðŸ’¡ Smart Study Plan:</strong> We'll automatically create daily study suggestions 
              leading up to your {eventType === 'major_exam' ? 'exam' : 'quiz'}. Each suggestion will be 
              clickable and will start a quiz session with the exact number of questions recommended.
            </p>
          </div>

          {/* Submit Buttons */}
          <div className="flex gap-3 pt-4 border-t">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-6 py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-xl font-bold transition-all"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className={`flex-1 px-6 py-3 rounded-xl font-bold transition-all text-white ${
                eventType === 'major_exam'
                  ? 'bg-red-600 hover:bg-red-700'
                  : 'bg-amber-600 hover:bg-amber-700'
              } disabled:opacity-50 disabled:cursor-not-allowed`}
            >
              {loading ? 'Creating...' : `Create ${eventType === 'major_exam' ? 'Exam' : 'Quiz'} & Study Plan`}
            </button>
          </div>
        </form>
      </motion.div>
    </div>
  );
}
--- END OF FILE: src/components/dashboard/EventCreationModal.jsx ---


--- START OF FILE: src/components/QuizEngine.jsx ---
import React, { useState, useEffect, useRef } from 'react';
import QuestionCard from './QuestionCard';
import { ChevronLeft, ChevronRight, Send, Timer, FlaskConical, Flag, Clock, X } from 'lucide-react';
import { calendarService } from '../services/calendarService';
import { useAuth } from '../context/AuthContext';

export default function QuizEngine({ questions, onComplete }) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [answers, setAnswers] = useState({});
  const [flagged, setFlagged] = useState(new Set());
  const [showPeriodicTable, setShowPeriodicTable] = useState(false);
  const [showQuestionPanel, setShowQuestionPanel] = useState(false);
  const [timerEnabled, setTimerEnabled] = useState(null);
  const [questionTimes, setQuestionTimes] = useState({});
  const [currentQuestionStartTime, setCurrentQuestionStartTime] = useState(null);
  const [currentTime, setCurrentTime] = useState(Date.now());
  const [sessionStartTime, setSessionStartTime] = useState(null);
  const timerInitialized = useRef(false);
  
  const { currentUser } = useAuth();
  const currentQuestion = questions[currentIndex];
  const totalQuestions = questions.length;
  const progress = ((currentIndex + 1) / totalQuestions) * 100;

  // Timer initialization prompt - only once
  useEffect(() => {
    if (timerEnabled === null && !timerInitialized.current) {
      timerInitialized.current = true;
      const enableTimer = window.confirm(
        "Do you want to enable the timer?\n\n" +
        "The timer will track how long you spend on each question.\n\n" +
        "Click OK to enable, Cancel to skip."
      );
      setTimerEnabled(enableTimer);
      if (enableTimer) {
        const now = Date.now();
        setCurrentQuestionStartTime(now);
        setSessionStartTime(now);
      }
    }
  }, [timerEnabled]);

  // Live timer update - updates every second
  useEffect(() => {
    if (!timerEnabled) return;
    
    const interval = setInterval(() => {
      setCurrentTime(Date.now());
    }, 1000);

    return () => clearInterval(interval);
  }, [timerEnabled]);

  // Start timer when changing questions
  useEffect(() => {
    if (timerEnabled && currentQuestion) {
      setCurrentQuestionStartTime(Date.now());
    }
  }, [currentIndex, timerEnabled]);

  // Record time when leaving a question
  const recordQuestionTime = () => {
    if (timerEnabled && currentQuestionStartTime) {
      const timeSpent = Date.now() - currentQuestionStartTime;
      setQuestionTimes(prev => ({
        ...prev,
        [currentQuestion.ID]: (prev[currentQuestion.ID] || 0) + timeSpent
      }));
    }
  };

  /**
   * Handle quiz completion with calendar integration
   */
  async function handleQuizComplete(finalAnswers, finalQuestionTimes) {
    try {
      // Log completion to calendar
      const quizMode = localStorage.getItem('quiz_mode');
      const eventId = localStorage.getItem('quiz_event_id');
      
      if (currentUser?.uid) {
        const correctCount = Object.entries(finalAnswers).filter(([qId, answer]) => {
          const question = questions.find(q => q.ID === qId);
          return question && answer === question.CorrectOption;
        }).length;

        // Log completion
        await calendarService.logCompletion(currentUser.uid, new Date().toISOString(), {
          type: quizMode || 'practice',
          topic: questions[0]?.Topic || 'Mixed',
          questionCount: questions.length,
          correctCount
        });

        // Mark linked event as completed if exists
        if (eventId && (quizMode === 'study-plan' || quizMode === 'spaced-repetition')) {
          await calendarService.markEventCompleted(eventId);
        }
      }

      // Clear event tracking
      localStorage.removeItem('quiz_event_id');
      
      // Call original completion handler
      onComplete(finalAnswers, timerEnabled ? finalQuestionTimes : null);
    } catch (error) {
      console.error('Error handling quiz completion:', error);
      // Still complete the quiz even if logging fails
      onComplete(finalAnswers, timerEnabled ? finalQuestionTimes : null);
    }
  }

  const handleOptionSelect = (option) => {
    setAnswers({
      ...answers,
      [currentQuestion.ID]: option
    });
  };

  const toggleFlag = () => {
    const questionId = currentQuestion.ID;
    setFlagged(prev => {
      const newSet = new Set(prev);
      if (newSet.has(questionId)) {
        newSet.delete(questionId);
      } else {
        newSet.add(questionId);
      }
      return newSet;
    });
  };

  const nextQuestion = () => {
    recordQuestionTime();
    if (currentIndex < totalQuestions - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const prevQuestion = () => {
    recordQuestionTime();
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  const jumpToQuestion = (index) => {
    recordQuestionTime();
    setCurrentIndex(index);
    setShowQuestionPanel(false);
  };

  const isLastQuestion = currentIndex === totalQuestions - 1;
  const allAnswered = Object.keys(answers).length === totalQuestions;

  // Calculate total time spent (accumulated + current question time)
  const getTotalTimeSpent = () => {
    const accumulated = Object.values(questionTimes).reduce((sum, time) => sum + time, 0);
    if (timerEnabled && currentQuestionStartTime) {
      const currentQuestionTime = currentTime - currentQuestionStartTime;
      return accumulated + currentQuestionTime;
    }
    return accumulated;
  };

  // Calculate session time
  const getSessionTime = () => {
    if (timerEnabled && sessionStartTime) {
      return currentTime - sessionStartTime;
    }
    return 0;
  };

  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hrs = Math.floor(minutes / 60);
    if (hrs > 0) {
      return `${hrs}:${String(minutes % 60).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
    }
    return `${minutes}:${String(seconds % 60).padStart(2, '0')}`;
  };

  // Get question status
  const getQuestionStatus = (q) => {
    if (answers[q.ID]) return 'answered';
    if (flagged.has(q.ID)) return 'flagged';
    return 'skipped';
  };

  if (timerEnabled === null) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="text-center">
          <Clock className="animate-pulse text-lab-blue w-12 h-12 mx-auto mb-4" />
          <p className="text-slate-600">Initializing quiz...</p>
        </div>
      </div>
    );
  }

  const totalTimeSpent = getTotalTimeSpent();
  const sessionTime = getSessionTime();

  return (
    <div className="relative h-screen overflow-hidden">
      {/* Fixed Left Sidebar */}
      <div className="fixed left-8 top-32 flex flex-col gap-4 z-30 h-[calc(100vh-10rem)]">
        {/* Timer Display */}
        {timerEnabled && (
          <div className="bg-white rounded-2xl shadow-xl border-2 border-lab-blue p-6 w-48">
            <div className="text-center">
              <div className="flex items-center justify-center gap-2 mb-2">
                <Timer className="text-lab-blue" size={24} />
                <span className="text-sm font-bold text-slate-600">SESSION TIME</span>
              </div>
              <div className="text-4xl font-black text-lab-blue mb-4 font-mono">
                {formatTime(sessionTime)}
              </div>
              <div className="text-xs text-slate-500 border-t pt-2">
                <div className="flex justify-between mb-1">
                  <span>Active Time:</span>
                  <span className="font-bold">{formatTime(totalTimeSpent)}</span>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Periodic Table Button */}
        <button
          onClick={() => setShowPeriodicTable(true)}
          className="flex items-center gap-2 px-6 py-4 bg-purple-600 text-white rounded-xl font-bold hover:bg-purple-700 transition-all shadow-lg hover:scale-105 active:scale-95"
        >
          <FlaskConical size={20} />
          <span>Periodic Table</span>
        </button>

        {/* Question Panel Button */}
        <button
          onClick={() => setShowQuestionPanel(!showQuestionPanel)}
          className="flex items-center gap-2 px-6 py-4 bg-slate-700 text-white rounded-xl font-bold hover:bg-slate-800 transition-all shadow-lg hover:scale-105 active:scale-95"
        >
          <Flag size={20} />
          <span>Overview</span>
        </button>

        {/* Spacer to push button to bottom */}
        <div className="flex-1"></div>

        {/* Previous Button - Left Side - Aligned to bottom */}
        <button
          onClick={prevQuestion}
          disabled={currentIndex === 0}
          className="flex items-center justify-center w-16 h-16 bg-lab-blue text-white rounded-full font-bold hover:bg-blue-800 disabled:bg-slate-300 disabled:cursor-not-allowed transition-all shadow-lg hover:scale-110 active:scale-95"
        >
          <ChevronLeft size={32} />
        </button>
      </div>

      {/* Fixed Right Sidebar */}
      <div className="fixed right-8 top-32 flex flex-col gap-4 z-30 h-[calc(100vh-10rem)]">
        {/* Flag Button */}
        <button
          onClick={toggleFlag}
          className={`w-16 h-16 rounded-full flex items-center justify-center transition-all shadow-lg hover:scale-110 active:scale-95 ${
            flagged.has(currentQuestion?.ID)
              ? 'bg-amber-500 text-white hover:bg-amber-600'
              : 'bg-white text-amber-500 border-2 border-amber-500 hover:bg-amber-50'
          }`}
          title={flagged.has(currentQuestion?.ID) ? 'Unflag Question' : 'Flag Question'}
        >
          <Flag size={28} fill={flagged.has(currentQuestion?.ID) ? 'currentColor' : 'none'} />
        </button>

        {/* Spacer to push button to bottom */}
        <div className="flex-1"></div>

        {/* Next/Submit Button - Right Side - Aligned to bottom */}
        {!isLastQuestion ? (
          <button
            onClick={nextQuestion}
            className="flex items-center justify-center w-16 h-16 bg-lab-blue text-white rounded-full font-bold hover:bg-blue-800 transition-all shadow-lg hover:scale-110 active:scale-95"
          >
            <ChevronRight size={32} />
          </button>
        ) : (
          <button
            onClick={() => {
              recordQuestionTime();
              handleQuizComplete(answers, timerEnabled ? questionTimes : null);
            }}
            className={`flex items-center justify-center w-16 h-16 rounded-full font-bold transition-all shadow-lg hover:scale-110 active:scale-95 ${
              allAnswered 
                ? 'bg-chemistry-green text-white hover:opacity-90' 
                : 'bg-slate-300 text-slate-500 cursor-not-allowed'
            }`}
            title="Finish & Submit"
          >
            <Send size={28} />
          </button>
        )}
      </div>

      {/* Question Overview Panel - Floating Left Sidebar */}
      {showQuestionPanel && (
        <>
          {/* Backdrop - semi-transparent to see content behind */}
          <div 
            className="fixed inset-0 z-40"
            style={{ backgroundColor: 'rgba(0, 0, 0, 0.15)' }}
            onClick={() => setShowQuestionPanel(false)}
          />
          
          {/* Panel - narrower sidebar on the left */}
          <div className="fixed left-0 top-0 h-full w-80 bg-white shadow-2xl z-50 overflow-y-auto animate-in slide-in-from-left duration-300">
            <div className="sticky top-0 bg-white border-b p-6 flex justify-between items-center">
              <h3 className="text-lg font-bold text-slate-800">Question Overview</h3>
              <button 
                onClick={() => setShowQuestionPanel(false)}
                className="text-slate-400 hover:text-slate-600 p-2 rounded-full hover:bg-slate-100"
              >
                <X size={20} />
              </button>
            </div>
            
            <div className="p-6">
              <div className="flex flex-col gap-3 mb-6 text-sm">
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded bg-chemistry-green"></div>
                  <span>Answered ({Object.keys(answers).length})</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded bg-amber-500"></div>
                  <span>Flagged ({flagged.size})</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded bg-slate-200"></div>
                  <span>Skipped ({totalQuestions - Object.keys(answers).length})</span>
                </div>
              </div>

              <div className="grid grid-cols-4 gap-3">
                {questions.map((q, idx) => {
                  const status = getQuestionStatus(q);
                  return (
                    <button
                      key={q.ID}
                      onClick={() => jumpToQuestion(idx)}
                      className={`aspect-square rounded-xl font-bold text-base transition-all border-2 ${
                        idx === currentIndex
                          ? 'border-lab-blue ring-2 ring-lab-blue ring-offset-2'
                          : 'border-transparent'
                      } ${
                        status === 'answered'
                          ? 'bg-chemistry-green text-white hover:opacity-80'
                          : status === 'flagged'
                          ? 'bg-amber-500 text-white hover:opacity-80'
                          : 'bg-slate-200 text-slate-600 hover:bg-slate-300'
                      }`}
                    >
                      {idx + 1}
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        </>
      )}

      {/* Periodic Table Modal */}
      {showPeriodicTable && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
          onClick={() => setShowPeriodicTable(false)}
        >
          <div 
            className="bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-auto"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="sticky top-0 bg-white border-b p-4 flex justify-between items-center">
              <h3 className="text-xl font-bold text-slate-800">Periodic Table of Elements</h3>
              <button 
                onClick={() => setShowPeriodicTable(false)}
                className="text-slate-400 hover:text-slate-600 p-2 rounded-full hover:bg-slate-100"
              >
                <X size={24} />
              </button>
            </div>
            <div className="p-4">
              <img 
                src="https://upload.wikimedia.org/wikipedia/commons/2/2e/Simple_Periodic_Table_Chart-en.svg"
                alt="Periodic Table"
                className="w-full h-auto"
              />
            </div>
          </div>
        </div>
      )}

      {/* Main Content Area - Centered and compact */}
      <div className="max-w-5xl mx-auto px-4 py-6 h-full flex flex-col">
        {/* Progress Header - More Compact */}
        <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200 mb-4">
          <div className="flex justify-between items-center mb-2">
            <div className="flex items-baseline gap-3">
              <span className="text-3xl font-black text-lab-blue">
                Q{currentIndex + 1}
              </span>
              <span className="text-sm font-medium text-slate-500">
                of {totalQuestions}
              </span>
            </div>
            <span className="text-xl font-bold text-lab-blue">
              {Math.round(progress)}%
            </span>
          </div>
          <div className="w-full bg-slate-100 h-2 rounded-full overflow-hidden">
            <div 
              className="bg-lab-blue h-full transition-all duration-300" 
              style={{ width: `${progress}%` }}
            />
          </div>
        </div>

        {/* Question Card Component - Takes remaining space */}
        <div className="flex-1 overflow-y-auto">
          <QuestionCard 
            question={currentQuestion}
            selectedOption={answers[currentQuestion.ID]}
            onSelect={handleOptionSelect}
          />
        </div>

        {/* Mini Progress Dots */}
        <div className="flex justify-center gap-1 mt-4 py-2">
          {questions.slice(0, Math.min(30, totalQuestions)).map((_, idx) => (
            <div 
              key={idx}
              className={`w-2 h-2 rounded-full transition-all ${
                idx === currentIndex ? 'bg-lab-blue w-6' : 
                answers[questions[idx].ID] ? 'bg-chemistry-green' : 
                flagged.has(questions[idx].ID) ? 'bg-amber-500' : 'bg-slate-200'
              }`}
            />
          ))}
          {totalQuestions > 30 && <span className="text-slate-400 text-xs">...</span>}
        </div>

        {!allAnswered && isLastQuestion && (
          <p className="text-center text-sm text-amber-600 font-medium mt-2">
            Please answer all questions before submitting.
          </p>
        )}
      </div>
    </div>
  );
}
--- END OF FILE: src/components/QuizEngine.jsx ---


--- START OF FILE: src/firebase/config.js ---
// Firebase configuration and initialization
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

// Your web app's Firebase configuration
// TODO: Replace with your own Firebase config from Firebase Console
const firebaseConfig = {
  apiKey: "AIzaSyBKk_TsWIVQCXfIwPQXnFOXvSNQNDgyvFg",
  authDomain: "chemleung-hkdse-mcq-platform.firebaseapp.com",
  projectId: "chemleung-hkdse-mcq-platform",
  storageBucket: "chemleung-hkdse-mcq-platform.firebasestorage.app",
  messagingSenderId: "811594644247",
  appId: "1:811594644247:web:5282c3c73f1d3566955552",
  measurementId: "G-85R118KESK"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Initialize Firebase services
export const auth = getAuth(app);
export const db = getFirestore(app);

export default app;
--- END OF FILE: src/firebase/config.js ---

